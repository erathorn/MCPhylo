<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Output · MCPhylo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCPhylo</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="intro.html">Introduction</a></li><li><a class="tocitem" href="tree.html">Tree Functionality</a></li><li><a class="tocitem" href="likelihood.html">Likelihood</a></li><li><a class="tocitem" href="parser.html">Parser</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="model.html">Model</a></li><li class="is-active"><a class="tocitem" href="output.html">Output</a><ul class="internal"><li><a class="tocitem" href="#Chains"><span>Chains</span></a></li><li><a class="tocitem" href="#File-I/O"><span>File I/O</span></a></li><li><a class="tocitem" href="#Discrete-Diagnostics"><span>Discrete Diagnostics</span></a></li><li><a class="tocitem" href="#Gelman-Diagnostic"><span>Gelman Diagnostic</span></a></li><li><a class="tocitem" href="#Geweke-Diagnostic"><span>Geweke Diagnostic</span></a></li><li><a class="tocitem" href="#Heidel-Diagnostic"><span>Heidel Diagnostic</span></a></li><li><a class="tocitem" href="#Raftery-and-Lewis-Diagnostic"><span>Raftery and Lewis Diagnostic</span></a></li><li><a class="tocitem" href="#Monte-Carlo-Standard-Errors"><span>Monte Carlo Standard Errors</span></a></li><li><a class="tocitem" href="#ModelChains"><span>ModelChains</span></a></li><li><a class="tocitem" href="#Model-Based-Inference"><span>Model-Based Inference</span></a></li><li><a class="tocitem" href="#Plot"><span>Plot</span></a></li><li><a class="tocitem" href="#Posterior-Summary-Statistics"><span>Posterior Summary Statistics</span></a></li></ul></li><li><a class="tocitem" href="samplers.html">Samplers</a></li><li><a class="tocitem" href="utils.html">Utils</a></li><li><a class="tocitem" href="links.html">Links</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="output.html">Output</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="output.html">Output</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/Julia_Tree/blob/master/docs/src/output.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="output"><a class="docs-heading-anchor" href="#output">output</a><a id="output-1"></a><a class="docs-heading-anchor-permalink" href="#output" title="Permalink"></a></h1><h2 id="Chains"><a class="docs-heading-anchor" href="#Chains">Chains</a><a id="Chains-1"></a><a class="docs-heading-anchor-permalink" href="#Chains" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.Chains" href="#Main.MCPhylo.Chains"><code>Main.MCPhylo.Chains</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chains(iters::Integer, params::Integer;
start::Integer=1, thin::Integer=1, chains::Integer=1,
names::Vector{T}=AbstractString[]) where {T&lt;:AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L4-L8">source</a></section><section><div><pre><code class="language-none">Chains(value::Array{T, 3},
start::Integer=1, thin::Integer=1,
names::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])
where {T&lt;:Real, U&lt;:AbstractString, V&lt;:Integer, W &lt;: AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L19-L24">source</a></section><section><div><pre><code class="language-none">Chains(value::Array{T, 3},
value2::Array{U,3};
start::Integer=1, thin::Integer=1,
names::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])
where {T&lt;:Real, U&lt;:AbstractString, V&lt;:Integer, W &lt;: AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L31-L37">source</a></section><section><div><pre><code class="language-none">Chains(value::Matrix{T};
start::Integer=1, thin::Integer=1,
names::Vector{U}=AbstractString[], chains::Integer=1)
where {T&lt;:Real, U&lt;:AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L60-L65">source</a></section><section><div><pre><code class="language-none">Chains(value::Vector{T};
start::Integer=1, thin::Integer=1,
names::U=&quot;Param1&quot;, chains::Integer=1) where {T&lt;:Real, U &lt;: AbstractString}</code></pre><p>Construct a <code>Chains</code> object that stores MCMC sampler output.</p><p>Returns an object of type <code>Chains</code>.</p><ul><li><p><code>iters</code>: total number of iterations in each sampler run, of which <code>length(start:thin:iters)</code> outputted iterations will be stored in the object.</p></li><li><p><code>params</code>: number of parameters to store.</p></li><li><p><code>value</code>: array whose first, second (optional), and third (optional) dimensions index outputted iterations, parameter elements, and runs of an MCMC sampler, respectively.</p></li><li><p><code>start</code>: number of the first iteration to be stored.</p></li><li><p><code>thin</code>: number of steps between consecutive iterations to be stored.</p></li><li><p><code>chains</code>: number of simulation runs for which to store output, or indices to the runs (default: 1, 2, …).</p></li><li><p><code>names</code>: names to assign to the parameter elements (default: <code>&quot;Param1&quot;</code>, <code>&quot;Param2&quot;</code>, …).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L74-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.getindex(c::Chains, window, names, chains)</code></pre><p>Subset MCMC sampler output. The syntax <code>c[i, j, k]</code> is converted to <code>getindex(c, i, j, k)</code>.</p><p>Subsetted sampler output stored in the same type of object as that supplied in the call.</p><ul><li><p><code>c</code> : sampler output to subset.</p></li><li><p><code>window</code> : indices of the form <code>start:stop</code> or <code>start:thin:stop</code> can be used to subset iterations, where <code>start</code> and <code>stop</code> define a range for the subset and <code>thin</code> will apply additional thinning to existing sampler output.</p></li><li><p><code>names</code> : indices for subsetting of parameters that can be specified as strings, integers, or booleans identifying parameters to be kept. <code>ModelChains</code> may additionally be indexed by model node symbols.</p></li><li><p><code>chains</code> : indices for chains can be integers or booleans.</p></li></ul><p>A value of <code>:</code> can be specified for any of the dimensions to indicate no subsetting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L106-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.setindex!(c::AbstractChains, value, iters, names, chains)</code></pre><p>Store MCMC sampler output at a given index. The syntax <code>c[i, j, k] = value</code> is converted to <code>setindex!(c, value, i, j, k)</code>.</p><p>Returns an object of the same type as c with the sampler output stored in the specified indices.</p><ul><li><p><code>c</code> : object within which to store sampler output.</p></li><li><p><code>value</code> : sampler output.</p></li><li><p><code>iters</code> : iterations can be indexed as a <code>start:stop</code> or <code>start:thin:stop</code> range, a single numeric index, or a vector of indices; and are taken to be relative to the index range store in the <code>c.range</code> field.</p></li><li><p><code>names</code> : indices for subsetting of parameters can be specified as strings, integers, or booleans.</p></li><li><p><code>chains</code> : indices for chains can be integers or booleans.</p></li></ul><p>A value of <code>:</code> can be specified for any of the dimensions to indicate no subsetting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L140-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.cat(c1::AbstractChains, args::AbstractChains...; dims::Integer)</code></pre><p>Concatenate input MCMC chains along a specified dimension. For dimensions other than the specified one, all input chains must have the same sizes, which will also be the sizes of the output chain. The size of the output chain along the specified dimension will be the sum of the sizes of the input chains in that dimension. vcat concatenates vertically along dimension 1, and has the alternative syntax [chain1; chain2; ...]. hcat concatenates horizontally along dimension 2, and has the alternative syntax [chain1 chain2 ...].</p><p>Returns a <code>Chains</code> object containing the concatenated input.</p><ul><li><p><code>dim</code> : dimension (1, 2, or 3) along which to concatenate the input chains.</p></li><li><p><code>c1</code>, <code>args...</code> : Chains to concatenate.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{AbstractChains}" href="#Base.keys-Tuple{AbstractChains}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.keys(c::AbstractChains)</code></pre><p>Returns names of parameter elements.</p><ul><li><code>c</code> : Chain to return names of.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L311-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,AbstractChains}" href="#Base.show-Tuple{IO,AbstractChains}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.show(io::IO, c::AbstractChains)</code></pre><p>Prints header and values of Chain.</p><ul><li><p><code>io</code> : IO stream on which to print.</p></li><li><p><code>AbstractChains</code> : Chain to print.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L322-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.size(c::AbstractChains)</code></pre><p>Returns Tuple containing last iteration of MCMC sampler output and dimensions of Chain dimensions of c.value.</p><ul><li><code>c</code> : Chain object of interest.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L336-L343">source</a></section><section><div><pre><code class="language-none">Base.size(c::AbstractChains, ind)</code></pre><p>Returns last iteration of MCMC sampler output, or dimension derived from C, according to value of ind.</p><ul><li><p><code>c</code> : Chain object of interest.</p></li><li><p><code>ind</code> : index of tuple to return; 1 returns last iteration of MCMC sampler output, 2 and 3 return dimensions of c.value.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/chains.jl#L348-L356">source</a></section></article><h2 id="File-I/O"><a class="docs-heading-anchor" href="#File-I/O">File I/O</a><a id="File-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#File-I/O" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.read-Union{Tuple{T}, Tuple{AbstractString,Type{T}}} where T&lt;:AbstractChains" href="#Base.read-Union{Tuple{T}, Tuple{AbstractString,Type{T}}} where T&lt;:AbstractChains"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.read(name::AbstractString, ::Type{T}) where {T&lt;:AbstractChains}</code></pre><p>Read a chain from an external file.</p><p>Returns an <code>AbstractChains</code> subtype read from an external file.</p><ul><li><p><code>name</code> : file to read or write. Recommended convention is for the file name to be specified with a <code>.jls</code> extension.</p></li><li><p><code>T</code> : chain type to read.</p></li><li><p><code>c</code> : chain to write.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/fileio.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{AbstractString,AbstractChains}" href="#Base.write-Tuple{AbstractString,AbstractChains}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.write(name::AbstractString, c::AbstractChains)</code></pre><p>Write a chain to an external file.</p><p>Returns a written external file containing a subtype.</p><ul><li><p><code>name</code> : file to read or write. Recommended convention is for the file name to be specified with a <code>.jls</code> extension.</p></li><li><p><code>T</code> : chain type to read.</p></li><li><p><code>c</code> : chain to write.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/fileio.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.readcoda-Tuple{AbstractString,AbstractString}" href="#Main.MCPhylo.readcoda-Tuple{AbstractString,AbstractString}"><code>Main.MCPhylo.readcoda</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readcoda(output::AbstractString, index::AbstractString)</code></pre><p>Read MCMC sampler output generated in the CODA format by OpenBUGS. The function only retains those sampler iterations at which all model parameters were monitored.</p><p>Returns a <code>Chains</code> object containing the read sampler output.</p><ul><li><p><code>output</code> : text file containing the iteration numbers and sampled values for the model parameters.</p></li><li><p><code>index</code> : text file containing the names of the parameters, followed by the first and last rows in which their output can be found in the <code>output</code> file.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/fileio.jl#L37-L49">source</a></section></article><h2 id="Discrete-Diagnostics"><a class="docs-heading-anchor" href="#Discrete-Diagnostics">Discrete Diagnostics</a><a id="Discrete-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.discretediag-Tuple{AbstractChains}" href="#Main.MCPhylo.discretediag-Tuple{AbstractChains}"><code>Main.MCPhylo.discretediag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discretediag(c::AbstractChains; frac::Real=0.3,
              method::Symbol=:weiss, nsim::Int=1000)</code></pre><p>Compute the convergence diagnostic for a discrete variable. Several options are available by choosing method to be one of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT. The first four are based off of Pearson’s chi-square test of homogeneity. The diagnostic tests whether the proportion of the categories of the discrete variable are similar in each chain. The last two methods test whether the transition probabilities between each category are similar between each chain. Along with a between chain assessment of convergence, a within-chain assessment is carried out by comparing a specified fraction (frac), or window, of the beginning of a chain to the specified fraction of the end of the chain. For within-chain assessment, users should ensure that there is sufficient separation between the windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.</p><p>A <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field. The first three columns correspond to the test statistic, degrees of freedom, and p-value of the between-chain assessment. The next columns are the test statistic, degrees of freedom, and p-value for each chain of the within-chain assessment.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>frac</code> : proportion of iterations to include in the first window.</p></li><li><p><code>method</code> : Specify which method to use. One of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT`.</p></li><li><p><code>nsim</code> : For the bootstrap methods (:DARBOOT, :MCBOOT, and :billingsleyBOOT) the number of bootstrap simulations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/discretediag.jl#L411-L426">source</a></section></article><h2 id="Gelman-Diagnostic"><a class="docs-heading-anchor" href="#Gelman-Diagnostic">Gelman Diagnostic</a><a id="Gelman-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Gelman-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.gelmandiag-Tuple{AbstractChains}" href="#Main.MCPhylo.gelmandiag-Tuple{AbstractChains}"><code>Main.MCPhylo.gelmandiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gelmandiag(c::AbstractChains; alpha::Real=0.05, mpsrf::Bool=false,
            transform::Bool=false)</code></pre><p>Compute the convergence diagnostics of Gelman, Rubin, and Brooks for MCMC sampler output. The diagnostics are designed to asses convergence of posterior means estimated with multiple autocorrelated samples (chains). They does so by comparing the between and within-chain variances with metrics called potential scale reduction factors (PSRF). Both univariate and multivariate factors are available to assess the convergence of parameters individually and jointly. Scale factors close to one are indicative of convergence. As a rule of thumb, convergence is concluded if the 0.975 quantile of an estimated factor is less than 1.2. Multiple chains are required for calculations. It is recommended that at least three chains be generated, each with different starting values chosen to be diffuse with respect to the anticipated posterior distribution. Use of multiple chains in the diagnostic provides for more robust assessment of convergence than is possible with single chain diagnostics.</p><p>Returns a <code>ChainSummary</code> type object of the form:</p><pre><code class="language-none">struct ChainSummary
  value::Array{Float64, 3}
  rownames::Vector{AbstractString}
  colnames::Vector{AbstractString}
  header::AbstractString
end</code></pre><p>with parameters contained in the rows of the <code>value</code> field, and scale reduction factors and upper-limit quantiles in the first and second columns.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>alpha</code> : quantile (<code>1 - alpha / 2</code>) at which to estimate the upper limits of scale reduction factors.</p></li><li><p><code>mpsrf</code> : whether to compute the multivariate potential scale reduction factor. This factor will not be calculable if any one of the parameters in the output is a linear combination of others.</p></li><li><p><code>transform</code> : whether to apply log or logit transformations, as appropriate, to parameters in the chain to potentially produce output that is more normally distributed, an assumption of the PSRF formulations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/gelmandiag.jl#L2-L27">source</a></section></article><h2 id="Geweke-Diagnostic"><a class="docs-heading-anchor" href="#Geweke-Diagnostic">Geweke Diagnostic</a><a id="Geweke-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Geweke-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.gewekediag" href="#Main.MCPhylo.gewekediag"><code>Main.MCPhylo.gewekediag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gewekediag(x::Vector{T}; first::Real=0.1, last::Real=0.5,
            etype=:imse, args...) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/gewekediag.jl#L2-L7">source</a></section><section><div><pre><code class="language-none">gewekediag(c::AbstractChains; first::Real=0.1, last::Real=0.5,
            etype=:imse, args...)</code></pre><p>Compute the convergence diagnostic of Geweke [37] for MCMC sampler output. The diagnostic is designed to asses convergence of posterior means estimated with autocorrelated samples. It computes a normal-based test statistic comparing the sample means in two windows containing proportions of the first and last iterations. Users should ensure that there is sufficient separation between the two windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field, and test Z-scores and p-values in the first and second columns. Results are chain-specific.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>first</code> : proportion of iterations to include in the first window.</p></li><li><p><code>last</code> : proportion of iterations to include in the last window.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/gewekediag.jl#L24-L43">source</a></section></article><h2 id="Heidel-Diagnostic"><a class="docs-heading-anchor" href="#Heidel-Diagnostic">Heidel Diagnostic</a><a id="Heidel-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Heidel-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.heideldiag" href="#Main.MCPhylo.heideldiag"><code>Main.MCPhylo.heideldiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">heideldiag(x::Vector{T}; alpha::Real=0.05, eps::Real=0.1,
            etype=:imse, start::Integer=1, args...) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/heideldiag.jl#L2-L5">source</a></section><section><div><pre><code class="language-none">heideldiag(c::AbstractChains; alpha::Real=0.05, eps::Real=0.1,
            etype=:imse, args...)</code></pre><p>Compute the convergence diagnostic of Heidelberger and Welch for MCMC sampler output. The diagnostic is designed to assess convergence of posterior means estimated with autocorrelated samples and to determine whether a target degree of accuracy is achieved. A stationarity test is performed for convergence assessment by iteratively discarding 10% of the initial samples until the test p-value is non-significant and stationarity is concluded or until 50% have been discarded and stationarity is rejected, whichever occurs first. Then, a halfwidth test is performed by calculating the relative halfwidth of a posterior mean estimation interval as <span>$z_{1 - \alpha / 2} \hat{s} / |\bar{\theta}|$</span>; where <span>$z$</span> is a standard normal quantile, <span>$\hat{s}$</span> is the Monte Carlo standard error, and <span>$\bar{\theta}$</span> is the estimated posterior mean. If the relative halfwidth is greater than a target ratio, the test is rejected. Rejection of the stationarity or halfwidth test suggests that additional samples are needed.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field, and numbers of burn-in sequences to discard, whether the stationarity tests are passed (1 = yes, 0 = no), their p-values (<span>$p &gt; \alpha$</span> implies stationarity), posterior means, halfwidths of their <span>$(1 - \alpha) 100\%$</span> estimation intervals, and whether the halfwidth tests are passed (1 = yes, 0 = no) in the columns. Results are chain-specific.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>alpha</code> : significance level for evaluations of stationarity tests and calculations of relative estimation interval halfwidths.</p></li><li><p><code>eps</code> : target ratio for the relative halfwidths.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li><li><p><code>start</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/heideldiag.jl#L31-L53">source</a></section></article><h2 id="Raftery-and-Lewis-Diagnostic"><a class="docs-heading-anchor" href="#Raftery-and-Lewis-Diagnostic">Raftery and Lewis Diagnostic</a><a id="Raftery-and-Lewis-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Raftery-and-Lewis-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.rafterydiag" href="#Main.MCPhylo.rafterydiag"><code>Main.MCPhylo.rafterydiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rafterydiag(x::Vector{T}; q::Real=0.025, r::Real=0.005,
                  s::Real=0.95, eps::Real=0.001,
                  range::AbstractRange=1:1:length(x)) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/rafterydiag.jl#L2-L6">source</a></section><section><div><pre><code class="language-none">rafterydiag(c::AbstractChains; q::Real=0.025, r::Real=0.005,
                 s::Real=0.95, eps::Real=0.001)</code></pre><p>Compute the convergence diagnostic of Raftery and Lewis for MCMC sampler output. The diagnostic is designed to determine the number of autocorrelated samples required to estimate a specified quantile <span>$\theta_q$</span>, such that <span>$\Pr(\theta \le \theta_q) = q$</span>, within a desired degree of accuracy. In particular, if <span>$\hat{\theta}_q$</span> is the estimand and <span>$\Pr(\theta \le \hat{\theta}_q) = \hat{P}_q$</span> the estimated cumulative probability, then accuracy is specified in terms of r and s, where <span>$\Pr(q - r &lt; \hat{P}_q &lt; q + r) = s$</span>. Thinning may be employed in the calculation of the diagnostic to satisfy its underlying assumptions. However, users may not want to apply the same (or any) thinning when estimating posterior summary statistics because doing so results in a loss of information. Accordingly, sample sizes estimated by the diagnostic tend to be conservative (too large).</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the value field, and thinning intervals employed, numbers of samples to discard as burn-in sequences, total numbers <span>$(N)$</span> to burn-in and retain, numbers of independent samples that would be needed <span>$(Nmin)$</span>, and dependence factors <span>$(N / Nmin)$</span> in the columns. Results are chain-specific.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>q</code> : posterior quantile of interest.</p></li><li><p><code>r</code> : margin of error for estimated cumulative probabilities.</p></li><li><p><code>s</code> : probability for the margin of error.</p></li><li><p><code>eps</code> : tolerance within which the probabilities of transitioning from initial to retained iterations are within the equilibrium probabilities for the chain. This argument determines the number of samples to discard as a burn-in sequence and is typically left at its default value.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li><li><p><code>range</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/rafterydiag.jl#L52-L73">source</a></section></article><h2 id="Monte-Carlo-Standard-Errors"><a class="docs-heading-anchor" href="#Monte-Carlo-Standard-Errors">Monte Carlo Standard Errors</a><a id="Monte-Carlo-Standard-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-Standard-Errors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.mcse" href="#Main.MCPhylo.mcse"><code>Main.MCPhylo.mcse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mcse(x::Vector{T}, method::Symbol=:imse; args...) where {T&lt;:Real}</code></pre><p>Compute Monte Carlo standard errors.</p><p>Returns the numeric standard error value.</p><ul><li><p><code>x</code> : time series of values on which to perform calculations.</p></li><li><p><code>method</code> : method used for the calculations. Options are</p><ul><li><p><code>:bm</code> : batch means, with optional argument <code>size::Integer=100</code> determining the number of sequential values to include in each batch. This method requires that the number of values in <code>x</code> is at least 2 times the batch size.</p></li><li><p><code>:imse</code> : initial monotone sequence estimator.</p></li><li><p><code>:ipse</code> : initial positive sequence estimator.</p></li></ul></li><li><p><code>args...</code> : additional arguments for the calculation method.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/mcse.jl#L2-L19">source</a></section></article><h2 id="ModelChains"><a class="docs-heading-anchor" href="#ModelChains">ModelChains</a><a id="ModelChains-1"></a><a class="docs-heading-anchor-permalink" href="#ModelChains" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ModelChains" href="#Main.MCPhylo.ModelChains"><code>Main.MCPhylo.ModelChains</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelChains(c::Chains, m::Model)</code></pre><p>See <code>Chains()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/modelchains.jl#L4-L8">source</a></section></article><h2 id="Model-Based-Inference"><a class="docs-heading-anchor" href="#Model-Based-Inference">Model-Based Inference</a><a id="Model-Based-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Based-Inference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf" href="#Distributions.logpdf"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logpdf(mc::ModelChains,
        nodekeys::Vector{Symbol}=keys(mc.model, :stochastic))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/modelstats.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf-Tuple{ModelChains,Function,Array{Symbol,1}}" href="#Distributions.logpdf-Tuple{ModelChains,Function,Array{Symbol,1}}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logpdf(mc::ModelChains, f::Function, nodekeys::Vector{Symbol})</code></pre><p>Compute the sum of log-densities at each iteration of MCMC output for stochastic nodes.</p><p>Returns a <code>ModelChains</code> object of resulting summed log-densities at each MCMC iteration of the supplied chain.</p><ul><li><p><code>mc</code> : sampler output from a model fit with the <code>mcmc()</code>` function.</p></li><li><p><code>nodekey/nodekeys</code> : stochastic model node(s) over which to sum densities (default: all).</p></li><li><p><code>f</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/modelstats.jl#L27-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.dic-Tuple{ModelChains}" href="#Main.MCPhylo.dic-Tuple{ModelChains}"><code>Main.MCPhylo.dic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dic(mc::ModelChains)</code></pre><p>Compute the Deviance Information Criterion (DIC) of Spiegelhalter et al. and Gelman et al. from MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with DIC results from the methods of Spiegelhalter and Gelman in the first and second rows of the <code>value</code> field, and the DIC value and effective numbers of parameters in the first and second columns; where</p><p><span>$\text{DIC} = -2 \mathcal{L}(\bar{\Theta}) + 2 p,$</span></p><p>such that <span>$\mathcal{L}(\bar{\Theta})$</span> is the log-likelihood of model outputs given the expected values of model parameters <span>$\Theta$</span>, and <span>$p$</span> is the effective number of parameters. The latter is defined as <span>$p_D = -2 \bar{\mathcal{L}}(\Theta) + 2 \mathcal{L}(\bar{\Theta})$</span> for the method of Spiegelhalter and as <span>$p_V = \frac{1}{2} \operatorname{var}(-2 \mathcal{L}(\Theta))$</span> for the method of Gelman. Results are for all chains combined.</p><ul><li><code>mc</code> : sampler output from a model fit with the <code>mcmc()</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/modelstats.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.predict" href="#StatsBase.predict"><code>StatsBase.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predict(mc::ModelChains,
         nodekeys::Vector{Symbol}=keys(mc.model, :output))</code></pre><p>Generate MCMC draws from a posterior predictive distribution.</p><p>Returns a <code>ModelChains</code> object of draws simulated at each MCMC iteration of the supplied chain. For observed data node <span>$y$</span>, simulation is from the posterior predictive distribution</p><p><span>$p(\tilde{y} | y) = \int p(\tilde{y} | \Theta) p(\Theta | y) d\Theta,$</span></p><p>where <span>$\tilde{y}$</span> is an unknown observation on the node, <span>$p(\tilde{y} | \Theta)$</span> is the data likelihood, and <span>$p(\Theta | y)$</span> is the posterior distribution of unobserved parameters <span>$\Theta$</span>.</p><ul><li><p><code>mc</code> : sampler output from a model fit with the <code>mcmc()</code>` function.</p></li><li><p><code>nodekey/nodekeys</code> : observed Stochastic model node(s) for which to generate draws from the predictive distribution (default: all observed data nodes).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/modelstats.jl#L104-L119">source</a></section></article><h2 id="Plot"><a class="docs-heading-anchor" href="#Plot">Plot</a><a id="Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Plot" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.autocorplot-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.autocorplot-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.autocorplot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>autocorplot(c::AbstractChains, indeces::Vector{Int64};                maxlag::Integer=round(Int, 10 * log10(length(c.range))),                legend::Bool=false, na...)</p><p>–- INTERNAL –- Helper function called by the plot function when a autocorrelation plot is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L192-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.barplot-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.barplot-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.barplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barplot(c::AbstractChains, indeces::Vector{Int64};
        legend::Bool=false, position::Symbol=:stack, na...)</code></pre><p>–- INTERNAL –- Helper function called by the plot function when a barplot is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.check_vars-Tuple{Array{AbstractString,1},Array{String,1}}" href="#Main.MCPhylo.check_vars-Tuple{Array{AbstractString,1},Array{String,1}}"><code>Main.MCPhylo.check_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>check<em>vars(sim</em>names::Vector{AbstractString},              vars::Vector{String})::Vector{Int64}</p><p>–- INTERNAL –- Helper function that returns a list of indeces that correspond to specific variables. Only those variables get plotted in later steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L100-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.contourplot-Tuple{AbstractChains}" href="#Main.MCPhylo.contourplot-Tuple{AbstractChains}"><code>Main.MCPhylo.contourplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contourplot(c::AbstractChains; &lt;keyword arguments&gt;)::Vector{Plots.Plot}</code></pre><p>Function that takes a MCMC chain and creates contourplots. If variables are limited with &#39;vars&#39; keyword argument, at least 2 variables have to be specified, or no contourplot can be drawn.</p><p><strong>Arguments</strong></p><ul><li>&#39;vars::Vector{String}&#39;: specifies the variables of the chain that are plotted</li></ul><p>. &#39;filename::String&#39;=&quot;&quot;: when given, the plots will be saved to a file</p><ul><li>&#39;fmt::Symbol&#39;: specifies the format of the output file</li><li>&#39;nrow::Integer&#39; / &#39;ncol::Integer&#39;: Define layout of the plot window(s), i.e.                                    how many plots on each page</li><li>&#39;legend::Bool=false&#39;: Turn plot legend on / off</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L157-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.contourplot_int-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.contourplot_int-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.contourplot_int</code></a> — <span class="docstring-category">Method</span></header><section><div><p>contourplot_int(c::AbstractChains, indeces::Vector{Int64};                   bins::Integer=100, na...)</p><p>–- INTERNAL –- Helper function called by the contourplot function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L264-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.densityplot-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.densityplot-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.densityplot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>densityplot(c::AbstractChains, indeces::Vector{Int64}; legend::Bool=false,               trim::Tuple{Real, Real}=(0.025, 0.975), na...)</p><p>–- INTERNAL –- Helper function called by the plot function when a densityplot is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L302-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.draw-Union{Tuple{T}, Tuple{Array{T,N} where N}} where T&lt;:Plots.Plot" href="#Main.MCPhylo.draw-Union{Tuple{T}, Tuple{Array{T,N} where N}} where T&lt;:Plots.Plot"><code>Main.MCPhylo.draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw(p::Array{T}; fmt::Symbol=:svg, filename::String=&quot;&quot;, nrow::Integer=3,
     ncol::Integer=2, byrow::Bool=false, ask::Bool=true) where T&lt;:Plots.Plot</code></pre><p>–- INTERNAL –- Helper function for the plot functions. Displays plots and - if wanted - saves them to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.meanplot-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.meanplot-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.meanplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meanplot(c::AbstractChains, indeces::Vector{Int64};
         legend::Bool=false, na...)</code></pre><p>–- INTERNAL –- Helper function called by the plot function when a meanplot is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L339-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.mixeddensityplot-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.mixeddensityplot-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.mixeddensityplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mixeddensityplot(c::AbstractChains, indeces::Vector{Int64};
                 barbounds::Tuple{Real, Real}=(0, Inf), args...)</code></pre><p>–- INTERNAL –- Helper function called by the plot function. Checks for each variable if it is discrete or not and plots a barplot for discrete variables and a densityplot for indiscrete variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L367-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.traceplot-Tuple{AbstractChains,Array{Int64,1}}" href="#Main.MCPhylo.traceplot-Tuple{AbstractChains,Array{Int64,1}}"><code>Main.MCPhylo.traceplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traceplot(c::AbstractChains, indeces::Vector{Int64};
          legend::Bool=false, na...)</code></pre><p>–- INTERNAL –- Helper function called by the plot function when a traceplot is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L400-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot" href="#RecipesBase.plot"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Function</span></header><section><div><p>plot(c::AbstractChains, ptype::Vector{Symbol}=[:trace, :density];        &lt;keyword arguments&gt;)::Array{Plots.Plot}</p><p>Function that takes a MCMC chain and creates various different plots (trace &amp; density by default).</p><p><strong>Arguments</strong></p><ul><li>&#39;vars::Vector{String}&#39;: specifies the variables of the chain that are plotted</li></ul><p>. &#39;filename::String&#39;=&quot;&quot;: when given, the plots will be saved to a file</p><ul><li>&#39;fmt::Symbol&#39;: specifies the format of the output file</li><li>&#39;nrow::Integer&#39; / &#39;ncol::Integer&#39;: Define layout of the plot window(s), i.e.                                    how many plots on each page</li><li>&#39;legend::Bool=false&#39;: Turn plot legend on / off</li><li>&#39;args&#39;: Plottype specific arguments, like the number of bins for the contour         plot or if the barplots bars should be stacked or not. Check the         specific plot functions below to use these arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L62-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot-Tuple{AbstractChains,Symbol,Array{Int64,1}}" href="#RecipesBase.plot-Tuple{AbstractChains,Symbol,Array{Int64,1}}"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>plot(c::AbstractChains, ptype::Symbol, indeces::Vector{Int64};        legend::Bool=false, args...)</p><p>–- INTERNAL –- Helper function to the actual plot function. Calls the specific plotting functions that are needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/plot.jl#L137-L144">source</a></section></article><h2 id="Posterior-Summary-Statistics"><a class="docs-heading-anchor" href="#Posterior-Summary-Statistics">Posterior Summary Statistics</a><a id="Posterior-Summary-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Posterior-Summary-Statistics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.describe-Tuple{IO,AbstractChains}" href="#DataAPI.describe-Tuple{IO,AbstractChains}"><code>DataAPI.describe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">describe(io::IO, c::AbstractChains;
              q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975], etype=:bm, args...)</code></pre><p>Compute summary statistics for MCMC sampler output.</p><p>Returns results from calls to <code>summarystats(c, etype, args...)</code> and <code>quantile(c, q)</code> are printed for all chains combined, and a value of <code>nothing</code> is returned.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>q</code> : probabilities at which to calculate quantiles.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L71-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.changerate-Tuple{AbstractChains}" href="#Main.MCPhylo.changerate-Tuple{AbstractChains}"><code>Main.MCPhylo.changerate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">changerate(c::AbstractChains)</code></pre><p>Estimate the probability, or rate per iteration, <span>$\Pr(\theta^i \ne \theta^{i-1})$</span> of a state space change for iterations <span>$i = 2, \ldots, N$</span> in MCMC sampler output. Estimation is performed for each parameter univariately as well as for the full parameter vector multivariately. For continuous output generated from samplers, like Metropolis-Hastings, whose algorithms conditionally accept candidate draws, the probability can be viewed as the acceptance rate.</p><p>Returns a <code>ChainSummary</code> type object with parameters in the rows of the <code>value</code> field, and the estimated rates in the column. Results are for all chains combined.</p><ul><li><code>c</code> : sampler output on which to perform calculations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.hpd-Tuple{AbstractChains}" href="#Main.MCPhylo.hpd-Tuple{AbstractChains}"><code>Main.MCPhylo.hpd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hpd(c::AbstractChains; alpha::Real=0.05)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L121-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.hpd-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Real" href="#Main.MCPhylo.hpd-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Real"><code>Main.MCPhylo.hpd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hpd(x::Vector{T}; alpha::Real=0.05) where {T&lt;:Real}</code></pre><p>Compute highest posterior density (HPD) intervals of Chen and Shao [16] for MCMC sampler output. HPD intervals have the desirable property of being the smallest intervals that contain a given probability. However, their calculation assumes unimodal marginal posterior distributions, and they are not invariant to transformations of parameters like central (quantile-based) posterior intervals.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the value field, and lower and upper intervals in the first and second columns. Results are for all chains combined.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>alpha</code> : the <code>100 * (1 - alpha)</code>% interval to compute.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.cor-Tuple{AbstractChains}" href="#Statistics.cor-Tuple{AbstractChains}"><code>Statistics.cor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cor(c::AbstractChains)</code></pre><p>Compute cross-correlations for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with the first and second dimensions of the <code>value</code> field indexing the model parameters between which correlations. Results are for all chains combined.</p><ul><li><code>c</code> : sampler output on which to perform calculations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.quantile-Tuple{AbstractChains}" href="#Statistics.quantile-Tuple{AbstractChains}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quantile(c::AbstractChains; q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975])</code></pre><p>Compute posterior quantiles for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field, and quantiles in the columns. Results are for all chains combined.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>q</code> : probabilities at which to compute quantiles.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L133-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.autocor-Tuple{AbstractChains}" href="#StatsBase.autocor-Tuple{AbstractChains}"><code>StatsBase.autocor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autocor(c::AbstractChains; lags::Vector=[1, 5, 10, 50],
         relative::Bool=true)</code></pre><p>Compute lag-k autocorrelations for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with model parameters indexed by the first dimension of <code>value</code>, lag-autocorrelations by the second, and chains by the third.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>lags</code> : lags at which to compute autocorrelations.</p></li><li><p><code>relative</code> : whether the lags are relative to the thinning interval of the output (<code>true</code>) or relative to the absolute iteration numbers (<code>false</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.summarystats-Tuple{AbstractChains}" href="#StatsBase.summarystats-Tuple{AbstractChains}"><code>StatsBase.summarystats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">summarystats(c::AbstractChains; etype=:bm, args...)</code></pre><p>Compute posterior summary statistics for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with parameters in the rows of the <code>value</code> field; and the sample mean, standard deviation, standard error, Monte Carlo standard error, and effective sample size in the columns. Results are for all chains combined.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/output/stats.jl#L152-L164">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="model.html">« Model</a><a class="docs-footer-nextpage" href="samplers.html">Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 March 2021 15:44">Monday 1 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
