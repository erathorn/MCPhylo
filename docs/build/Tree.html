<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree Functionality · MCPhylo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCPhylo</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="intro.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="Tree.html">Tree Functionality</a><ul class="internal"><li><a class="tocitem" href="#Converter.jl"><span>Converter.jl</span></a></li><li><a class="tocitem" href="#Node_Type.jl"><span>Node_Type.jl</span></a></li><li><a class="tocitem" href="#Tree_Basics.jl"><span>Tree_Basics.jl</span></a></li><li><a class="tocitem" href="#Tree_Clustering.jl"><span>Tree_Clustering.jl</span></a></li><li><a class="tocitem" href="#Tree_Consensus.jl"><span>Tree_Consensus.jl</span></a></li><li><a class="tocitem" href="#Tree_Distance.jl"><span>Tree_Distance.jl</span></a></li><li><a class="tocitem" href="#Tree_Ladderizing.jl"><span>Tree_Ladderizing.jl</span></a></li><li><a class="tocitem" href="#Tree_Legacy.jl"><span>Tree_Legacy.jl</span></a></li><li><a class="tocitem" href="#Tree_moves.jl"><span>Tree_moves.jl</span></a></li><li><a class="tocitem" href="#Tree_Pruning.jl"><span>Tree_Pruning.jl</span></a></li><li><a class="tocitem" href="#Tree_Search.jl"><span>Tree_Search.jl</span></a></li><li><a class="tocitem" href="#Tree_Traversal.jl"><span>Tree_Traversal.jl</span></a></li></ul></li><li><a class="tocitem" href="Likelihood.html">Likelihood</a></li><li><a class="tocitem" href="Parser.html">Parser</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="model.html">Model</a></li><li><a class="tocitem" href="output.html">Output</a></li><li><a class="tocitem" href="Sampler.html">Sampler</a></li><li><a class="tocitem" href="samplers.html">Samplers</a></li><li><a class="tocitem" href="Substitution.html">Substitution</a></li><li><a class="tocitem" href="Utils.html">Utils</a></li><li><a class="tocitem" href="Links.html">Links</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Tree.html">Tree Functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Tree.html">Tree Functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/Julia_Tree/blob/master/docs/src/Tree.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-Functionality"><a class="docs-heading-anchor" href="#Tree-Functionality">Tree Functionality</a><a id="Tree-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Functionality" title="Permalink"></a></h1><p>Functions found in all files of Tree folder, ordered according to file of origin.</p><h2 id="Converter.jl"><a class="docs-heading-anchor" href="#Converter.jl">Converter.jl</a><a id="Converter.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Converter.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.from_df" href="#Main.MCPhylo.from_df"><code>Main.MCPhylo.from_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">from_df(df::DataFrame)::Node</code></pre><p>This function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Converter.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newick(node::Node)::String</code></pre><p>Creates a newick represnetation of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Converter.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance" href="#Main.MCPhylo.to_covariance"><code>Main.MCPhylo.to_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N&lt;:GeneralNode,T&lt;: Real}</code></pre><p>Calcualte the variance-covariance matrix from <code>tree</code>. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Converter.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance_ultra" href="#Main.MCPhylo.to_covariance_ultra"><code>Main.MCPhylo.to_covariance_ultra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_covariance_ultra(tree::Node)::Array{T,2} where T&lt;: Real</code></pre><p>Get the covariance matrix of the ultrametric version of <code>tree</code> with height 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Converter.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_df" href="#Main.MCPhylo.to_df"><code>Main.MCPhylo.to_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_df(root::Node)::DataFrame</code></pre><p>This function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry <code>df[i,j]</code> is the length of the edge connecting node <code>i</code> with node <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Converter.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_distance_matrix" href="#Main.MCPhylo.to_distance_matrix"><code>Main.MCPhylo.to_distance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_distance_matrix(tree::T)::Array{Float64,2} where T &lt;:GeneralNode</code></pre><p>Calculate the distance matrix over the set of leaves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Converter.jl#L143-L147">source</a></section></article><h2 id="Node_Type.jl"><a class="docs-heading-anchor" href="#Node_Type.jl">Node_Type.jl</a><a id="Node_Type.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Node_Type.jl" title="Permalink"></a></h2><h2 id="Tree_Basics.jl"><a class="docs-heading-anchor" href="#Tree_Basics.jl">Tree_Basics.jl</a><a id="Tree_Basics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Basics.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.add_child!" href="#Main.MCPhylo.add_child!"><code>Main.MCPhylo.add_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)</code></pre><p>This function adds a child to the mother node. The arity of the mother node is increased by <code>1</code> and the root status of the child is set to <code>False</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.check_binary" href="#Main.MCPhylo.check_binary"><code>Main.MCPhylo.check_binary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_binary(root::Node)::Bool</code></pre><p>checks to see if given tree is binary; returns true if properly formatted and false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L639-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.create_tree_from_leaves" href="#Main.MCPhylo.create_tree_from_leaves"><code>Main.MCPhylo.create_tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_tree_from_leaves(leaf_nodes::Vector{T})::Node</code></pre><p>This function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.delete_node!" href="#Main.MCPhylo.delete_node!"><code>Main.MCPhylo.delete_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_node!(node::Node)::Nothing</code></pre><p>This functions deletes node from a tree and assigns all its children to its mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.force_ultrametric!" href="#Main.MCPhylo.force_ultrametric!"><code>Main.MCPhylo.force_ultrametric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">force_ultrametric!(root::T) where T&lt;:GeneralNode</code></pre><p>Force an ultrametric version of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector" href="#Main.MCPhylo.get_branchlength_vector"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(root::N)::Vector{T}  where {N &lt;:GeneralNode, T&lt;:Real}</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L461-L465">source</a></section><section><div><pre><code class="language-none">get_branchlength_vector(t::TreeStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L474-L478">source</a></section><section><div><pre><code class="language-none">get_branchlength_vector(root::N, out_vec::Vector{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>Do post order traversal to retrieve a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L483-L487">source</a></section><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Legacy.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_mother" href="#Main.MCPhylo.get_mother"><code>Main.MCPhylo.get_mother</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_mother(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the mother of <code>node</code>. It does so by looking for the respective binary representation of the mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L404-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sister" href="#Main.MCPhylo.get_sister"><code>Main.MCPhylo.get_sister</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sister(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the sister of <code>node</code>. It does so by looking for the respective binary representation of the sister.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L393-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sum_seperate_length!" href="#Main.MCPhylo.get_sum_seperate_length!"><code>Main.MCPhylo.get_sum_seperate_length!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sum_seperate_length!(root::T)::Vector{Float64}  where T&lt;:GeneralNode</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L540-L545">source</a></section><section><div><pre><code class="language-none">get_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T&lt;:GeneralNode</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L551-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.insert_node!" href="#Main.MCPhylo.insert_node!"><code>Main.MCPhylo.insert_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_node!(mother::Node, children::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>This function inserts a node into a tree after a mother node and gains a subset of the mother&#39;s children as its children. Returns the inserted node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.node_height" href="#Main.MCPhylo.node_height"><code>Main.MCPhylo.node_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_height(root::T, mv::Float64)::Float64  where T&lt;:GeneralNode</code></pre><p>Calculate the height of a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.number_nodes!" href="#Main.MCPhylo.number_nodes!"><code>Main.MCPhylo.number_nodes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_nodes!(root::T)::Nothing  where T&lt;:GeneralNode</code></pre><p>This function assigns a unique, sequential number to each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.path_length" href="#Main.MCPhylo.path_length"><code>Main.MCPhylo.path_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">path_length(ancestor::T, descendant::T)::Float64  where T&lt;:GeneralNode</code></pre><p>Note: The function assumes there is an ancestral relationship between the two nodes.</p><p>This function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L373-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.random_node" href="#Main.MCPhylo.random_node"><code>Main.MCPhylo.random_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function random_node(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function returns a random node from the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L447-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.remove_child!" href="#Main.MCPhylo.remove_child!"><code>Main.MCPhylo.remove_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_child!(mother_node::Node, left::Bool)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. The removed node is returned. An input of &quot;True&quot; removes the left child, while &quot;False&quot; removes the right child.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L29-L35">source</a></section><section><div><pre><code class="language-none">remove_child!(mother_node::Node, child::Node)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. The removed node is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_binary!" href="#Main.MCPhylo.set_binary!"><code>Main.MCPhylo.set_binary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_binary!(root::Node)</code></pre><p>Assign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L414-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_branchlength_vector!" href="#Main.MCPhylo.set_branchlength_vector!"><code>Main.MCPhylo.set_branchlength_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T &lt;: Real</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L499-L503">source</a></section><section><div><pre><code class="language-none">set_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L508-L512">source</a></section><section><div><pre><code class="language-none">set_branchlength_vector!(root::N, blenvec::Array{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>This function sets the branch lengths of a tree to the values specified in blenvec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L522-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_height" href="#Main.MCPhylo.tree_height"><code>Main.MCPhylo.tree_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tree_height(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.tree_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_length(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Basics.jl#L281-L285">source</a></section></article><h2 id="Tree_Clustering.jl"><a class="docs-heading-anchor" href="#Tree_Clustering.jl">Tree_Clustering.jl</a><a id="Tree_Clustering.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Clustering.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.neighbor_joining" href="#Main.MCPhylo.neighbor_joining"><code>Main.MCPhylo.neighbor_joining</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighbor_joining(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Clustering.jl#L116-L122">source</a></section><section><div><pre><code class="language-none">neighbor_joining(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Clustering.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.upgma" href="#Main.MCPhylo.upgma"><code>Main.MCPhylo.upgma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upgma(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Clustering.jl#L1-L7">source</a></section><section><div><pre><code class="language-none">upgma(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Clustering.jl#L22-L28">source</a></section></article><pre><code class="language-none"></code></pre><p>@autodocs Modules = [MCPhylo] Pages   = [&quot;Tree_Clustering.jl&quot;] Filter =</p><pre><code class="language-none"></code></pre><h2 id="Tree_Consensus.jl"><a class="docs-heading-anchor" href="#Tree_Consensus.jl">Tree_Consensus.jl</a><a id="Tree_Consensus.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Consensus.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.find_common_clusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_common_clusters(ref_tree, tree:T)
    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}</code></pre><p>Use Day&#39;s algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.majority_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T&lt;:AbstractNode</code></pre><p>Construct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L422-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.max_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:AbstractNode</code></pre><p>Recursive helper function to find the highest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.merge_trees!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T&lt;:AbstractNode</code></pre><p>Merge two compatible trees, i.e. inserts all cluster of the first tree, which aren&#39;t already in the second tree, into the secon tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.min_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T &lt;: AbstractNode</code></pre><p>Recursive helper function to find the lowest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.one_way_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one_way_compatible(ref_tree::T, tree::T)::T where T&lt;:AbstractNode</code></pre><p>Takes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.order_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())
    ::Vector{T} where T&lt;:AbstractNode</code></pre><p>Helper function to order a tree based on cluster indeces and return the leaves of the ordered tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L297-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.x_left</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_left(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>Helper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L363-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.x_right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_right(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>Helper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Consensus.jl#L387-L392">source</a></section></article><h2 id="Tree_Distance.jl"><a class="docs-heading-anchor" href="#Tree_Distance.jl">Tree_Distance.jl</a><a id="Tree_Distance.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Distance.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.BHV_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T &lt;:GeneralNode</code></pre><p>This function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Distance.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.RF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RF(tree1::T, tree2::T)::Int64 where T &lt;:GeneralNode</code></pre><p>Calculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Distance.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_bipartitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bipartitions(tree::T)::Vector{Tuple} where T &lt;:GeneralNode</code></pre><p>Get a vector of all bipartions of <code>tree</code>. The resulting vector contains Tuples of sets representing the bipartions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Distance.jl#L15-L20">source</a></section></article><h2 id="Tree_Ladderizing.jl"><a class="docs-heading-anchor" href="#Tree_Ladderizing.jl">Tree_Ladderizing.jl</a><a id="Tree_Ladderizing.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Ladderizing.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.ladderize_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T&lt;:AbstractNode)</code></pre><p>This function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Ladderizing.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.ladderize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree(root::T, ascending::Bool=true)::T where T&lt;:AbstractNode)</code></pre><p>This function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Ladderizing.jl#L22-L27">source</a></section></article><h2 id="Tree_Legacy.jl"><a class="docs-heading-anchor" href="#Tree_Legacy.jl">Tree_Legacy.jl</a><a id="Tree_Legacy.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Legacy.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Legacy.jl#L3-L7">source</a></section></article><h2 id="Tree_moves.jl"><a class="docs-heading-anchor" href="#Tree_moves.jl">Tree_moves.jl</a><a id="Tree_moves.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_moves.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI!" href="#Main.MCPhylo.NNI!"><code>Main.MCPhylo.NNI!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">NNI(root::T, target::T, lor::Bool)::Int64   where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The parameter <code>target</code> specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used <code>lor=true</code>. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L4-L12">source</a></section><section><div><pre><code class="language-none">NNI!(root::T, target::Int64)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L34-L40">source</a></section><section><div><pre><code class="language-none">NNI!(root::T)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI" href="#Main.MCPhylo.NNI"><code>Main.MCPhylo.NNI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">NNI(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code> and returns a mutated copy while leaving the original tree intact.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.change_edge_length!" href="#Main.MCPhylo.change_edge_length!"><code>Main.MCPhylo.change_edge_length!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">change_edge_length!(root::T) where T &lt;:GeneralNode</code></pre><p>Pick a random node and increase or decrease its length randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.move!" href="#Main.MCPhylo.move!"><code>Main.MCPhylo.move!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move!(node1::Node, node2::Node, proportion::Float64)</code></pre><p>Change the incomming length of node1 and node2 while keeping there combined length constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.perform_spr" href="#Main.MCPhylo.perform_spr"><code>Main.MCPhylo.perform_spr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perform_spr(root::Node)</code></pre><p>performs SPR on binary tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L287-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.randomize!" href="#Main.MCPhylo.randomize!"><code>Main.MCPhylo.randomize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomize!(root::Node, num::Int64=100)::nothing</code></pre><p>This function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR!" href="#Main.MCPhylo.risky_SPR!"><code>Main.MCPhylo.risky_SPR!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    risky_SPR!(root::Node)::AbstractNode
Performs SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not
Returns reference to root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR" href="#Main.MCPhylo.risky_SPR"><code>Main.MCPhylo.risky_SPR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    risky_SPR(root::Node)::AbstractNode
Performs SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not
Returns copy of root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide" href="#Main.MCPhylo.slide"><code>Main.MCPhylo.slide</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slide(root::T)::T where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters. The new tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide!" href="#Main.MCPhylo.slide!"><code>Main.MCPhylo.slide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slide!(root::T) where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing!" href="#Main.MCPhylo.swing!"><code>Main.MCPhylo.swing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swing!(root::T) where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing" href="#Main.MCPhylo.swing"><code>Main.MCPhylo.swing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swing(root::T)::T where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children. The new tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_moves.jl#L139-L144">source</a></section></article><h2 id="Tree_Pruning.jl"><a class="docs-heading-anchor" href="#Tree_Pruning.jl">Tree_Pruning.jl</a><a id="Tree_Pruning.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Pruning.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree!" href="#Main.MCPhylo.prune_tree!"><code>Main.MCPhylo.prune_tree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_tree!(root::T, node_names::Vector{String})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Pruning.jl#L18-L22">source</a></section><section><div><pre><code class="language-none">prune_tree!(root::T, node_names::Vector{T})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Pruning.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree" href="#Main.MCPhylo.prune_tree"><code>Main.MCPhylo.prune_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_tree(root::T, node_names::Vector{String})::T where T&lt;:AbstractNode</code></pre><p>This function returns a copy of a tree with specific nodes including their descendants removed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Pruning.jl#L1-L6">source</a></section></article><h2 id="Tree_Search.jl"><a class="docs-heading-anchor" href="#Tree_Search.jl">Tree_Search.jl</a><a id="Tree_Search.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Search.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_binary" href="#Main.MCPhylo.find_binary"><code>Main.MCPhylo.find_binary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_binary(root::T, bin::String)::T where T&lt;:GeneralNode</code></pre><p>Find a node by its binary representation. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure wheter the node is in the tree at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Search.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_num" href="#Main.MCPhylo.find_num"><code>Main.MCPhylo.find_num</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_num(root::T, num::Int64)  where T&lt;:GeneralNode</code></pre><p>Find a node by its number. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure wheter the node is in the tree at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Search.jl#L35-L42">source</a></section><section><div><pre><code class="language-none">find_num(root::T, num::Int64, rn::Vector{T})::Bool  where T&lt;:GeneralNode</code></pre><p>Do a post order traversal to find the node corresponding to the <code>num</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Search.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_root" href="#Main.MCPhylo.find_root"><code>Main.MCPhylo.find_root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_root(node::Node)::Node</code></pre><p>Takes a node in a tree and finds the root of that tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Search.jl#L94-L98">source</a></section></article><h2 id="Tree_Traversal.jl"><a class="docs-heading-anchor" href="#Tree_Traversal.jl">Tree_Traversal.jl</a><a id="Tree_Traversal.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Traversal.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_leaves" href="#Main.MCPhylo.get_leaves"><code>Main.MCPhylo.get_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L32-L38">source</a></section><section><div><pre><code class="language-none">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_order" href="#Main.MCPhylo.level_order"><code>Main.MCPhylo.level_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">level_order(node::T)::Array{T} where T&lt;:GeneralNode</code></pre><p>This function does level order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_traverse" href="#Main.MCPhylo.level_traverse"><code>Main.MCPhylo.level_traverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T &lt;:GeneralNode</code></pre><p>This function traverses a level of the tree specified through <code>node</code>. The level is specified via the <code>level</code> argument and the nodes visited are stored in the <code>stack</code>. This function is intended as the internal worker for the level_order function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.post_order" href="#Main.MCPhylo.post_order"><code>Main.MCPhylo.post_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L3-L9">source</a></section><section><div><pre><code class="language-none">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.pre_order" href="#Main.MCPhylo.pre_order"><code>Main.MCPhylo.pre_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pre_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a pre order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the pre order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L68-L74">source</a></section><section><div><pre><code class="language-none">pre_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does pre order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12955e8f130c5f5f0f3ca31cc8b73aec0cba0489/src/Tree/Tree_Traversal.jl#L86-L90">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="intro.html">« Introduction</a><a class="docs-footer-nextpage" href="Likelihood.html">Likelihood »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 27 November 2020 13:02">Friday 27 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
