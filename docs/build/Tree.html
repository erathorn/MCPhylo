<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree Functionality · MCPhylo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCPhylo</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="intro.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="tree.html">Tree Functionality</a><ul class="internal"><li><a class="tocitem" href="#Node-Type"><span>Node Type</span></a></li><li><a class="tocitem" href="#Converter"><span>Converter</span></a></li><li><a class="tocitem" href="#Tree-Basics"><span>Tree Basics</span></a></li><li><a class="tocitem" href="#Tree-Clustering"><span>Tree Clustering</span></a></li><li><a class="tocitem" href="#Tree-Consensus"><span>Tree Consensus</span></a></li><li><a class="tocitem" href="#Tree-Distance"><span>Tree Distance</span></a></li><li><a class="tocitem" href="#Tree-Ladderizing"><span>Tree Ladderizing</span></a></li><li><a class="tocitem" href="#Tree-Legacy"><span>Tree Legacy</span></a></li><li><a class="tocitem" href="#Tree-moves"><span>Tree moves</span></a></li><li><a class="tocitem" href="#Tree-Pruning"><span>Tree Pruning</span></a></li><li><a class="tocitem" href="#Tree-Search"><span>Tree Search</span></a></li><li><a class="tocitem" href="#Tree-Traversal"><span>Tree Traversal</span></a></li></ul></li><li><a class="tocitem" href="likelihood.html">Likelihood</a></li><li><a class="tocitem" href="parser.html">Parser</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="model.html">Model</a></li><li><a class="tocitem" href="output.html">Output</a></li><li><a class="tocitem" href="samplers.html">Samplers</a></li><li><a class="tocitem" href="utils.html">Utils</a></li><li><a class="tocitem" href="links.html">Links</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tree.html">Tree Functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tree.html">Tree Functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/Julia_Tree/blob/master/docs/src/tree.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-Functionality"><a class="docs-heading-anchor" href="#Tree-Functionality">Tree Functionality</a><a id="Tree-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Functionality" title="Permalink"></a></h1><p>MCPhylo offers several tree functionalities. The underlying type is that of a <code>GeneralNode</code>. It provides the functionality necessary to do MCMC operations with tree structures.</p><h2 id="Node-Type"><a class="docs-heading-anchor" href="#Node-Type">Node Type</a><a id="Node-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Node-Type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.GeneralNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Node</code></pre><p>This data type holds the basic Node structure. The type T is used to specify the type of the data stored in the node.</p><ul><li>If <code>nchild</code> is <code>0</code> the Node is a leaf node.</li><li>If <code>root</code> is <code>False</code> the Node is a child of another node.</li><li><code>inc_length</code> specifies the length of the incomming branch.</li><li><code>binary</code> specifies the path from the root to the Node. <code>1</code> and <code>0</code> represent left and right turns respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Node_Type.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.Node-Tuple{}" href="#Main.MCPhylo.Node-Tuple{}"><code>Main.MCPhylo.Node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Node()::Node</code></pre><p>This function will initialize an empty node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Node_Type.jl#L38-L42">source</a></section></article><h2 id="Converter"><a class="docs-heading-anchor" href="#Converter">Converter</a><a id="Converter-1"></a><a class="docs-heading-anchor-permalink" href="#Converter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.from_df" href="#Main.MCPhylo.from_df"><code>Main.MCPhylo.from_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">from_df(df::DataFrame)::Node</code></pre><p>This function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.</p><p>Returns the root node of the tree.</p><ul><li><code>df</code> : Dataframe used to create a tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Converter.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.newick-Tuple{T} where T&lt;:GeneralNode" href="#Main.MCPhylo.newick-Tuple{T} where T&lt;:GeneralNode"><code>Main.MCPhylo.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newick(node::Node)::String</code></pre><p>Creates a newick representation of the tree.</p><p>Returns a properly formatted newick String.</p><ul><li><code>node</code> : root node of tree used to create the newick string.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Converter.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance" href="#Main.MCPhylo.to_covariance"><code>Main.MCPhylo.to_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N&lt;:GeneralNode,T&lt;: Real}</code></pre><p>Calcualte the variance-covariance matrix from <code>tree</code>. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.</p><p>Returns an Array of Real numbers.</p><ul><li><p><code>tree</code> : Node in tree of interest.</p></li><li><p><code>blv</code> : branchlength vector of tree. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Converter.jl#L184-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance_ultra" href="#Main.MCPhylo.to_covariance_ultra"><code>Main.MCPhylo.to_covariance_ultra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_covariance_ultra(tree::Node)::Array{T,2} where T&lt;: Real</code></pre><p>Get the covariance matrix of the ultrametric version of <code>tree</code> with height 1.</p><p>Returns an Array of Real numbers.</p><ul><li><code>tree</code> : root of tree used to perform calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Converter.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_df" href="#Main.MCPhylo.to_df"><code>Main.MCPhylo.to_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_df(root::Node)::DataFrame</code></pre><p>This function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry <code>df[i,j]</code> is the length of the edge connecting node <code>i</code> with node <code>j</code>.</p><p>Returns a Dataframe.</p><ul><li><code>root</code> : root of tree used to create matrix represenation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Converter.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_distance_matrix" href="#Main.MCPhylo.to_distance_matrix"><code>Main.MCPhylo.to_distance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_distance_matrix(tree::T)::Array{Float64,2} where T &lt;:GeneralNode</code></pre><p>Calculate the distance matrix over the set of leaves.</p><p>Returns an Array of Floats.</p><ul><li><code>tree</code> : root node of tree used to perform caclulcation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Converter.jl#L159-L167">source</a></section></article><h2 id="Tree-Basics"><a class="docs-heading-anchor" href="#Tree-Basics">Tree Basics</a><a id="Tree-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Basics" title="Permalink"></a></h2><p>This file is a bit larger, and so will be broken into (hopefully coherent) subgroups, listed here:</p><p><a href="tree.html#Tree-Editing">Tree Editing</a></p><p><a href="tree.html#Return-Functions">Return Functions</a></p><p><a href="tree.html#Metavariable-Functions">Metavariable Functions</a></p><p><a href="tree.html#Variable-Functions">Variable Functions</a></p><h3 id="Tree-Editing"><a class="docs-heading-anchor" href="#Tree-Editing">Tree Editing</a><a id="Tree-Editing-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Editing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.add_child!" href="#Main.MCPhylo.add_child!"><code>Main.MCPhylo.add_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)</code></pre><p>This function adds a child to the mother node. The arity of the mother node is increased by <code>1</code> and the root status of the child is set to <code>False</code>.</p><ul><li><p><code>mother_node</code> : Node to add a child to.</p></li><li><p><code>child</code> : Node to add to mother_node.children.</p></li><li><p><code>child_position</code> : index at which to add the new child node; optional.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.delete_node!" href="#Main.MCPhylo.delete_node!"><code>Main.MCPhylo.delete_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_node!(node::Node)::Nothing</code></pre><p>This functions deletes node from a tree and assigns all its children to its mother node.</p><ul><li><code>node</code> : Node to be deleted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.insert_node!" href="#Main.MCPhylo.insert_node!"><code>Main.MCPhylo.insert_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_node!(mother::Node, children::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>This function inserts a node into a tree after a mother node and gains a subset of the mother&#39;s children as its children.</p><p>Returns the inserted node.</p><ul><li><p><code>mother</code> : Node under which to add the newly-inserted node.</p></li><li><p><code>children</code> : Children of node referenced by &quot;mother&quot; to reassign as children of the newly-inserted node.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L101-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.remove_child!" href="#Main.MCPhylo.remove_child!"><code>Main.MCPhylo.remove_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_child!(mother_node::Node, left::Bool)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. An input of &quot;True&quot; removes the left child, while &quot;False&quot; removes the right child.</p><p>Returns the removed node.</p><ul><li><p><code>mother_node</code> : Node from which to remove a child.</p></li><li><p><code>left</code> : boolean value determining which child of mother_node to remove.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L35-L47">source</a></section><section><div><pre><code class="language-none">remove_child!(mother_node::Node, child::Node)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node.</p><p>The removed node is returned.</p><ul><li><p><code>mother_node</code> : Node from which to remove a child.</p></li><li><p><code>child</code> : specific Node to remove.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.create_tree_from_leaves" href="#Main.MCPhylo.create_tree_from_leaves"><code>Main.MCPhylo.create_tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_tree_from_leaves(leaf_nodes::Vector{T})::Node</code></pre><p>This function creates a  random binary tree from a list of leaf nodes.</p><p>The root node as access point for the tree is returned.</p><ul><li><p><code>leaf_nodes</code> : Names of nodes to create.</p></li><li><p><code>node_size</code> : used to initialize node.data</p></li><li><p><code>cu</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L197-L209">source</a></section></article><h3 id="Return-Functions"><a class="docs-heading-anchor" href="#Return-Functions">Return Functions</a><a id="Return-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_mother" href="#Main.MCPhylo.get_mother"><code>Main.MCPhylo.get_mother</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_mother(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the mother of <code>node</code>. It does so by looking for the respective binary representation of the mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L448-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sister" href="#Main.MCPhylo.get_sister"><code>Main.MCPhylo.get_sister</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sister(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the sister of <code>node</code>. It does so by looking for the respective binary representation of the sister.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L437-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.node_height" href="#Main.MCPhylo.node_height"><code>Main.MCPhylo.node_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_height(root::T, mv::Float64)::Float64  where T&lt;:GeneralNode</code></pre><p>Calculate the height of a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.random_node" href="#Main.MCPhylo.random_node"><code>Main.MCPhylo.random_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function random_node(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function returns a random node from the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L500-L504">source</a></section></article><h3 id="Metavariable-Functions"><a class="docs-heading-anchor" href="#Metavariable-Functions">Metavariable Functions</a><a id="Metavariable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Metavariable-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_length-Tuple{T} where T&lt;:GeneralNode" href="#Main.MCPhylo.tree_length-Tuple{T} where T&lt;:GeneralNode"><code>Main.MCPhylo.tree_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_length(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_height" href="#Main.MCPhylo.tree_height"><code>Main.MCPhylo.tree_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tree_height(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L346-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector" href="#Main.MCPhylo.get_branchlength_vector"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(root::N)::Vector{T}  where {N &lt;:GeneralNode, T&lt;:Real}</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L514-L518">source</a></section><section><div><pre><code class="language-none">get_branchlength_vector(t::TreeStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L527-L531">source</a></section><section><div><pre><code class="language-none">get_branchlength_vector(root::N, out_vec::Vector{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>Do post order traversal to retrieve a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L536-L540">source</a></section><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p><ul><li><code>post_order</code> : Vector of Nodes of a tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Legacy.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sum_seperate_length!" href="#Main.MCPhylo.get_sum_seperate_length!"><code>Main.MCPhylo.get_sum_seperate_length!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sum_seperate_length!(root::T)::Vector{Float64}  where T&lt;:GeneralNode</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L593-L598">source</a></section><section><div><pre><code class="language-none">get_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T&lt;:GeneralNode</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L604-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.check_binary" href="#Main.MCPhylo.check_binary"><code>Main.MCPhylo.check_binary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_binary(root::Node)::Bool</code></pre><p>checks to see if given tree is binary; returns true if properly formatted and false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L692-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.path_length" href="#Main.MCPhylo.path_length"><code>Main.MCPhylo.path_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">path_length(ancestor::T, descendant::T)::Float64  where T&lt;:GeneralNode</code></pre><p>Note: The function assumes there is an ancestral relationship between the two nodes.</p><p>This function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L417-L425">source</a></section></article><h3 id="Variable-Functions"><a class="docs-heading-anchor" href="#Variable-Functions">Variable Functions</a><a id="Variable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.force_ultrametric!" href="#Main.MCPhylo.force_ultrametric!"><code>Main.MCPhylo.force_ultrametric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">force_ultrametric!(root::T) where T&lt;:GeneralNode</code></pre><p>Force an ultrametric version of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.number_nodes!" href="#Main.MCPhylo.number_nodes!"><code>Main.MCPhylo.number_nodes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_nodes!(root::T)::Nothing  where T&lt;:GeneralNode</code></pre><p>This function assigns a unique, sequential number to each node. Leaves are numbered first in alphabetical order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L478-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_branchlength_vector!" href="#Main.MCPhylo.set_branchlength_vector!"><code>Main.MCPhylo.set_branchlength_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T &lt;: Real</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L552-L556">source</a></section><section><div><pre><code class="language-none">set_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L561-L565">source</a></section><section><div><pre><code class="language-none">set_branchlength_vector!(root::N, blenvec::Array{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>This function sets the branch lengths of a tree to the values specified in blenvec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L575-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_binary!" href="#Main.MCPhylo.set_binary!"><code>Main.MCPhylo.set_binary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_binary!(root::Node)</code></pre><p>Assign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Basics.jl#L458-L464">source</a></section></article><h2 id="Tree-Clustering"><a class="docs-heading-anchor" href="#Tree-Clustering">Tree Clustering</a><a id="Tree-Clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Clustering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.neighbor_joining" href="#Main.MCPhylo.neighbor_joining"><code>Main.MCPhylo.neighbor_joining</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighbor_joining(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><p><code>dm</code> : Matrix used to create Tree.</p></li><li><p><code>leaf_names</code> : Array containing names of leaf nodes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Clustering.jl#L125-L136">source</a></section><section><div><pre><code class="language-none">neighbor_joining(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><code>dm</code> : Matrix from which to create tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Clustering.jl#L151-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.upgma" href="#Main.MCPhylo.upgma"><code>Main.MCPhylo.upgma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upgma(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><p><code>dm</code> : Matrix from which to create the tree.</p></li><li><p><code>leaf_names</code> : array of strings containing names of leaf nodes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Clustering.jl#L1-L12">source</a></section><section><div><pre><code class="language-none">upgma(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><code>dm</code> : Matrix from which to create the tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Clustering.jl#L27-L36">source</a></section></article><h2 id="Tree-Consensus"><a class="docs-heading-anchor" href="#Tree-Consensus">Tree Consensus</a><a id="Tree-Consensus-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Consensus" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.check_node!-Union{Tuple{T}, Tuple{T,Array{T,1},Dict{String,Int64},Dict{T,Tuple{T,Dict{Int64,T}}},Dict{T,Tuple{T,Dict{Int64,T}}}}, Tuple{T,Array{T,1},Dict{String,Int64},Dict{T,Tuple{T,Dict{Int64,T}}},Dict{T,Tuple{T,Dict{Int64,T}}},Union{Nothing, Dict{Int64,Bool}}}} where T&lt;:AbstractNode" href="#Main.MCPhylo.check_node!-Union{Tuple{T}, Tuple{T,Array{T,1},Dict{String,Int64},Dict{T,Tuple{T,Dict{Int64,T}}},Dict{T,Tuple{T,Dict{Int64,T}}}}, Tuple{T,Array{T,1},Dict{String,Int64},Dict{T,Tuple{T,Dict{Int64,T}}},Dict{T,Tuple{T,Dict{Int64,T}}},Union{Nothing, Dict{Int64,Bool}}}} where T&lt;:AbstractNode"><code>Main.MCPhylo.check_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_node!(
    ref_node::T, leaves::Vector{T},
    leaf_ranks_reverse::Dict{String, Int64},
    xleft_dict::Dict{T, Tuple{T, Dict{Int64, T}}},
    xright_dict::Dict{T, Tuple{T, Dict{Int64, T}}},
    marked_nodes::Union{Dict{Int64, Bool, Nothing}}=nothing
)::Union{Nothing, Tuple{T, T, T, Dict{Int64, T}, Dict{Int64, T}}} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function that handles major chunk of code that one<em>way</em>compatible and merge_tree share</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L449-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.count_cluster_occurences-Tuple{Array{BitArray{1},1}}" href="#Main.MCPhylo.count_cluster_occurences-Tuple{Array{BitArray{1},1}}"><code>Main.MCPhylo.count_cluster_occurences</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">count_cluster_occurences(bit_vectors::BitVector)
    ::PriorityQueue{BitVector, Int64}</code></pre><p>–- INTERNAL –- Helper function for greedy<em>consensus</em>tree that counts the occurrences of each bit vector representing a cluster. Returns a priority queue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L209-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.depth_dicts-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode" href="#Main.MCPhylo.depth_dicts-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode"><code>Main.MCPhylo.depth_dicts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">depth_dicts(leaves::Vector{T})
    ::Tuple{Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function for one<em>way</em>compatible and merge_trees!. Creates a dictionary based on a vector of leaf nodes, and stores the depth of each node, as well as the left and right path leading to it. Based on section 6.1 of the paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L687-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractNode" href="#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractNode"><code>Main.MCPhylo.find_common_clusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_common_clusters(ref_tree, tree:T)
    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}</code></pre><p>–- INTERNAL –- Use Day&#39;s algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees.</p><p>Returns dictionary.</p><ul><li><p><code>ref_tree</code> : Tree used to create dictionary.</p></li><li><p><code>tree</code> : Tree used to create dictionary.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L277-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_cluster_start_indeces-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractNode" href="#Main.MCPhylo.get_cluster_start_indeces-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractNode"><code>Main.MCPhylo.get_cluster_start_indeces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_cluster_start_indeces(ref_nodes::T, tree::T)
    ::Dict{T, Int64} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function to obtain the cluster start indeces for a tree (tree), based on the nodes of another tree (ref_nodes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L516-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_leaf_ranks-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode" href="#Main.MCPhylo.get_leaf_ranks-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode"><code>Main.MCPhylo.get_leaf_ranks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_leaf_ranks(nodes::Vector{T})
    ::Dict{String, Int64} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Enumerate the leaf nodes in a tree. Returns a dictionary of this mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L547-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.greedy_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode" href="#Main.MCPhylo.greedy_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode"><code>Main.MCPhylo.greedy_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedy_consensus_tree(trees::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>Construct the greedy consensus tree from a set of trees that share the same leafset.  Returns the root node of the greedy consensus tree, from which it can be traversed. This algorithm is based on section 5 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.loose_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode" href="#Main.MCPhylo.loose_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:AbstractNode"><code>Main.MCPhylo.loose_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loose_consensus_tree(trees::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>Construct the loose consensus tree from a set of trees that share the same leafset. I.e. a tree with all the clusters that appear in at least one tree and are compatible with all trees. Returns the root node of the loose consensus tree, from which it can be traversed. This algorithm is based on section 4 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L76-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:AbstractNode" href="#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:AbstractNode"><code>Main.MCPhylo.majority_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T&lt;:AbstractNode</code></pre><p>Construct the majority rule consensus tree from a set of trees that share the same leafset. By default the output tree includes clusters that occur in over 50% of the trees. This can be customized when calling the function. The function returns the root node of the majority consensus tree, from which it can be traversed. The algorithm is based on section 3 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:AbstractNode" href="#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:AbstractNode"><code>Main.MCPhylo.max_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Recursive helper function to find the highest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L613-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractNode" href="#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractNode"><code>Main.MCPhylo.merge_trees!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_trees!(ref_tree::T, tree::T)::Vector{T}} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Merge two compatible trees, i.e. inserts all cluster of the first tree, which aren&#39;t already in the second tree, into the second tree</p><p>Returns a Tuple containing the root node of the merged tree, as well as a vector of nodes that were added.</p><ul><li><p><code>ref_tree</code> : tree used to determine common clusters.</p></li><li><p><code>tree</code> : tree used to determine common clusters.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L394-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:AbstractNode" href="#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:AbstractNode"><code>Main.MCPhylo.min_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:AbstractNode</code></pre><p>–– INTERNAL –- Recursive helper function to find the lowest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L589-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractNode" href="#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractNode"><code>Main.MCPhylo.one_way_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one_way_compatible(ref_tree::T, tree::T)::T where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Takes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.</p><p>Returns root node of edited tree.</p><ul><li><p><code>ref_tree</code> : tree used to determine clusters.</p></li><li><p><code>tree</code> : tree used to determine clusters.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L359-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:AbstractNode" href="#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:AbstractNode"><code>Main.MCPhylo.order_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())
    ::Vector{T} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function to order a tree based on cluster indeces and return the leaves of the ordered tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L567-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_node_stats!-Union{Tuple{T}, Tuple{T,Array{T,1},Bool}, Tuple{T,Array{T,1},Bool,Float64}} where T&lt;:AbstractNode" href="#Main.MCPhylo.set_node_stats!-Union{Tuple{T}, Tuple{T,Array{T,1},Bool}, Tuple{T,Array{T,1},Bool,Float64}} where T&lt;:AbstractNode"><code>Main.MCPhylo.set_node_stats!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_node_stats!(tree::T, trees::Vector{T}, majority::Bool)
    ::Nothing where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function for the construction of a consensus tree. Calculates the inc_lengths and statistics of the nodes in the consensus tree. If dealing with a (in-progress) majority consensus tree, this function will also delete its non-majority clusters (handled by the &#39;majority&#39; boolean).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L235-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_left-Tuple{T} where T&lt;:AbstractNode" href="#Main.MCPhylo.x_left-Tuple{T} where T&lt;:AbstractNode"><code>Main.MCPhylo.x_left</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_left(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L637-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_right-Tuple{T} where T&lt;:AbstractNode" href="#Main.MCPhylo.x_right-Tuple{T} where T&lt;:AbstractNode"><code>Main.MCPhylo.x_right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_right(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>–- INTERNAL –- Helper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Consensus.jl#L662-L668">source</a></section></article><h2 id="Tree-Distance"><a class="docs-heading-anchor" href="#Tree-Distance">Tree Distance</a><a id="Tree-Distance-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Distance" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:GeneralNode" href="#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:GeneralNode"><code>Main.MCPhylo.BHV_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T &lt;:GeneralNode</code></pre><p>This function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.</p><p>Returns tuple of floats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Distance.jl#L43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:GeneralNode" href="#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:GeneralNode"><code>Main.MCPhylo.RF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RF(tree1::T, tree2::T)::Int64 where T &lt;:GeneralNode</code></pre><p>Calculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.</p><p>Returns result of algorithm as integer.</p><ul><li><p><code>tree1</code> : tree used to determine RF distance.</p></li><li><p><code>tree2</code> : tree used to determine RF distance.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Distance.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_bipartitions-Tuple{T} where T&lt;:GeneralNode" href="#Main.MCPhylo.get_bipartitions-Tuple{T} where T&lt;:GeneralNode"><code>Main.MCPhylo.get_bipartitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bipartitions(tree::T)::Vector{Tuple} where T &lt;:GeneralNode</code></pre><p>Get a vector of all bipartions of <code>tree</code>.</p><p>Returns a vector containing Tuples of sets representing the bipartions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Distance.jl#L21-L27">source</a></section></article><h2 id="Tree-Ladderizing"><a class="docs-heading-anchor" href="#Tree-Ladderizing">Tree Ladderizing</a><a id="Tree-Ladderizing-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Ladderizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T,Bool}} where T&lt;:AbstractNode" href="#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T,Bool}} where T&lt;:AbstractNode"><code>Main.MCPhylo.ladderize_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T&lt;:AbstractNode)</code></pre><p>This function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>ascending</code> : Boolean, determines whether to sort in ascending (true) or descending (false) order.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Ladderizing.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T,Bool}} where T&lt;:AbstractNode" href="#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T,Bool}} where T&lt;:AbstractNode"><code>Main.MCPhylo.ladderize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree(root::T, ascending::Bool=true)::T where T&lt;:AbstractNode)</code></pre><p>This function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>ascending</code> : Boolean, determines whether to sort in ascending (true) or descending (false) order.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Ladderizing.jl#L26-L35">source</a></section></article><h2 id="Tree-Legacy"><a class="docs-heading-anchor" href="#Tree-Legacy">Tree Legacy</a><a id="Tree-Legacy-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Legacy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:GeneralNode" href="#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:GeneralNode"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p><ul><li><code>post_order</code> : Vector of Nodes of a tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Legacy.jl#L3-L9">source</a></section></article><h2 id="Tree-moves"><a class="docs-heading-anchor" href="#Tree-moves">Tree moves</a><a id="Tree-moves-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-moves" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI!" href="#Main.MCPhylo.NNI!"><code>Main.MCPhylo.NNI!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">NNI(root::T, target::T, lor::Bool)::Int64   where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The parameter <code>target</code> specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used <code>lor=true</code>.</p><p>The function returns 1 if the move was successful and 0 else.</p><ul><li><p><code>root</code> : root node of tree on which to perform the NNI.</p></li><li><p><code>target</code> : specific node of tree to interchange.</p></li><li><p><code>lor</code> : Bool; &quot;true&quot; uses the left child of <code>target,</code> &quot;false,&quot; the right child.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L4-L19">source</a></section><section><div><pre><code class="language-none">NNI!(root::T, target::Int64)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node.</p><p>The function returns 1 if the move was successful and 0 else.</p><ul><li><p><code>root</code> : root node of tree on which to perform the NNI.</p></li><li><p><code>target</code> : specific node of tree to interchange.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L41-L52">source</a></section><section><div><pre><code class="language-none">NNI!(root::T, target::Int64)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L59-L65">source</a></section><section><div><pre><code class="language-none">NNI!(root::T)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node.</p><p>The function returns 1 if the move was successful and 0 else.</p><ul><li><code>root</code> : root node of tree on which to perform the NNI.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI" href="#Main.MCPhylo.NNI"><code>Main.MCPhylo.NNI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">NNI(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root.</code></p><p>Returns a mutated copy while leaving the original tree intact.</p><ul><li><code>root</code> : root node of tree on which to perform the NNI.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L90-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.change_edge_length!" href="#Main.MCPhylo.change_edge_length!"><code>Main.MCPhylo.change_edge_length!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">change_edge_length!(root::T) where T &lt;:GeneralNode</code></pre><p>Pick a random node and increase or decrease its length randomly.</p><ul><li><code>root</code> : root node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L221-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.move!" href="#Main.MCPhylo.move!"><code>Main.MCPhylo.move!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move!(node1::Node, node2::Node, proportion::Float64)</code></pre><p>Change the incoming length of node1 and node2 while keeping their combined length constant.</p><ul><li><p><code>node1</code> : Node whose inc<em>length will be modified; this node&#39;s inc</em>length will be the total inc_length of both nodes, times proportion.</p></li><li><p><code>node2</code> : Node whose inc<em>length will be modified; this node&#39;s inc</em>length will be the remainder of total - the new inc_length value of node1.</p></li><li><p><code>proportion</code> : Float64, determines proportion of the inc_length of both nodes assigned to node1.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L241-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.perform_spr" href="#Main.MCPhylo.perform_spr"><code>Main.MCPhylo.perform_spr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perform_spr(root::Node)</code></pre><p>performs SPR on binary tree.</p><p>Returns root of tree post-SPR.</p><ul><li><code>root</code> : Node of tree on which to perform SPR.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L349-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.randomize!" href="#Main.MCPhylo.randomize!"><code>Main.MCPhylo.randomize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomize!(root::Node, num::Int64=100)::nothing</code></pre><p>This function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.</p><ul><li><p><code>root</code> : root node of tree to be edited.</p></li><li><p><code>num</code> : amount of NNI moves to perform.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L198-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR!" href="#Main.MCPhylo.risky_SPR!"><code>Main.MCPhylo.risky_SPR!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    risky_SPR!(root::Node)::AbstractNode</code></pre><p>Performs SPR on tree in place.</p><p>Returns reference to root of altered tree. Does not check for correct formatting of tree.</p><ul><li><code>root</code> : root node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR" href="#Main.MCPhylo.risky_SPR"><code>Main.MCPhylo.risky_SPR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    risky_SPR(root::Node)::AbstractNode
Performs SPR on tree in place. Takes reference to root of tree
Returns copy of root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide" href="#Main.MCPhylo.slide"><code>Main.MCPhylo.slide</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slide(root::T)::T where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.</p><p>Returns root Node of new tree.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L136-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide!" href="#Main.MCPhylo.slide!"><code>Main.MCPhylo.slide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slide!(root::T) where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing!" href="#Main.MCPhylo.swing!"><code>Main.MCPhylo.swing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swing!(root::T) where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing" href="#Main.MCPhylo.swing"><code>Main.MCPhylo.swing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swing(root::T)::T where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.</p><p>Returns root Node of new tree.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_moves.jl#L181-L190">source</a></section></article><h2 id="Tree-Pruning"><a class="docs-heading-anchor" href="#Tree-Pruning">Tree Pruning</a><a id="Tree-Pruning-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Pruning" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree!" href="#Main.MCPhylo.prune_tree!"><code>Main.MCPhylo.prune_tree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_tree!(root::T, node_names::Vector{String})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree.</p><ul><li><p><code>root</code> : root Node of tree to prune.</p></li><li><p><code>node_names</code> : vector of strings, used to specify nodes to remove.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Pruning.jl#L21-L29">source</a></section><section><div><pre><code class="language-none">prune_tree!(root::T, node_names::Vector{T})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree.</p><ul><li><p><code>root</code> : root node of tree to prune.</p></li><li><p><code>node_names</code>: vector of Node objects to be removed from tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Pruning.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree" href="#Main.MCPhylo.prune_tree"><code>Main.MCPhylo.prune_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_tree(root::T, node_names::Vector{String})::T where T&lt;:AbstractNode</code></pre><p>This function removes specific nodes, including their descendants, from a tree.</p><ul><li><p><code>root</code> : root Node of tree to prune.</p></li><li><p><code>node_names</code> : vector of strings, used to specify nodes to remove.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Pruning.jl#L1-L9">source</a></section></article><h2 id="Tree-Search"><a class="docs-heading-anchor" href="#Tree-Search">Tree Search</a><a id="Tree-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Search" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_binary" href="#Main.MCPhylo.find_binary"><code>Main.MCPhylo.find_binary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_binary(root::T, bin::String)::T where T&lt;:GeneralNode</code></pre><p>Find a node by its binary representation. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure whether the node is in the tree at all.</p><p>Returns a reference to the desired Node.</p><ul><li><p><code>root</code> : root Node of tree to search.</p></li><li><p><code>bin</code> : binary representation of desired Node as a String.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Search.jl#L92-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_num" href="#Main.MCPhylo.find_num"><code>Main.MCPhylo.find_num</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_num(root::T, num::Int64)  where T&lt;:GeneralNode</code></pre><p>Find a node by its number. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure whether the node is in the tree at all.</p><p>Returns reference to Node.</p><ul><li><p><code>root</code> : root Node of tree to be searched.</p></li><li><p><code>num</code> : number of desired Node.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Search.jl#L35-L48">source</a></section><section><div><pre><code class="language-none">find_num(root::T, num::Int64, rn::Vector{T})::Bool  where T&lt;:GeneralNode</code></pre><p>Do a post order traversal to find the node corresponding to the <code>num</code>.</p><p>Returns true if node is found, false otherwise. Desired Node is pushed to rn.</p><ul><li><p><code>root</code> : root Node of tree to be searched.</p></li><li><p><code>num</code> : number of desired Node.</p></li><li><p><code>rn</code> : Vector of Nodes; desired Node is pushed to this vector when found.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Search.jl#L61-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_root" href="#Main.MCPhylo.find_root"><code>Main.MCPhylo.find_root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_root(node::Node)::Node</code></pre><p>Finds the root of tree indicated by Node.</p><p>Returns reference to root Node of the tree.</p><ul><li><code>node</code> : Node in Tree of interest.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Search.jl#L114-L122">source</a></section></article><h2 id="Tree-Traversal"><a class="docs-heading-anchor" href="#Tree-Traversal">Tree Traversal</a><a id="Tree-Traversal-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Traversal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_leaves" href="#Main.MCPhylo.get_leaves"><code>Main.MCPhylo.get_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_leaves(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function returns leaf nodes of a tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used.</p><p>Returns a vector of leaf Nodes.</p><ul><li><p><code>root</code> : root Node of tree to traverse.</p></li><li><p><code>traversal</code> : vector of Nodes; leaf Nodes, once found, are pushed to this vector.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L42-L55">source</a></section><section><div><pre><code class="language-none">get_leaves(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function returns the leaves of a tree. Only the root node needs to be supplied.</p><p>Returns vector of leaf Nodes.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_order" href="#Main.MCPhylo.level_order"><code>Main.MCPhylo.level_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">level_order(node::T)::Array{T} where T&lt;:GeneralNode</code></pre><p>This function does level order traversal. Only the root node needs to be supplied.</p><p>Returns Array of Nodes.</p><ul><li><code>node</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_traverse" href="#Main.MCPhylo.level_traverse"><code>Main.MCPhylo.level_traverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T &lt;:GeneralNode</code></pre><p>This function traverses a level of the tree specified through <code>node</code>. The level is specified via the <code>level</code> argument and the nodes visited are stored in the <code>stack</code>. This function is intended as the internal worker for the level_order function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.post_order" href="#Main.MCPhylo.post_order"><code>Main.MCPhylo.post_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p><p>Returns vector of Nodes.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>traversal</code> : vector of Nodes; nodes are pushed to this vector as the tree is traversed.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L3-L15">source</a></section><section><div><pre><code class="language-none">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p><p>Returns vector of Nodes.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.pre_order" href="#Main.MCPhylo.pre_order"><code>Main.MCPhylo.pre_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pre_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a pre order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the pre order traversal.</p><p>Returns vector of Nodes.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>traversal</code> : vector of Nodes; nodes are pushed to this vector as the tree is traversed.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L89-L101">source</a></section><section><div><pre><code class="language-none">pre_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does pre order traversal. Only the root node needs to be supplied.</p><p>Returns vector of Nodes.</p><ul><li><code>root</code> : root Node of tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/12afe65c95b36f37b6d1a0c053f19f53c4f87319/src/Tree/Tree_Traversal.jl#L113-L121">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="intro.html">« Introduction</a><a class="docs-footer-nextpage" href="likelihood.html">Likelihood »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 March 2021 15:44">Monday 1 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
