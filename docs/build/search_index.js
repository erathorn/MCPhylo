var documenterSearchIndex = {"docs":
[{"location":"distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"there are no docstrings in this folder","category":"page"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [MCPhylo]\r\nPages   = [\"distributions/constructors.jl\", \"distributionstruct.jl\", \"extensions.jl\", \"pdmatdistribution.jl\", \"pdmats2.jl\", \"Phylodist.jl\", \"transformdistribution.jl\", \"TreeConstraints.jl\"]\r\nFilter = ","category":"page"},{"location":"distributions.html#Main.MCPhylo.PhyloDist","page":"Distributions","title":"Main.MCPhylo.PhyloDist","text":"This structure implements a Distribution whos likelihood is calculated\naccording to Felsensteins algorithm.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Main.MCPhylo.PhyloDist-Union{Tuple{A}, Tuple{S}, Tuple{T}, Tuple{T,S,A,Int64,Int64,Int64}} where A<:Main.MCPhylo.ArrayVariate where S<:Main.MCPhylo.ScalarVariate where T<:Main.MCPhylo.TreeVariate","page":"Distributions","title":"Main.MCPhylo.PhyloDist","text":"PhyloDist(my_tree::T, mypi::S, rates::A, nbase::Int64, nsites::Int64, nnodes::Int64) where {T<:TreeVariate, S<:ScalarVariate, A<:ArrayVariate}\n\nConvenience function which can work with MCPhylo types.\n\n\n\n\n\n","category":"method"},{"location":"Utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Functions found in all files of Utils folder, ordered according to file of origin.","category":"page"},{"location":"Utils.html#utils.jl","page":"Utils","title":"utils.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"utils.jl\"]","category":"page"},{"location":"Utils.html#Main.MCPhylo.lcp-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractString","page":"Utils","title":"Main.MCPhylo.lcp","text":"lcp(str1::T, str2::T)::T where T <: AbstractString\n\nGet the longest common prefix.\n\n\n\n\n\n","category":"method"},{"location":"Utils.html#FileIO.jl","page":"Utils","title":"FileIO.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"Utils/FileIO.jl\"]","category":"page"},{"location":"Utils.html#Main.MCPhylo.to_file-Tuple{Main.MCPhylo.ModelChains,AbstractString}","page":"Utils","title":"Main.MCPhylo.to_file","text":"to_file(model::ModelChains, outpath::AbstractString)\n\nThis function writes the results of the MCMC runs into files. The destination of the files is specified using outpath. It will create a files for each chain. A params_x.log file storing each parameter sample. In this case x specifies the index of the chain. The file is compatible with MCMC analysis tools like Tracer (http://tree.bio.ed.ac.uk/software/tracer/). If in addition trees are sampled, they are stored in newick format in a file called trees_x.nwk, where x again specifies the index of the respective chain.\n\n\n\n\n\n","category":"method"},{"location":"output.html#output","page":"Output","title":"output","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Pages = [\"output.md\"]","category":"page"},{"location":"output.html#Chains","page":"Output","title":"Chains","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.Chains","category":"page"},{"location":"output.html#Main.MCPhylo.Chains","page":"Output","title":"Main.MCPhylo.Chains","text":"Chains(iters::Integer, params::Integer;\nstart::Integer=1, thin::Integer=1, chains::Integer=1,\nnames::Vector{T}=AbstractString[]) where {T<:AbstractString}\n\n\n\n\n\nChains(value::Array{T, 3},\nstart::Integer=1, thin::Integer=1,\nnames::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])\nwhere {T<:Real, U<:AbstractString, V<:Integer, W <: AbstractString}\n\n\n\n\n\nChains(value::Array{T, 3},\nvalue2::Array{U,3};\nstart::Integer=1, thin::Integer=1,\nnames::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])\nwhere {T<:Real, U<:AbstractString, V<:Integer, W <: AbstractString}\n\n\n\n\n\nChains(value::Matrix{T};\nstart::Integer=1, thin::Integer=1,\nnames::Vector{U}=AbstractString[], chains::Integer=1)\nwhere {T<:Real, U<:AbstractString}\n\n\n\n\n\nChains(value::Vector{T};\nstart::Integer=1, thin::Integer=1,\nnames::U=\"Param1\", chains::Integer=1) where {T<:Real, U <: AbstractString}\n\n\n\n\n\n","category":"type"},{"location":"output.html","page":"Output","title":"Output","text":"Construct a Chains object that stores MCMC sampler output. Returns an object of type Chains.","category":"page"},{"location":"output.html#Arguments","page":"Output","title":"Arguments","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"iters: total number of iterations in each sampler run, of which length(start:thin:iters) outputted iterations will be stored in the object.","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"params: number of parameters to store.","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"value: array whose first, second (optional), and third (optional) dimensions index outputted iterations, parameter elements, and runs of an MCMC sampler, respectively.","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"start: number of the first iteration to be stored.","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"thin: number of steps between consecutive iterations to be stored.","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"chains: number of simulation runs for which to store output, or indices to the runs (default: 1, 2, …).","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"names: names to assign to the parameter elements (default: \"Param1\", \"Param2\", …).","category":"page"},{"location":"toc.html#MCPhylo-Documentation","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"All functions provided by the MCPhylo package are detailed below, organized according to the file they are sourced from.","category":"page"},{"location":"toc.html#Here's-an-example-list","page":"MCPhylo Documentation","title":"Here's an example list","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"one\ntwo\nthree\nfour\nLaTeX syntax works too\nwe can even make links to google.","category":"page"},{"location":"toc.html#Here's-an-example-inset","page":"MCPhylo Documentation","title":"Here's an example inset","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"inset text\r\nthis is all in a box\r\ntext in a box","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"note: Note\nThis is the content of the note.","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"warning: I can write anything here apparently!\nAnd this is another one.these can be multi-line","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"Pages = [\"Tree.md\", \"Likelihood.md\", \"Parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"Sampler.md\", \"samplers.md\", \"Utils.md\"]","category":"page"},{"location":"intro.html#MCPhylo","page":"Introduction","title":"MCPhylo","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package does phylogenetic computations in Julia. It is an extension of the Mamba package which does Markov Chain Monte Carlo (MCMC) sampling for Bayesian analysis. (https://mambajl.readthedocs.io/en/latest/) MCPhylo extends Mamba by a tree module to perform phylogenetic computations.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"which currently supports the output of newick strings for tree structures. The goal is to facilitate phylogenetic computations in computational historical linguistics. To facilitate the inference of phylogenetic trees, Probabilistic Path Hamiltonian Dynamics (https://arxiv.org/pdf/1702.07814.pdf) are implemented.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package is currently under heavy development.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package needs at least Julia 1.3.1. This package is not backwards compatible!","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This module is build on a forked instance of Mamba 0.12.0","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Note This package uses multithreading. (https://docs.julialang.org/en/v1/base/multi-threading/)","category":"page"},{"location":"intro.html#General-Information","page":"Introduction","title":"General Information","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"In order to use the current version of the package clone the repo and place it into your current working directory.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"include(\"./src/MCPhylo.jl\")\r\nusing .MCPhylo","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Installation of the package may also work.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"using Pkg\r\nPkg.add(\"https://github.com/erathorn/JuliaTree\")","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The setup of a model is as in the original Mamba package.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Nexus and CSV files with binarized cognate data are supported.","category":"page"},{"location":"intro.html#New-Functions","page":"Introduction","title":"New Functions","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The standard mcmc function from Mamba takes an extra Boolean argument trees indicating if the sampled trees should be stored. If set to true the trees will be stored. The default is false.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"You can flush the model parameters and the sampled trees to a file, using the to_file function. It takes as a first argument an MCMC object and second a path to a folder where the results should be stored. This file can be read by the Tracer software (https://github.com/beast-dev/tracer/). Additionally, if trees are stored it will create a file with newick strings of these trees.","category":"page"},{"location":"intro.html#New-and-Adjusted-Samplers","page":"Introduction","title":"New & Adjusted Samplers","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"PNUTS is a sampler which does Phylogenetic No-U-Turn sampling (Wahle (forthcomming)). It samples tree stochastic nodes.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"RWM Random walk metroplis hastings sampling can work with trees now. For numerical nodes the sampler and the function signature is as in the original Mamba package. For tree structures the signature is slightly different: RWM(:tree, :all) or RWM(:tree, [:NNI, :Swing]) The first variant uses all available tree manipulation moves (see Tree Manipulation), the second variant only makes use of a user defined subset of these moves. Ladderization of the tree is not an eligible tree manipulation move","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"NUTS can take the argument dtype=:Zygote to use Zygote for the calculation of the gradient. The default is finite differencing.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Slice can also sample trees. It does a slice sampling operation on the branch lengths of the tree.","category":"page"},{"location":"intro.html#Tree-Functionalities","page":"Introduction","title":"Tree Functionalities","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"For the available tree functionalities see: Tree Functionalities, and for exact documentation of the functions involved, see the Tree Functionality page linked along the left-hand side of the page.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Pages = [\"Tree.md\", \"Likelihood.md\", \"Parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"Sampler.md\", \"samplers.md\", \"Substitution.md\", \"Utils.md\"]","category":"page"},{"location":"Links.html#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"Links.html","page":"Links","title":"Links","text":"Below we've provided links to relevant Jupyter Notebooks and publications. More will be added as they come. ","category":"page"},{"location":"Links.html#Notebooks","page":"Links","title":"Notebooks","text":"","category":"section"},{"location":"Links.html#[Markov-Chain-Monte-Carlo-for-Tree-structures](https://github.com/erathorn/Julia_Tree/blob/master/notebook/MCPhylo.ipynb)","page":"Links","title":"Markov Chain Monte Carlo for Tree structures","text":"","category":"section"},{"location":"Links.html","page":"Links","title":"Links","text":"A software package to calculate statistic problems including (phylogenetic) tree structures","category":"page"},{"location":"Links.html#Papers,-References","page":"Links","title":"Papers, References","text":"","category":"section"},{"location":"Links.html#[Markov-Chain-Monte-Carlo-in-Julia](https://mambajl.readthedocs.io/en/latest/)","page":"Links","title":"Markov Chain Monte Carlo in Julia","text":"","category":"section"},{"location":"Links.html#[Probabilistic-Path-Hamiltonian-Dynamics](https://arxiv.org/pdf/1702.07814.pdf)","page":"Links","title":"Probabilistic Path Hamiltonian Dynamics","text":"","category":"section"},{"location":"Tree.html#Tree-Functionality","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"MCPhylo offers several tree functionalities. The underlying type is that of a GeneralNode. It provides the functionality necessary to do MCMC operations with tree structures.","category":"page"},{"location":"Tree.html#Node_Type","page":"Tree Functionality","title":"Node_Type","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Node_Type.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.GeneralNode","text":"Node\n\nThis data type holds the basic Node structure. The type T is used to specify the type of the data stored in the node.\n\nIf nchild is 0 the Node is a leaf node.\nIf root is False the Node is a child of another node.\ninc_length specifies the length of the incomming branch.\nbinary specifies the path from the root to the Node. 1 and 0 represent left and right turns respectively.\n\n\n\n\n\n","category":"type"},{"location":"Tree.html#Main.MCPhylo.Node-Tuple{}","page":"Tree Functionality","title":"Main.MCPhylo.Node","text":"function Node()::Node\n\nThis function will initialize an empty node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Converter","page":"Tree Functionality","title":"Converter","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.from_df\r\nMain.MCPhylo.newick(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.to_covariance\r\nMain.MCPhylo.to_covariance_ultra\r\nMain.MCPhylo.to_df\r\nMain.MCPhylo.to_distance_matrix","category":"page"},{"location":"Tree.html#Main.MCPhylo.from_df","page":"Tree Functionality","title":"Main.MCPhylo.from_df","text":"from_df(df::DataFrame)::Node\n\nThis function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.\n\nReturns the root node of the tree.\n\ndf : Dataframe used to create a tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.newick","text":"newick(node::Node)::String\n\nCreates a newick representation of the tree.\n\nReturns a (properly formatted newick) String.\n\n'node' : root node of tree used to create the newick string.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_covariance","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance","text":"to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N<:GeneralNode,T<: Real}\n\nCalcualte the variance-covariance matrix from tree. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.\n\nReturns an Array of Real numbers.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_covariance_ultra","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance_ultra","text":"to_covariance_ultra(tree::Node)::Array{T,2} where T<: Real\n\nGet the covariance matrix of the ultrametric version of tree with height 1.\n\nReturns an Array of Real numbers.\n\ntree : root of tree used to perform calculation.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_df","page":"Tree Functionality","title":"Main.MCPhylo.to_df","text":"to_df(root::Node)::DataFrame\n\nThis function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry df[i,j] is the length of the edge connecting node i with node j.\n\nReturns a Dataframe.\n\nroot : root of tree used to create matrix represenation.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_distance_matrix","page":"Tree Functionality","title":"Main.MCPhylo.to_distance_matrix","text":"to_distance_matrix(tree::T)::Array{Float64,2} where T <:GeneralNode\n\nCalculate the distance matrix over the set of leaves.\n\nReturns an Array of Floats.\n\ntree : root node of tree used to perform caclulcation.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Basics.jl","page":"Tree Functionality","title":"Tree_Basics.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"This file is a bit larger, and so will be broken into (hopefully coherent) subgroups, listed here:","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Tree Editing","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Return Functions","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Metavariable Functions","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Variable Functions","category":"page"},{"location":"Tree.html#Tree-Editing","page":"Tree Functionality","title":"Tree Editing","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.add_child!\r\nMain.MCPhylo.delete_node!\r\nMain.MCPhylo.insert_node!\r\nMain.MCPhylo.remove_child!\r\nMain.MCPhylo.create_tree_from_leaves\r\n","category":"page"},{"location":"Tree.html#Main.MCPhylo.add_child!","page":"Tree Functionality","title":"Main.MCPhylo.add_child!","text":"add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)\n\nThis function adds a child to the mother node. The arity of the mother node is increased by 1 and the root status of the child is set to False.\n\nmother_node : Node to add a child to.\nchild : Node to add to mother_node.children.\nchild_position : index at which to add the new child node; optional.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.delete_node!","page":"Tree Functionality","title":"Main.MCPhylo.delete_node!","text":"delete_node!(node::Node)::Nothing\n\nThis functions deletes node from a tree and assigns all its children to its mother node.\n\nnode : Node to be deleted.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.insert_node!","page":"Tree Functionality","title":"Main.MCPhylo.insert_node!","text":"insert_node!(mother::Node, children::Vector{T})::T where T<:AbstractNode\n\nThis function inserts a node into a tree after a mother node and gains a subset of the mother's children as its children.\n\nReturns the inserted node.\n\nmother : Node under which to add the newly-inserted node.\nchildren : Children of node referenced by \"mother\" to reassign as children of the newly-inserted node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.remove_child!","page":"Tree Functionality","title":"Main.MCPhylo.remove_child!","text":"remove_child!(mother_node::Node, left::Bool)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. An input of \"True\" removes the left child, while \"False\" removes the right child.\n\nReturns the removed node.\n\nmother_node : Node from which to remove a child.\nleft : boolean value determining which child of mother_node to remove.\n\n\n\n\n\nremove_child!(mother_node::Node, child::Node)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node.\n\nThe removed node is returned.\n\nmother_node : Node from which to remove a child.\nchild : specific Node to remove.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.create_tree_from_leaves","page":"Tree Functionality","title":"Main.MCPhylo.create_tree_from_leaves","text":"create_tree_from_leaves(leaf_nodes::Vector{T})::Node\n\nThis function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Return-Functions","page":"Tree Functionality","title":"Return Functions","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_mother\r\nMain.MCPhylo.get_sister\r\nMain.MCPhylo.node_height\r\nMain.MCPhylo.random_node\r\n\r\n","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_mother","page":"Tree Functionality","title":"Main.MCPhylo.get_mother","text":"function get_mother(node::T)::T  where T<:GeneralNode\n\nThis function gets the mother of node. It does so by looking for the respective binary representation of the mother node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_sister","page":"Tree Functionality","title":"Main.MCPhylo.get_sister","text":"get_sister(node::T)::T  where T<:GeneralNode\n\nThis function gets the sister of node. It does so by looking for the respective binary representation of the sister.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.node_height","page":"Tree Functionality","title":"Main.MCPhylo.node_height","text":"node_height(root::T, mv::Float64)::Float64  where T<:GeneralNode\n\nCalculate the height of a node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.random_node","page":"Tree Functionality","title":"Main.MCPhylo.random_node","text":"function random_node(root::T)::T  where T<:GeneralNode\n\nThis function returns a random node from the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Metavariable-Functions","page":"Tree Functionality","title":"Metavariable Functions","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.tree_length(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.tree_height\r\nMain.MCPhylo.get_branchlength_vector\r\nMain.MCPhylo.get_sum_seperate_length!\r\nMain.MCPhylo.check_binary\r\nMain.MCPhylo.path_length","category":"page"},{"location":"Tree.html#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_length","text":"tree_length(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree length.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.tree_height","page":"Tree Functionality","title":"Main.MCPhylo.tree_height","text":"tree_height(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree height.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(root::N)::Vector{T}  where {N <:GeneralNode, T<:Real}\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(t::TreeStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(root::N, out_vec::Vector{T}) where {N<:GeneralNode, T<:Real}\n\nDo post order traversal to retrieve a vector of branch lengths.\n\n\n\n\n\nget_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\npost_order : Vector of Nodes of a tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_sum_seperate_length!","page":"Tree Functionality","title":"Main.MCPhylo.get_sum_seperate_length!","text":"get_sum_seperate_length!(root::T)::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\nget_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.check_binary","page":"Tree Functionality","title":"Main.MCPhylo.check_binary","text":"check_binary(root::Node)::Bool\n\nchecks to see if given tree is binary; returns true if properly formatted and false otherwise\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.path_length","page":"Tree Functionality","title":"Main.MCPhylo.path_length","text":"path_length(ancestor::T, descendant::T)::Float64  where T<:GeneralNode\n\nNote: The function assumes there is an ancestral relationship between the two nodes.\n\nThis function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Variable-Functions","page":"Tree Functionality","title":"Variable Functions","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.force_ultrametric!\r\nMain.MCPhylo.number_nodes!\r\nMain.MCPhylo.set_branchlength_vector!\r\nMain.MCPhylo.set_binary!","category":"page"},{"location":"Tree.html#Main.MCPhylo.force_ultrametric!","page":"Tree Functionality","title":"Main.MCPhylo.force_ultrametric!","text":"force_ultrametric!(root::T) where T<:GeneralNode\n\nForce an ultrametric version of the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.number_nodes!","page":"Tree Functionality","title":"Main.MCPhylo.number_nodes!","text":"number_nodes!(root::T)::Nothing  where T<:GeneralNode\n\nThis function assigns a unique, sequential number to each node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.set_branchlength_vector!","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T <: Real\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(root::N, blenvec::Array{T}) where {N<:GeneralNode, T<:Real}\n\nThis function sets the branch lengths of a tree to the values specified in blenvec.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.set_binary!","page":"Tree Functionality","title":"Main.MCPhylo.set_binary!","text":"set_binary!(root::Node)\n\nAssign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Clustering.jl","page":"Tree Functionality","title":"Tree_Clustering.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.neighbor_joining\r\nMain.MCPhylo.upgma","category":"page"},{"location":"Tree.html#Main.MCPhylo.neighbor_joining","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining","text":"neighbor_joining(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix used to create Tree.\nleaf_names : Array containing names of leaf nodes.\n\n\n\n\n\nneighbor_joining(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix from which to create tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.upgma","page":"Tree Functionality","title":"Main.MCPhylo.upgma","text":"upgma(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix from which to create the tree.\nleaf_names : array of strings containing names of leaf nodes.\n\n\n\n\n\nupgma(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix from which to create the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Consensus.jl","page":"Tree Functionality","title":"Tree_Consensus.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Consensus.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.find_common_clusters","text":"find_common_clusters(ref_tree, tree:T)\n    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}\n\nUse Day's algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees.\n\nReturns dictionary.\n\nref_tree : Tree used to create dictionary.\ntree : Tree used to create dictionary.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.majority_consensus_tree","text":"majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T<:AbstractNode\n\nConstruct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.max_leaf_rank","text":"max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T<:AbstractNode\n\nRecursive helper function to find the highest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.merge_trees!","text":"merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T<:AbstractNode\n\nMerge two compatible trees, i.e. inserts all cluster of the first tree, which aren't already in the second tree, into the second tree\n\nReturns a Tuple containing the root node of the merged tree, as well as a vector of nodes that were added.\n\nref_tree : tree used to determine common clusters.\ntree : tree used to determine common clusters.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.min_leaf_rank","text":"min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T <: AbstractNode\n\nRecursive helper function to find the lowest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.one_way_compatible","text":"one_way_compatible(ref_tree::T, tree::T)::T where T<:AbstractNode\n\nTakes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.\n\nReturns root node of edited tree.\n\nref_tree : tree used to determine clusters.\ntree : tree used to determine clusters.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.order_tree!","text":"order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())\n    ::Vector{T} where T<:AbstractNode\n\nHelper function to order a tree based on cluster indeces and return the leaves of the ordered tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_left","text":"x_left(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_right","text":"x_right(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Distance.jl","page":"Tree Functionality","title":"Tree_Distance.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Distance.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.BHV_bounds","text":"BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T <:GeneralNode\n\nThis function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.\n\nReturns tuple of floats.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.RF","text":"RF(tree1::T, tree2::T)::Int64 where T <:GeneralNode\n\nCalculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.\n\nReturns result of algorithm as integer.\n\ntree1 : tree used to determine RF distance.\ntree2 : tree used to determine RF distance.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_bipartitions","text":"get_bipartitions(tree::T)::Vector{Tuple} where T <:GeneralNode\n\nGet a vector of all bipartions of tree.\n\nThe resulting vector contains Tuples of sets representing the bipartions.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Ladderizing.jl","page":"Tree Functionality","title":"Tree_Ladderizing.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Ladderizing.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree!","text":"ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T<:AbstractNode)\n\nThis function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree","text":"ladderize_tree(root::T, ascending::Bool=true)::T where T<:AbstractNode)\n\nThis function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Legacy.jl","page":"Tree Functionality","title":"Tree_Legacy.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Legacy.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\npost_order : Vector of Nodes of a tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_moves.jl","page":"Tree Functionality","title":"Tree_moves.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.NNI!\r\nMain.MCPhylo.NNI\r\nMain.MCPhylo.change_edge_length!\r\nMain.MCPhylo.move!\r\nMain.MCPhylo.perform_spr\r\nMain.MCPhylo.randomize!\r\nMain.MCPhylo.risky_SPR!\r\nMain.MCPhylo.risky_SPR\r\nMain.MCPhylo.slide\r\nMain.MCPhylo.slide!\r\nMain.MCPhylo.swing!\r\nMain.MCPhylo.swing","category":"page"},{"location":"Tree.html#Main.MCPhylo.NNI!","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI(root::T, target::T, lor::Bool)::Int64   where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The parameter target specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used lor=true.\n\nThe function returns 1 if the move was successful and 0 else.\n\nroot : root node of tree on which to perform the NNI.\ntarget : specific node of tree to interchange.\nlor : Bool; \"true\" uses the left child of target, \"false,\" the right child.\n\n\n\n\n\nNNI!(root::T, target::Int64)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node.\n\nThe function returns 1 if the move was successful and 0 else.\n\nroot : root node of tree on which to perform the NNI.\ntarget : specific node of tree to interchange.\n\n\n\n\n\nNNI!(root::T)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node.\n\nThe function returns 1 if the move was successful and 0 else.\n\nroot : root node of tree on which to perform the NNI.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.NNI","page":"Tree Functionality","title":"Main.MCPhylo.NNI","text":"NNI(root::T)::T  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root.\n\nReturns a mutated copy while leaving the original tree intact.\n\nroot : root node of tree on which to perform the NNI.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.change_edge_length!","page":"Tree Functionality","title":"Main.MCPhylo.change_edge_length!","text":"change_edge_length!(root::T) where T <:GeneralNode\n\nPick a random node and increase or decrease its length randomly.\n\nroot : root node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.move!","page":"Tree Functionality","title":"Main.MCPhylo.move!","text":"move!(node1::Node, node2::Node, proportion::Float64)\n\nChange the incoming length of node1 and node2 while keeping their combined length constant.\n\nnode1 : Node whose inclength will be modified; this node's inclength will be the total inc_length of both nodes, times proportion.\nnode2 : Node whose inclength will be modified; this node's inclength will be the remainder of total - the new inc_length value of node1.\nproportion : Float64, determines proportion of the inc_length of both nodes assigned to node1.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.perform_spr","page":"Tree Functionality","title":"Main.MCPhylo.perform_spr","text":"perform_spr(root::Node)\n\nperforms SPR on binary tree.\n\nReturns root of tree post-SPR.\n\nroot : Node of tree on which to perform SPR.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.randomize!","page":"Tree Functionality","title":"Main.MCPhylo.randomize!","text":"randomize!(root::Node, num::Int64=100)::nothing\n\nThis function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.\n\nroot : root node of tree to be edited.\nnum : amount of NNI moves to perform.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.risky_SPR!","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR!","text":"    risky_SPR!(root::Node)::AbstractNode\n\nPerforms SPR on tree in place.\n\nReturns reference to root of altered tree. Does not check for correct formatting of tree.\n\nroot : root node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.risky_SPR","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR","text":"    risky_SPR(root::Node)::AbstractNode\nPerforms SPR on tree in place. Takes reference to root of tree\nReturns copy of root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.slide","page":"Tree Functionality","title":"Main.MCPhylo.slide","text":"slide(root::T)::T where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\nReturns root Node of new tree.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.slide!","page":"Tree Functionality","title":"Main.MCPhylo.slide!","text":"slide!(root::T) where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.swing!","page":"Tree Functionality","title":"Main.MCPhylo.swing!","text":"swing!(root::T) where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.swing","page":"Tree Functionality","title":"Main.MCPhylo.swing","text":"swing(root::T)::T where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\nReturns root Node of new tree.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Pruning.jl","page":"Tree Functionality","title":"Tree_Pruning.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.prune_tree!\r\nMain.MCPhylo.prune_tree","category":"page"},{"location":"Tree.html#Main.MCPhylo.prune_tree!","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree!","text":"prune_tree!(root::T, node_names::Vector{String})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree.\n\nroot : root Node of tree to prune.\nnode_names : vector of strings, used to specify nodes to remove.\n\n\n\n\n\nprune_tree!(root::T, node_names::Vector{T})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree.\n\nroot : root node of tree to prune.\nnode_names: vector of Node objects to be removed from tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.prune_tree","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree","text":"prune_tree(root::T, node_names::Vector{String})::T where T<:AbstractNode\n\nThis function removes specific nodes, including their descendants, from a tree.\n\nroot : root Node of tree to prune.\nnode_names : vector of strings, used to specify nodes to remove.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Search.jl","page":"Tree Functionality","title":"Tree_Search.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.find_binary\r\nMain.MCPhylo.find_num\r\nMain.MCPhylo.find_root","category":"page"},{"location":"Tree.html#Main.MCPhylo.find_binary","page":"Tree Functionality","title":"Main.MCPhylo.find_binary","text":"find_binary(root::T, bin::String)::T where T<:GeneralNode\n\nFind a node by its binary representation. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure whether the node is in the tree at all.\n\nReturns a reference to the desired Node.\n\nroot : root Node of tree to search.\nbin : binary representation of desired Node as a String.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.find_num","page":"Tree Functionality","title":"Main.MCPhylo.find_num","text":"find_num(root::T, num::Int64)  where T<:GeneralNode\n\nFind a node by its number. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure whether the node is in the tree at all.\n\nReturns reference to Node.\n\nroot : root Node of tree to be searched.\nnum : number of desired Node.\n\n\n\n\n\nfind_num(root::T, num::Int64, rn::Vector{T})::Bool  where T<:GeneralNode\n\nDo a post order traversal to find the node corresponding to the num.\n\nReturns true if node is found, false otherwise. Desired Node is pushed to rn.\n\nroot : root Node of tree to be searched.\nnum : number of desired Node.\nrn : Vector of Nodes; desired Node is pushed to this vector when found.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.find_root","page":"Tree Functionality","title":"Main.MCPhylo.find_root","text":"find_root(node::Node)::Node\n\nTakes a node in a tree and finds the root of that tree.\n\nReturns reference to root Node of the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Traversal.jl","page":"Tree Functionality","title":"Tree_Traversal.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_leaves\r\nMain.MCPhylo.level_order\r\nMain.MCPhylo.level_traverse\r\nMain.MCPhylo.post_order\r\nMain.MCPhylo.pre_order","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_leaves","page":"Tree Functionality","title":"Main.MCPhylo.get_leaves","text":"get_leaves(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function returns leaf nodes of a tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used.\n\nReturns a vector of leaf Nodes.\n\nroot : root Node of tree to traverse.\ntraversal : vector of Nodes; leaf Nodes, once found, are pushed to this vector.\n\n\n\n\n\nget_leaves(root::T)::Vector{T} where T<:GeneralNode\n\nThis function returns the leaves of a tree. Only the root node needs to be supplied.\n\nReturns vector of leaf Nodes.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.level_order","page":"Tree Functionality","title":"Main.MCPhylo.level_order","text":"level_order(node::T)::Array{T} where T<:GeneralNode\n\nThis function does level order traversal. Only the root node needs to be supplied.\n\nReturns Array of Nodes.\n\nnode : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.level_traverse","page":"Tree Functionality","title":"Main.MCPhylo.level_traverse","text":"level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T <:GeneralNode\n\nThis function traverses a level of the tree specified through node. The level is specified via the level argument and the nodes visited are stored in the stack. This function is intended as the internal worker for the level_order function.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.post_order","page":"Tree Functionality","title":"Main.MCPhylo.post_order","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\ntraversal : vector of Nodes; nodes are pushed to this vector as the tree is traversed.\n\n\n\n\n\npost_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.pre_order","page":"Tree Functionality","title":"Main.MCPhylo.pre_order","text":"pre_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a pre order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the pre order traversal.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\ntraversal : vector of Nodes; nodes are pushed to this vector as the tree is traversed.\n\n\n\n\n\npre_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does pre order traversal. Only the root node needs to be supplied.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"model.html#model","page":"Model","title":"model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Pages = [\"model.md\"]","category":"page"},{"location":"model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Main.MCPhylo.Model","category":"page"},{"location":"model.html#Main.MCPhylo.Model","page":"Model","title":"Main.MCPhylo.Model","text":"Model(; iter::Integer=0, burnin::Integer=0,\n  samplers::Vector{Sampler}=Sampler[], nodes...)\n\nConstruct a Model object that defines a model for MCMC simulation. Returns a Model type object.\n\n\n\n\n\n","category":"type"},{"location":"model.html#Arguments","page":"Model","title":"Arguments","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"iter: current iteration of the MCMC simulation.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"burnin: number of initial draws to be discarded as a burn-in sequence to allow for convergence.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"samplers: block-specific sampling functions.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"nodes...: arbitrary number of user-specified arguments defining logical and stochastic nodes in the model. Argument values must be Logical or Stochastic type objects. Their names in the model will be taken from the argument names.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"Back to top.","category":"page"},{"location":"Likelihood.html#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"There are several prior distributions for tree structures implemented in this package. Also there is a function which calculates the likelihood of a tree given a model using Felsensteins algorithm.","category":"page"},{"location":"Likelihood.html#Likelihood-Calculator-functionality","page":"Likelihood","title":"Likelihood Calculator functionality","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Likelihood/LikelihoodCalculator_Node.jl\"]\r\nFilter =","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.FelsensteinFunction-Union{Tuple{N}, Tuple{T}, Tuple{Array{N,1},T,Array{Float64,1},Array{Float64,3},Int64,Array{Float64,1}}} where N<:Main.MCPhylo.GeneralNode where T<:Real","page":"Likelihood","title":"Main.MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(tree_postorder::Vector{N}, pi_::T, rates::Vector{Float64}, data::Array{Float64,3}, n_c::Int64, blv::Vector{Float64}) where {T<:Real, N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm.\n\nThe function is written such that it is differentiable by Zygote 0.5.3.\n\n\n\n\n\n","category":"method"},{"location":"Likelihood.html#Prior","page":"Likelihood","title":"Prior","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Main.MCPhylo.CompoundDirichlet\r\nMain.MCPhylo.exponentialBL","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.CompoundDirichlet","page":"Likelihood","title":"Main.MCPhylo.CompoundDirichlet","text":"CompoundDirichlet(alpha::Float64, a::Float64, beta::Float64, c::Float64, nterm::Float64)\n\nThis structure implememts the CompoundDirichlet distribution described in Zhang, Rannala and Yang 2012. (DOI:10.1093/sysbio/sys030)\n\n\n\n\n\n","category":"type"},{"location":"Likelihood.html#Main.MCPhylo.exponentialBL","page":"Likelihood","title":"Main.MCPhylo.exponentialBL","text":"exponentialBL(scale::Float64) <: ContinuousUnivariateDistribution\n\nThis structure implememts an exponential prior on the branch lengths of a tree.\n\n\n\n\n\n","category":"type"},{"location":"Parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Functions found in all files of Parser folder, ordered according to file of origin.","category":"page"},{"location":"Parser.html#ParseCSV.jl","page":"Parser","title":"ParseCSV.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser/ParseCSV.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseCSV","page":"Parser","title":"Main.MCPhylo.ParseCSV","text":"ParseCSV(filename::String, header::Bool=true)\n\nThis function parses a CSV file containing input for the MCMC compuation. The file should follow the conventions used for MrBayes. For example:\n\nSwedish_0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,?,0,0,?,0,0\nWelsh_N_0,0,0,0,0,0,0,?,0,0,0,0,?,?,0,0,?,0,0,0,1,?,?,0\nSardinian_N_0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,?,0,0,0,0,0\n\nSet input for \"header\" to false if no header is present in the file.\n\n\n\n\n\n","category":"function"},{"location":"Parser.html#Main.MCPhylo.create_csvdf","page":"Parser","title":"Main.MCPhylo.create_csvdf","text":"function create_csvdf(filecontnt::Array{String}, separator::AbstractString=\",\")::DataFrame\n\nThis function parses a CSV file and returns its content as a DataFrame.\n\nNOTE: May later on be replaced by the respective DataFrames function.\n\n\n\n\n\n","category":"function"},{"location":"Parser.html#ParseNewick.jl","page":"Parser","title":"ParseNewick.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNewick.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseNewick-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNewick","text":"ParseNewick(filename::String)::Array{AbstractNode, 1}\n\nThis function takes a filename as a String, and returns an array of trees(represented as Node objects). The file should solely consist of newick tree representations, separated by line. The function checks for proper newick formatting, and will return an error if the file is incorrectly formatted.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#ParseNexus.jl","page":"Parser","title":"ParseNexus.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNexus.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseNexus-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNexus","text":"ParseNexus(filename::String)\n\nThis function parses a NEXUS file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Main.MCPhylo.create_nexusdf-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.create_nexusdf","text":"create_nexusdf(filecontent::Array{String})::DataFrame\n\nThis function creates a DataFrame of the acutal data.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Main.MCPhylo.extract_meta_info-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.extract_meta_info","text":"extract_meta_info(content::Array{String})\n\nThis function extracts some meta information from the content of the nexus file. It \"eats-up\" the stack\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Parser.jl","page":"Parser","title":"Parser.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser.jl\"]\r\nFilter = ","category":"page"},{"location":"samplers.html#samplers","page":"Samplers","title":"samplers","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Functions found in all files of samplers folder, ordered according to file of origin.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Pages = [\"samplers.md\"]","category":"page"},{"location":"samplers.html#abc","page":"Samplers","title":"abc","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.ABC","category":"page"},{"location":"samplers.html#Main.MCPhylo.ABC","page":"Samplers","title":"Main.MCPhylo.ABC","text":"          ABC(params::ElementOrVector{Symbol},\n\n          scale::ElementOrVector{T}, summary::Function,\n\n          epsilon::Real; kernel::KernelDensityType=SymUniform,\n\n          dist::Function=(Tsim, Tobs) -> sqrt(sum(abs2, Tsim - Tobs)),\n\n          proposal::SymDistributionType=Normal, maxdraw::Integer=1,\n\n          nsim::Integer=1, decay::Real=1.0, randeps::Bool=false,\n\n          args...) where {T<:Real}\n\nConstruct a Sampler object for ABC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{ABCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nscale : scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution.  Values are relative to the unconstrained parameter space, where candidate draws are generated.\nsummary : function that takes a vector of observed or simulated data and returns a summary statistic or vector of statistics.\nepsilon : target tolerance for determining how similar observed and simulated data summary statistics need to be in order to accept a candidate draw.\nkernel : weighting kernel density of type Biweight, Cosine, Epanechnikov, Normal, SymTriangularDist, SymUniform, or Triweight to use in measuring similarity between observed and simulated data summary statistics.  Specified epsilon determines the standard deviation of Normal kernels and widths of the others.\ndist : positive function for the kernel density to compute distance between vectors of observed (Tobs) and simulated (Tsim) data summary statistics (default: Euclidean distance).\nproposal : symmetric distribution of type Biweight, Cosine, Epanechnikov, Normal, SymTriangularDist, SymUniform, or Triweight to be centered around current parameter values and used to generate proposal draws.  Specified scale determines the standard deviations of Normal proposals and widths of the others.\nmaxdraw : maximum number of unaccepted candidates to draw in each call of the sampler.  Draws are generated until one is accepted or the maximum is reached.  Larger values increase acceptance rates at the expense of longer runtimes.\nnsim : number of data sets to simulate in deciding whether to accept a candidate draw.  Larger values lead to closer approximations of the target distribution at the expense of longer runtimes.\ndecay : if 0 < decay <= 1, the rate at which internal tolerances are monotonically decreased from the initial distance between observed and simulated summary statistics toward the maximum of each subsequent distance and epsilon; if decay = 0, internal tolerances are fixed at epsilon.\nrandeps : whether to perturb internal tolerances by random exponential variates.\nargs... : additional keyword arguments to be passed to the dist function.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#amm","page":"Samplers","title":"amm","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.AMM","category":"page"},{"location":"samplers.html#Main.MCPhylo.AMM","page":"Samplers","title":"Main.MCPhylo.AMM","text":"AMM(params::ElementOrVector{Symbol}, Sigma::Matrix{T};\n    adapt::Symbol=:all, args...) where {T<:Real}\n\nConstruct a Sampler object for AMM sampling. Parameters are assumed to be  continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{AMMTune} type object.\n\nparams : stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nSigma : covariance matrix for the non-adaptive multivariate normal proposal distribution.  The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated.\nadapt : type of adaptation phase.  Options are\n:all : adapt proposal during all iterations.\n:burnin : adapt proposal during burn-in iterations.\n:none : no adaptation (multivariate Metropolis sampling with fixed proposal).\nargs... : additional keyword arguments to be passed to the AMMVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#amwg.jl","page":"Samplers","title":"amwg.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.AMWG","category":"page"},{"location":"samplers.html#Main.MCPhylo.AMWG","page":"Samplers","title":"Main.MCPhylo.AMWG","text":"AMWG(params::ElementOrVector{Symbol},\n\nsigma::ElementOrVector{T};\n\nadapt::Symbol=:all,\n\nargs...) where {T<:Real}\n\nConstruct a Sampler object for AMWG sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{ABCTune} type object.\n\nparams:  stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nsigma: scaling value or vector of the same length as the combined elements of nodes\nparams, defining initial standard deviations for univariate normal proposal distributions. Standard deviations are relative to the unconstrained parameter space, where candidate draws are generated.\nadapt : type of adaptation phase.  Options are\n:all : adapt proposal during all iterations.\n:burnin : adapt proposal during burn-in iterations.\n:none : no adaptation (Metropolis-within-Gibbs sampling with fixed proposal).\nargs...: additional keyword arguments to be passed to the AMWGVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bhmc.jl","page":"Samplers","title":"bhmc.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BHMC","category":"page"},{"location":"samplers.html#Main.MCPhylo.BHMC","page":"Samplers","title":"Main.MCPhylo.BHMC","text":"BHMC(params::ElementOrVector{Symbol}, traveltime::Real)\n\nConstruct a Sampler object for BHMC sampling. Parameters are assumed to   have binary numerical values (0 or 1).\n\nReturns a Sampler{BHMCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\ntraveltime: length of time over which particle paths are simulated. It is recommended that supplied values be of the form (n + frac12) pi, where optimal choices of n in mathbbZ^+ are expected to grow with the parameter space dimensionality.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bia.jl","page":"Samplers","title":"bia.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BIA","category":"page"},{"location":"samplers.html#Main.MCPhylo.BIA","page":"Samplers","title":"Main.MCPhylo.BIA","text":"BIA(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for BIA sampling. Parameters are assumed to have    binary numerical values (0 or 1).\n\nReturns a Sampler{BIATune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the BIAVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bmc3.jl","page":"Samplers","title":"bmc3.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BMC3","category":"page"},{"location":"samplers.html#Main.MCPhylo.BMC3","page":"Samplers","title":"Main.MCPhylo.BMC3","text":"BMC3(params::ElementOrVector{Symbol}; k::F=1) where {F<:BMC3Form}\n\nConstruct a Sampler object for BMC3 sampling. Parameters are assumed to have binary numerical values (0 or 1).\n\nReturns a Sampler{BMC3Tune{typeof(k)}} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nk: number of parameters or vector of parameter indices to select at random for simultaneous updating in each call of the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bmg.jl","page":"Samplers","title":"bmg.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BMG","category":"page"},{"location":"samplers.html#Main.MCPhylo.BMG","page":"Samplers","title":"Main.MCPhylo.BMG","text":"BMG(params::ElementOrVector{Symbol}; k::F=1) where {F<:BMGForm}\n\nConstruct a Sampler object for BMG sampling. Parameters are assumed to have  binary numerical values (0 or 1).\n\nReturns a Sampler{BMGTune{typeof(k)}} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nk:  number of parameters or vector of parameter indices to select at random for simultaneous updating in each call of the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#dgs.jl","page":"Samplers","title":"dgs.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.DGS","category":"page"},{"location":"samplers.html#Main.MCPhylo.DGS","page":"Samplers","title":"Main.MCPhylo.DGS","text":"DGS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object for which DGS sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to have discrete univariate distributions with finite supports.\n\nReturns a Sampler{DSTune{Function}} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#hmc.jl","page":"Samplers","title":"hmc.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.HMC","category":"page"},{"location":"samplers.html#Main.MCPhylo.HMC","page":"Samplers","title":"Main.MCPhylo.HMC","text":"HMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nepsilon: step size.\nL: number of steps to take in the Leapfrog algorithm.\nSigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.\ndtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.\n\n\n\n\n\nHMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer, Sigma::Matrix{T}; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#mala.jl","page":"Samplers","title":"mala.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.MALA","category":"page"},{"location":"samplers.html#Main.MCPhylo.MALA","page":"Samplers","title":"Main.MCPhylo.MALA","text":"MALA(params::ElementOrVector{Symbol}, epsilon::Real; args...)\n\nConstruct a Sampler object for MALA sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{MALATune}` type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nepsilon: factor by which the drift and covariance matrix of the proposal distribution are scaled.\nSigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.\ndtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.\n\n\n\n\n\nMALA(params::ElementOrVector{Symbol}, epsilon::Real, Sigma::Matrix{T}; args...)\n\nConstruct a Sampler object for MALA sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{MALATune}` type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#miss.jl","page":"Samplers","title":"miss.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.MISS","category":"page"},{"location":"samplers.html#Main.MCPhylo.MISS","page":"Samplers","title":"Main.MCPhylo.MISS","text":"MISS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object to sampling missing output values. The constructor should only be used to sample stochastic nodes upon which no other stochastic node depends. So-called ‘output nodes’ can be identified with the keys() function. Moreover, when the MISS constructor is included in a vector of Sampler objects to define a sampling scheme, it should be positioned at the beginning of the vector. This ensures that missing output values are updated before any other samplers are executed.\n\nReturns a Sampler{Dict{Symbol, MISSTune}} type object.\n\nparams: stochastic node(s) that contain missing values (NaN) to be updated with the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#nuts.jl","page":"Samplers","title":"nuts.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.NUTS","category":"page"},{"location":"samplers.html#Main.MCPhylo.NUTS","page":"Samplers","title":"Main.MCPhylo.NUTS","text":"NUTS(params::ElementOrVector{Symbol}; dtype::Symbol=:forward, args...)\n\nConstruct a Sampler object for NUTS sampling, with the algorithm’s step size parameter adaptively tuned during burn-in iterations. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{NUTSTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\ndtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.\nargs...: additional keyword arguments to be passed to the NUTSVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#P-NUTS","page":"Samplers","title":"P-NUTS","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.PNUTS","category":"page"},{"location":"samplers.html#Main.MCPhylo.PNUTS","page":"Samplers","title":"Main.MCPhylo.PNUTS","text":"PNUTS(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for PNUTS sampling. The Parameter is assumed to be a tree.\n\nReturns a Sampler{PNUTSTune} type object.\n\nparams: stochastic node to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the PNUTSVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#rwm","page":"Samplers","title":"rwm","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.RWM(::Main.MCPhylo.ElementOrVector{Symbol}, ::Main.MCPhylo.ElementOrVector{T}; args...) where {T<:Real}\r\nMain.MCPhylo.RWM(::Main.MCPhylo.ElementOrVector{Symbol}, ::Main.MCPhylo.ElementOrVector{Symbol}; args...)","category":"page"},{"location":"samplers.html#Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{T,1}, T}}} where T<:Real","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol},\n              scale::ElementOrVector{T}; args...) where {T<:Real})\n\nConstruct a Sampler object for RWM sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{RWMTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nscale: scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution. Values are relative to the unconstrained parameter space, where candidate draws are generated.\nargs...: additional keyword arguments to be passed to the RWMVariate constructor.\n\n\n\n\n\n","category":"method"},{"location":"samplers.html#Main.MCPhylo.RWM-Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{Symbol,1}, Symbol}}","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol}, moves::Array{Symbol}; args...)\n\nConstruct the RWM sampler for Trees. If you set moves to :all it will use all eligible moves to change the tree. These are currently: NNI, SPR, Slide, Swing, :EdgeLength\n\nReturns a Sampler{RWMTune} type object.\n\n\n\n\n\n","category":"method"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#slice.jl","page":"Samplers","title":"slice.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.Slice","category":"page"},{"location":"samplers.html#Main.MCPhylo.Slice","page":"Samplers","title":"Main.MCPhylo.Slice","text":"Slice(params::ElementOrVector{Symbol},                 width::ElementOrVector{T},                 ::Type{F}=Multivariate;                 transform::Bool=false) where {T<:Real, F<:SliceForm}\n\nConstruct a Sampler object for Slice sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{SliceTune{Univariate}} or Sampler{SliceTune{Multivariate}} type object if sampling univariately or multivariately, respectively.\n\nparams: stochastic node(s) to be updated with the sampler.\nwidth: scaling value or vector of the same length as the combined elements of nodes params, defining initial widths of a hyperrectangle from which to simulate values.\nF : sampler type. Options are\n:Univariate : sequential univariate sampling of parameters.\n:Multivariate : joint multivariate sampling.\ntransform: whether to sample parameters on the link-transformed scale (unconstrained parameter space). If true, then constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function, and width is interpreted as being relative to the unconstrained parameter space. Otherwise, sampling is relative to the untransformed space.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#slicesimplex.jl","page":"Samplers","title":"slicesimplex.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.SliceSimplex","category":"page"},{"location":"samplers.html#Main.MCPhylo.SliceSimplex","page":"Samplers","title":"Main.MCPhylo.SliceSimplex","text":"SliceSimplex(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for which SliceSimplex sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to be continuous and constrained to a simplex.\n\nReturns a Sampler{SliceSimplexTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the SliceSimplexVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#sampler.jl","page":"Samplers","title":"sampler.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.Sampler","category":"page"},{"location":"samplers.html#Main.MCPhylo.Sampler","page":"Samplers","title":"Main.MCPhylo.Sampler","text":"Sampler(params::Vector{Symbol}, f::Function, tune::Any=Dict())\n\nConstruct a Sampler object that defines a sampling function for a block of stochastic nodes.\n\nReturns a Sampler{typeof(tune)} type object.\n\nparams: node(s) being block-updated by the sampler.\nf: function for the eval field of the constructed sampler and whose arguments are the other model nodes upon which the sampler depends, typed argument model::Model that contains all model nodes, and/or typed argument block::Integer that is an index identifying the corresponding sampling function in a vector of all samplers for the associated model. Through the arguments, all model nodes and fields can be accessed in the body of the function. The function may return an updated sample for the nodes identified in its params field. Such a return value can be a structure of the same type as the node if the block consists of only one node, or a dictionary of node structures with keys equal to the block node symbols if one or more. Alternatively, a value of nothing may be returned. Return values that are not nothing will be used to automatically update the node values and propagate them to dependent nodes. No automatic updating will be done if nothing is returned.\ntune: tuning parameters needed by the sampling function.\n\n\n\n\n\n","category":"type"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"}]
}
