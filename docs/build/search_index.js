var documenterSearchIndex = {"docs":
[{"location":"distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"there are no docstrings in this folder","category":"page"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [MCPhylo]\r\nPages   = [\"distributions/constructors.jl\", \"distributionstruct.jl\", \"extensions.jl\", \"pdmatdistribution.jl\", \"pdmats2.jl\", \"Phylodist.jl\", \"transformdistribution.jl\", \"TreeConstraints.jl\"]\r\nFilter = ","category":"page"},{"location":"Sampler.html#Sampler","page":"Sampler","title":"Sampler","text":"","category":"section"},{"location":"Sampler.html","page":"Sampler","title":"Sampler","text":"there are no docstrings in this folder","category":"page"},{"location":"Sampler.html","page":"Sampler","title":"Sampler","text":"Modules = [MCPhylo]\r\nPages   = [\"Sampler/SamplerFunctions.jl\", \"PNUTS.jl\", \"ProbPathHMC.jl\"]\r\nFilter = ","category":"page"},{"location":"Utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Functions found in all files of Utils folder, ordered according to file of origin.","category":"page"},{"location":"Utils.html#utils.jl","page":"Utils","title":"utils.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"utils.jl\"]","category":"page"},{"location":"Utils.html#Main.MCPhylo.lcp-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractString","page":"Utils","title":"Main.MCPhylo.lcp","text":"lcp(str1::T, str2::T)::T where T <: AbstractString\n\nGet the longest common prefix.\n\n\n\n\n\n","category":"method"},{"location":"Utils.html#FileIO.jl","page":"Utils","title":"FileIO.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"Utils/FileIO.jl\"]","category":"page"},{"location":"Utils.html#SIMD_Mat.jl","page":"Utils","title":"SIMD_Mat.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"SIMD_Mat.jl\"]","category":"page"},{"location":"output.html#output","page":"Output","title":"output","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"there are no docstrings in this folder","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"output/chains.jl\", \"chainsummary.jl\", \"discretediag.jl\", \"fileio.jl\", \"gelmandiag.jl\", \"gewekediag.jl\", \"heideldiag.jl\", \"mcse.jl\", \"modelchains.jl\", \"modelstats.jl\", \"plot.jl\", \"rafterydiag.jl\", \"stats.jl\"]\r\nFilter = ","category":"page"},{"location":"intro.html#MCPhylo","page":"Introduction","title":"MCPhylo","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package does phylogenetic computations in Julia. It is an extension of the Mamba package which does Markov Chain Monte Carlo (MCMC) sampling for Bayesian analysis. (https://mambajl.readthedocs.io/en/latest/) MCPhylo extends Mamba by a tree module to perform phylogenetic computations.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"which currently supports the output of newick strings for tree structures. The goal is to facilitate phylogenetic computations in computational historical linguistics. To facilitate the inference of phylogenetic trees, Probabilistic Path Hamiltonian Dynamics (https://arxiv.org/pdf/1702.07814.pdf) are implemented.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package is currently under heavy development.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package needs at least Julia 1.3.1. This package is not backwards compatible!","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This module is build on a forked instance of Mamba 0.12.0","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Note This package uses multithreading. (https://docs.julialang.org/en/v1/base/multi-threading/)","category":"page"},{"location":"intro.html#General-Information","page":"Introduction","title":"General Information","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"In order to use the current version of the package clone the repo and place it into your current working directory.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"include(\"./src/MCPhylo.jl\")\r\nusing .MCPhylo","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Installation of the package may also work.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"using Pkg\r\nPkg.add(\"https://github.com/erathorn/JuliaTree\")","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The setup of a model is as in the original Mamba package.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Nexus and CSV files with binarized cognate data are supported.","category":"page"},{"location":"intro.html#New-Functions","page":"Introduction","title":"New Functions","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The standard mcmc function from Mamba takes an extra Boolean argument trees indicating if the sampled trees should be stored. If set to true the trees will be stored. The default is false.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"You can flush the model parameters and the sampled trees to a file, using the to_file function. It takes as a first argument an MCMC object and second a path to a folder where the results should be stored. This file can be read by the Tracer software (https://github.com/beast-dev/tracer/). Additionally, if trees are stored it will create a file with newick strings of these trees.","category":"page"},{"location":"intro.html#New-and-Adjusted-Samplers","page":"Introduction","title":"New & Adjusted Samplers","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"PNUTS is a sampler which does Phylogenetic No-U-Turn sampling (Wahle (forthcomming)). It samples tree stochastic nodes.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"RWM Random walk metroplis hastings sampling can work with trees now. For numerical nodes the sampler and the function signature is as in the original Mamba package. For tree structures the signature is slightly different: RWM(:tree, :all) or RWM(:tree, [:NNI, :Swing]) The first variant uses all available tree manipulation moves (see Tree Manipulation), the second variant only makes use of a user defined subset of these moves. Ladderization of the tree is not an eligible tree manipulation move","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"NUTS can take the argument dtype=:Zygote to use Zygote for the calculation of the gradient. The default is finite differencing.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Slice can also sample trees. It does a slice sampling operation on the branch lengths of the tree.","category":"page"},{"location":"intro.html#Tree-Functionalities","page":"Introduction","title":"Tree Functionalities","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"For the available tree functionalities see: Tree Functionalities, and for exact documentation of the functions involved, see the Tree Functionality page linked along the left-hand side of the page.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Pages = [\"Tree.md\", \"Likelihood.md\", \"Parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"Sampler.md\", \"samplers.md\", \"Substitution.md\", \"Utils.md\"]","category":"page"},{"location":"Links.html#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"Links.html","page":"Links","title":"Links","text":"Below we've provided links to relevant Jupyter Notebooks and publications. More will be added as they come. ","category":"page"},{"location":"Links.html#Notebooks","page":"Links","title":"Notebooks","text":"","category":"section"},{"location":"Links.html#[Markov-Chain-Monte-Carlo-for-Tree-structures](https://github.com/erathorn/Julia_Tree/blob/master/notebook/MCPhylo.ipynb)","page":"Links","title":"Markov Chain Monte Carlo for Tree structures","text":"","category":"section"},{"location":"Links.html","page":"Links","title":"Links","text":"A software package to calculate statistic problems including (phylogenetic) tree structures","category":"page"},{"location":"Links.html#Papers,-References","page":"Links","title":"Papers, References","text":"","category":"section"},{"location":"Links.html#[Markov-Chain-Monte-Carlo-in-Julia](https://mambajl.readthedocs.io/en/latest/)","page":"Links","title":"Markov Chain Monte Carlo in Julia","text":"","category":"section"},{"location":"Links.html#[Probabilistic-Path-Hamiltonian-Dynamics](https://arxiv.org/pdf/1702.07814.pdf)","page":"Links","title":"Probabilistic Path Hamiltonian Dynamics","text":"","category":"section"},{"location":"Tree.html#Tree-Functionality","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Functions found in all files of Tree folder, ordered according to file of origin.","category":"page"},{"location":"Tree.html#Converter.jl","page":"Tree Functionality","title":"Converter.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.from_df\r\nMain.MCPhylo.newick(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.to_covariance\r\nMain.MCPhylo.to_covariance_ultra\r\nMain.MCPhylo.to_df\r\nMain.MCPhylo.to_distance_matrix","category":"page"},{"location":"Tree.html#Main.MCPhylo.from_df","page":"Tree Functionality","title":"Main.MCPhylo.from_df","text":"from_df(df::DataFrame)::Node\n\nThis function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.newick","text":"newick(node::Node)::String\n\nCreates a newick represnetation of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_covariance","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance","text":"to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N<:GeneralNode,T<: Real}\n\nCalcualte the variance-covariance matrix from tree. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_covariance_ultra","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance_ultra","text":"to_covariance_ultra(tree::Node)::Array{T,2} where T<: Real\n\nGet the covariance matrix of the ultrametric version of tree with height 1.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_df","page":"Tree Functionality","title":"Main.MCPhylo.to_df","text":"to_df(root::Node)::DataFrame\n\nThis function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry df[i,j] is the length of the edge connecting node i with node j.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_distance_matrix","page":"Tree Functionality","title":"Main.MCPhylo.to_distance_matrix","text":"to_distance_matrix(tree::T)::Array{Float64,2} where T <:GeneralNode\n\nCalculate the distance matrix over the set of leaves.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Node_Type.jl","page":"Tree Functionality","title":"Node_Type.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Node_Type.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Tree_Basics.jl","page":"Tree Functionality","title":"Tree_Basics.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.add_child!\r\nMain.MCPhylo.check_binary\r\nMain.MCPhylo.create_tree_from_leaves\r\nMain.MCPhylo.delete_node!\r\nMain.MCPhylo.force_ultrametric!\r\nMain.MCPhylo.get_branchlength_vector\r\nMain.MCPhylo.get_mother\r\nMain.MCPhylo.get_sister\r\nMain.MCPhylo.get_sum_seperate_length!\r\nMain.MCPhylo.insert_node!\r\nMain.MCPhylo.node_height\r\nMain.MCPhylo.number_nodes!\r\nMain.MCPhylo.path_length\r\nMain.MCPhylo.random_node\r\nMain.MCPhylo.remove_child!\r\nMain.MCPhylo.set_binary!\r\nMain.MCPhylo.set_branchlength_vector!\r\nMain.MCPhylo.tree_height\r\nMain.MCPhylo.tree_length(::T) where T<:Main.MCPhylo.GeneralNode","category":"page"},{"location":"Tree.html#Main.MCPhylo.add_child!","page":"Tree Functionality","title":"Main.MCPhylo.add_child!","text":"add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)\n\nThis function adds a child to the mother node. The arity of the mother node is increased by 1 and the root status of the child is set to False.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.check_binary","page":"Tree Functionality","title":"Main.MCPhylo.check_binary","text":"check_binary(root::Node)::Bool\n\nchecks to see if given tree is binary; returns true if properly formatted and false otherwise\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.create_tree_from_leaves","page":"Tree Functionality","title":"Main.MCPhylo.create_tree_from_leaves","text":"create_tree_from_leaves(leaf_nodes::Vector{T})::Node\n\nThis function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.delete_node!","page":"Tree Functionality","title":"Main.MCPhylo.delete_node!","text":"delete_node!(node::Node)::Nothing\n\nThis functions deletes node from a tree and assigns all its children to its mother node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.force_ultrametric!","page":"Tree Functionality","title":"Main.MCPhylo.force_ultrametric!","text":"force_ultrametric!(root::T) where T<:GeneralNode\n\nForce an ultrametric version of the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(root::N)::Vector{T}  where {N <:GeneralNode, T<:Real}\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(t::TreeStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(root::N, out_vec::Vector{T}) where {N<:GeneralNode, T<:Real}\n\nDo post order traversal to retrieve a vector of branch lengths.\n\n\n\n\n\nget_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_mother","page":"Tree Functionality","title":"Main.MCPhylo.get_mother","text":"function get_mother(node::T)::T  where T<:GeneralNode\n\nThis function gets the mother of node. It does so by looking for the respective binary representation of the mother node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_sister","page":"Tree Functionality","title":"Main.MCPhylo.get_sister","text":"get_sister(node::T)::T  where T<:GeneralNode\n\nThis function gets the sister of node. It does so by looking for the respective binary representation of the sister.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_sum_seperate_length!","page":"Tree Functionality","title":"Main.MCPhylo.get_sum_seperate_length!","text":"get_sum_seperate_length!(root::T)::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\nget_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.insert_node!","page":"Tree Functionality","title":"Main.MCPhylo.insert_node!","text":"insert_node!(mother::Node, children::Vector{T})::T where T<:AbstractNode\n\nThis function inserts a node into a tree after a mother node and gains a subset of the mother's children as its children. Returns the inserted node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.node_height","page":"Tree Functionality","title":"Main.MCPhylo.node_height","text":"node_height(root::T, mv::Float64)::Float64  where T<:GeneralNode\n\nCalculate the height of a node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.number_nodes!","page":"Tree Functionality","title":"Main.MCPhylo.number_nodes!","text":"number_nodes!(root::T)::Nothing  where T<:GeneralNode\n\nThis function assigns a unique, sequential number to each node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.path_length","page":"Tree Functionality","title":"Main.MCPhylo.path_length","text":"path_length(ancestor::T, descendant::T)::Float64  where T<:GeneralNode\n\nNote: The function assumes there is an ancestral relationship between the two nodes.\n\nThis function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.random_node","page":"Tree Functionality","title":"Main.MCPhylo.random_node","text":"function random_node(root::T)::T  where T<:GeneralNode\n\nThis function returns a random node from the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.remove_child!","page":"Tree Functionality","title":"Main.MCPhylo.remove_child!","text":"remove_child!(mother_node::Node, left::Bool)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. The removed node is returned. An input of \"True\" removes the left child, while \"False\" removes the right child.\n\n\n\n\n\nremove_child!(mother_node::Node, child::Node)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. The removed node is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.set_binary!","page":"Tree Functionality","title":"Main.MCPhylo.set_binary!","text":"set_binary!(root::Node)\n\nAssign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.set_branchlength_vector!","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T <: Real\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(root::N, blenvec::Array{T}) where {N<:GeneralNode, T<:Real}\n\nThis function sets the branch lengths of a tree to the values specified in blenvec.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.tree_height","page":"Tree Functionality","title":"Main.MCPhylo.tree_height","text":"tree_height(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree height.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_length","text":"tree_length(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree length.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Clustering.jl","page":"Tree Functionality","title":"Tree_Clustering.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.neighbor_joining\r\nMain.MCPhylo.upgma","category":"page"},{"location":"Tree.html#Main.MCPhylo.neighbor_joining","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining","text":"neighbor_joining(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\nneighbor_joining(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.upgma","page":"Tree Functionality","title":"Main.MCPhylo.upgma","text":"upgma(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\nupgma(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"@autodocs Modules = [MCPhylo] Pages   = [\"Tree_Clustering.jl\"] Filter =","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"page"},{"location":"Tree.html#Tree_Consensus.jl","page":"Tree Functionality","title":"Tree_Consensus.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Consensus.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.find_common_clusters","text":"find_common_clusters(ref_tree, tree:T)\n    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}\n\nUse Day's algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.majority_consensus_tree","text":"majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T<:AbstractNode\n\nConstruct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.max_leaf_rank","text":"max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T<:AbstractNode\n\nRecursive helper function to find the highest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.merge_trees!","text":"merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T<:AbstractNode\n\nMerge two compatible trees, i.e. inserts all cluster of the first tree, which aren't already in the second tree, into the secon tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.min_leaf_rank","text":"min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T <: AbstractNode\n\nRecursive helper function to find the lowest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.one_way_compatible","text":"one_way_compatible(ref_tree::T, tree::T)::T where T<:AbstractNode\n\nTakes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.order_tree!","text":"order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())\n    ::Vector{T} where T<:AbstractNode\n\nHelper function to order a tree based on cluster indeces and return the leaves of the ordered tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_left","text":"x_left(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_right","text":"x_right(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Distance.jl","page":"Tree Functionality","title":"Tree_Distance.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Distance.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.BHV_bounds","text":"BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T <:GeneralNode\n\nThis function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.RF","text":"RF(tree1::T, tree2::T)::Int64 where T <:GeneralNode\n\nCalculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_bipartitions","text":"get_bipartitions(tree::T)::Vector{Tuple} where T <:GeneralNode\n\nGet a vector of all bipartions of tree. The resulting vector contains Tuples of sets representing the bipartions.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Ladderizing.jl","page":"Tree Functionality","title":"Tree_Ladderizing.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Ladderizing.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree!","text":"ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T<:AbstractNode)\n\nThis function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree","text":"ladderize_tree(root::T, ascending::Bool=true)::T where T<:AbstractNode)\n\nThis function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Legacy.jl","page":"Tree Functionality","title":"Tree_Legacy.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Legacy.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_moves.jl","page":"Tree Functionality","title":"Tree_moves.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.NNI!\r\nMain.MCPhylo.NNI\r\nMain.MCPhylo.change_edge_length!\r\nMain.MCPhylo.move!\r\nMain.MCPhylo.perform_spr\r\nMain.MCPhylo.randomize!\r\nMain.MCPhylo.risky_SPR!\r\nMain.MCPhylo.risky_SPR\r\nMain.MCPhylo.slide\r\nMain.MCPhylo.slide!\r\nMain.MCPhylo.swing!\r\nMain.MCPhylo.swing","category":"page"},{"location":"Tree.html#Main.MCPhylo.NNI!","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI(root::T, target::T, lor::Bool)::Int64   where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The parameter target specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used lor=true. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\nNNI!(root::T, target::Int64)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\nNNI!(root::T)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.NNI","page":"Tree Functionality","title":"Main.MCPhylo.NNI","text":"NNI(root::T)::T  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root and returns a mutated copy while leaving the original tree intact.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.change_edge_length!","page":"Tree Functionality","title":"Main.MCPhylo.change_edge_length!","text":"change_edge_length!(root::T) where T <:GeneralNode\n\nPick a random node and increase or decrease its length randomly.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.move!","page":"Tree Functionality","title":"Main.MCPhylo.move!","text":"move!(node1::Node, node2::Node, proportion::Float64)\n\nChange the incomming length of node1 and node2 while keeping there combined length constant.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.perform_spr","page":"Tree Functionality","title":"Main.MCPhylo.perform_spr","text":"perform_spr(root::Node)\n\nperforms SPR on binary tree\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.randomize!","page":"Tree Functionality","title":"Main.MCPhylo.randomize!","text":"randomize!(root::Node, num::Int64=100)::nothing\n\nThis function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.risky_SPR!","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR!","text":"    risky_SPR!(root::Node)::AbstractNode\nPerforms SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not\nReturns reference to root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.risky_SPR","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR","text":"    risky_SPR(root::Node)::AbstractNode\nPerforms SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not\nReturns copy of root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.slide","page":"Tree Functionality","title":"Main.MCPhylo.slide","text":"slide(root::T)::T where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters. The new tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.slide!","page":"Tree Functionality","title":"Main.MCPhylo.slide!","text":"slide!(root::T) where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.swing!","page":"Tree Functionality","title":"Main.MCPhylo.swing!","text":"swing!(root::T) where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.swing","page":"Tree Functionality","title":"Main.MCPhylo.swing","text":"swing(root::T)::T where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children. The new tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Pruning.jl","page":"Tree Functionality","title":"Tree_Pruning.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.prune_tree!\r\nMain.MCPhylo.prune_tree","category":"page"},{"location":"Tree.html#Main.MCPhylo.prune_tree!","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree!","text":"prune_tree!(root::T, node_names::Vector{String})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree\n\n\n\n\n\nprune_tree!(root::T, node_names::Vector{T})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.prune_tree","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree","text":"prune_tree(root::T, node_names::Vector{String})::T where T<:AbstractNode\n\nThis function returns a copy of a tree with specific nodes including their descendants removed\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Search.jl","page":"Tree Functionality","title":"Tree_Search.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.find_binary\r\nMain.MCPhylo.find_num\r\nMain.MCPhylo.find_root","category":"page"},{"location":"Tree.html#Main.MCPhylo.find_binary","page":"Tree Functionality","title":"Main.MCPhylo.find_binary","text":"find_binary(root::T, bin::String)::T where T<:GeneralNode\n\nFind a node by its binary representation. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure wheter the node is in the tree at all.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.find_num","page":"Tree Functionality","title":"Main.MCPhylo.find_num","text":"find_num(root::T, num::Int64)  where T<:GeneralNode\n\nFind a node by its number. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure wheter the node is in the tree at all.\n\n\n\n\n\nfind_num(root::T, num::Int64, rn::Vector{T})::Bool  where T<:GeneralNode\n\nDo a post order traversal to find the node corresponding to the num.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.find_root","page":"Tree Functionality","title":"Main.MCPhylo.find_root","text":"find_root(node::Node)::Node\n\nTakes a node in a tree and finds the root of that tree\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Traversal.jl","page":"Tree Functionality","title":"Tree_Traversal.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_leaves\r\nMain.MCPhylo.level_order\r\nMain.MCPhylo.level_traverse\r\nMain.MCPhylo.post_order\r\nMain.MCPhylo.pre_order","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_leaves","page":"Tree Functionality","title":"Main.MCPhylo.get_leaves","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\n\n\n\n\npost_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.level_order","page":"Tree Functionality","title":"Main.MCPhylo.level_order","text":"level_order(node::T)::Array{T} where T<:GeneralNode\n\nThis function does level order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.level_traverse","page":"Tree Functionality","title":"Main.MCPhylo.level_traverse","text":"level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T <:GeneralNode\n\nThis function traverses a level of the tree specified through node. The level is specified via the level argument and the nodes visited are stored in the stack. This function is intended as the internal worker for the level_order function.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.post_order","page":"Tree Functionality","title":"Main.MCPhylo.post_order","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\n\n\n\n\npost_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.pre_order","page":"Tree Functionality","title":"Main.MCPhylo.pre_order","text":"pre_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a pre order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the pre order traversal.\n\n\n\n\n\npre_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does pre order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"model.html#model","page":"Model","title":"model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"there are no docstrings in this folder","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"Modules = [MCPhylo]\r\nPages   = [\"model/dependent.jl\", \"dependent_tree.jl\", \"graph.jl\", \"initialization.jl\", \"mcmc.jl\", \"model.jl\", \"simulation.jl\"]\r\nFilter = ","category":"page"},{"location":"Likelihood.html#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Functions found in all files of Likelihood folder, ordered according to file of origin.","category":"page"},{"location":"Likelihood.html#LikelihoodCalculator_Node.jl","page":"Likelihood","title":"LikelihoodCalculator_Node.jl","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Likelihood/LikelihoodCalculator_Node.jl\"]\r\nFilter = ","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.FelsensteinFunction-Union{Tuple{N}, Tuple{T}, Tuple{Array{N,1},T,Array{Float64,1},Array{Float64,3},Int64,Array{Float64,1}}} where N<:Main.MCPhylo.GeneralNode where T<:Real","page":"Likelihood","title":"Main.MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(treepostorder::Vector{N}, pi::T, rates::Vector{Float64}, data::Array{Float64,3}, n_c::Int64, blv::Vector{Float64}) where {T<:Real, N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm.\n\nThe function is written such that it is differentiable by Zygote 0.5.3.\n\n\n\n\n\n","category":"method"},{"location":"Likelihood.html#Prior.jl","page":"Likelihood","title":"Prior.jl","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Prior.jl\"]\r\nFilter = ","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.BirthDeath","page":"Likelihood","title":"Main.MCPhylo.BirthDeath","text":"Strict Molecular Clock - BirthDeath Implemented following Yang & Rannala 1997 doi.org/10.1093/oxfordjournals.molbev.a025811\n\n\n\n\n\n","category":"type"},{"location":"Likelihood.html#Main.MCPhylo.BirthDeathSimplified","page":"Likelihood","title":"Main.MCPhylo.BirthDeathSimplified","text":"Strict Molecular Clock - Simplified Birth Death Implemented folloing Yang & Rannala 1996 doi.org/10.1007/BF02338839\n\n\n\n\n\n","category":"type"},{"location":"Parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Functions found in all files of Parser folder, ordered according to file of origin.","category":"page"},{"location":"Parser.html#ParseCSV.jl","page":"Parser","title":"ParseCSV.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser/ParseCSV.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseCSV","page":"Parser","title":"Main.MCPhylo.ParseCSV","text":"ParseCSV(filename::String, header::Bool=true)\n\nThis function parses a CSV file containing input for the MCMC compuation. The file should follow the conventions used for MrBayes. For example:\n\nSwedish_0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,?,0,0,?,0,0\nWelsh_N_0,0,0,0,0,0,0,?,0,0,0,0,?,?,0,0,?,0,0,0,1,?,?,0\nSardinian_N_0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,?,0,0,0,0,0\n\nSet input for \"header\" to false if no header is present in the file.\n\n\n\n\n\n","category":"function"},{"location":"Parser.html#Main.MCPhylo.create_csvdf","page":"Parser","title":"Main.MCPhylo.create_csvdf","text":"function create_csvdf(filecontnt::Array{String}, separator::AbstractString=\",\")::DataFrame\n\nThis function parses a CSV file and returns its content as a DataFrame.\n\nNOTE: May later on be replaced by the respective DataFrames function.\n\n\n\n\n\n","category":"function"},{"location":"Parser.html#ParseNewick.jl","page":"Parser","title":"ParseNewick.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNewick.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseNewick-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNewick","text":"ParseNewick(filename::String)::Array{AbstractNode, 1}\n\nThis function takes a filename as a String, and returns an array of trees(represented as Node objects). The file should solely consist of newick tree representations, separated by line. The function checks for proper newick formatting, and will return an error if the file is incorrectly formatted.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#ParseNexus.jl","page":"Parser","title":"ParseNexus.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNexus.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseNexus-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNexus","text":"ParseNexus(filename::String)\n\nThis function parses a NEXUS file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Main.MCPhylo.create_nexusdf-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.create_nexusdf","text":"create_nexusdf(filecontent::Array{String})::DataFrame\n\nThis function creates a DataFrame of the acutal data.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Main.MCPhylo.extract_meta_info-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.extract_meta_info","text":"extract_meta_info(content::Array{String})\n\nThis function extracts some meta information from the content of the nexus file. It \"eats-up\" the stack\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Parser.jl","page":"Parser","title":"Parser.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser.jl\"]\r\nFilter = ","category":"page"},{"location":"samplers.html#samplers","page":"Samplers","title":"samplers","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Functions found in all files of Parser folder, ordered according to file of origin.","category":"page"},{"location":"samplers.html#rwm.jl","page":"Samplers","title":"rwm.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Modules = [MCPhylo]\r\nPages   = [\"rwm.jl\"]\r\nFilter = ","category":"page"},{"location":"samplers.html#Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{Symbol,1}, Symbol}}} where T<:Real","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol}, moves::Array{Symbol}; args...)\n\nConstruct the RWM sampler for Trees. If you set moves to :all it will use all eligible moves to change the tree. These are currently: NNI, Slide, Swing, :EdgeLength\n\n\n\n\n\n","category":"method"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Modules = [MCPhylo]\r\nPages   = [\"samplers/abc.jl\", \"amm.jl\", \"amwg.jl\", \"bhmc.jl\", \"bia.jl\", \"bmc3.jl\", \"bmg.jl\", \"dgs.jl\", \"hmc.jl\", \"mala.jl\", \"miss.jl\", \"nuts.jl\", \"rwmc.jl\", \"sampler.jl\", \"slice.jl\", \"slicesimplex.jl\"]\r\nFilter = ","category":"page"},{"location":"Substitution.html#Substitution","page":"Substitution","title":"Substitution","text":"","category":"section"},{"location":"Substitution.html","page":"Substitution","title":"Substitution","text":"Functions found in all files of Parser folder, ordered according to file of origin.","category":"page"},{"location":"Substitution.html","page":"Substitution","title":"Substitution","text":"##SubstitutionMat.jl","category":"page"},{"location":"Substitution.html","page":"Substitution","title":"Substitution","text":"Modules = [MCPhylo]\r\nPages   = [\"Substitution/SubstitutionMat.jl\"]\r\nFilter = ","category":"page"},{"location":"Substitution.html#Main.MCPhylo.exponentiate_binary-Tuple{Number,Float64,Float64}","page":"Substitution","title":"Main.MCPhylo.exponentiate_binary","text":"exponentiate_binary(pi::Float64, t::float::64, r::Float64)::Array{Float64,2}\n\nThis function returns the expontiatied matrix for the restriction site model. Following Felsenstein 1981\n\n\n\n\n\n","category":"method"}]
}
