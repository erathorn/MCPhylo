var documenterSearchIndex = {"docs":
[{"location":"distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [MCPhylo]\r\nPages   = [\"distributions/constructors.jl\", \"distributionstruct.jl\", \"extensions.jl\", \"pdmatdistribution.jl\", \"pdmats2.jl\", \"Phylodist.jl\", \"transformdistribution.jl\", \"TreeConstraints.jl\"]\r\nFilter = ","category":"page"},{"location":"distributions.html#Main.MCPhylo.PhyloDist","page":"Distributions","title":"Main.MCPhylo.PhyloDist","text":"This structure implements a Distribution whos likelihood is calculated\naccording to Felsensteins algorithm.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Main.MCPhylo.PhyloDist-Union{Tuple{R}, Tuple{S}, Tuple{T}, Tuple{T,S,R,R,Function}} where R<:Real where S<:(DenseArray{Float64,N} where N) where T<:GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}","page":"Distributions","title":"Main.MCPhylo.PhyloDist","text":"function PhyloDist(my_tree::T, base_freq::S, substitution_rates::R, rates::R, substitution_model::Function) where {T<:Node, S<:DenseArray{Float64}, R<:Real}\n\nConvenience function which can work with MCPhylo types.\n\n\n\n\n\n","category":"method"},{"location":"links.html#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"links.html","page":"Links","title":"Links","text":"Below we've provided links to relevant Jupyter Notebooks and publications. More will be added as they come. ","category":"page"},{"location":"links.html#Notebooks","page":"Links","title":"Notebooks","text":"","category":"section"},{"location":"links.html#[Markov-Chain-Monte-Carlo-for-Tree-structures](https://github.com/erathorn/Julia_Tree/blob/master/notebook/MCPhylo.ipynb)","page":"Links","title":"Markov Chain Monte Carlo for Tree structures","text":"","category":"section"},{"location":"links.html","page":"Links","title":"Links","text":"A software package to calculate statistic problems including (phylogenetic) tree structures","category":"page"},{"location":"links.html#Papers,-References","page":"Links","title":"Papers, References","text":"","category":"section"},{"location":"links.html#[Markov-Chain-Monte-Carlo-in-Julia](https://mambajl.readthedocs.io/en/latest/)","page":"Links","title":"Markov Chain Monte Carlo in Julia","text":"","category":"section"},{"location":"links.html#[Probabilistic-Path-Hamiltonian-Dynamics](https://arxiv.org/pdf/1702.07814.pdf)","page":"Links","title":"Probabilistic Path Hamiltonian Dynamics","text":"","category":"section"},{"location":"output.html#output","page":"Output","title":"output","text":"","category":"section"},{"location":"output.html#Chains","page":"Output","title":"Chains","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.Chains\r\nMain.MCPhylo.getindex\r\nMain.MCPhylo.setindex!\r\nMain.MCPhylo.Base.cat\r\nMain.MCPhylo.Base.keys(::Main.MCPhylo.AbstractChains)\r\nMain.MCPhylo.Base.show(::IO, ::Main.MCPhylo.AbstractChains)\r\nMain.MCPhylo.Base.size","category":"page"},{"location":"output.html#Main.MCPhylo.Chains","page":"Output","title":"Main.MCPhylo.Chains","text":"Chains(iters::Integer, params::Integer;\nstart::Integer=1, thin::Integer=1, chains::Integer=1,\nnames::Vector{T}=AbstractString[]) where {T<:AbstractString}\n\n\n\n\n\nChains(value::Array{T, 3},\nstart::Integer=1, thin::Integer=1,\nnames::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])\nwhere {T<:Real, U<:AbstractString, V<:Integer, W <: AbstractString}\n\n\n\n\n\nChains(value::Array{T, 3},\nvalue2::Array{U,3};\nstart::Integer=1, thin::Integer=1,\nnames::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])\nwhere {T<:Real, U<:AbstractString, V<:Integer, W <: AbstractString}\n\n\n\n\n\nChains(value::Matrix{T};\nstart::Integer=1, thin::Integer=1,\nnames::Vector{U}=AbstractString[], chains::Integer=1)\nwhere {T<:Real, U<:AbstractString}\n\n\n\n\n\nChains(value::Vector{T};\nstart::Integer=1, thin::Integer=1,\nnames::U=\"Param1\", chains::Integer=1) where {T<:Real, U <: AbstractString}\n\nConstruct a Chains object that stores MCMC sampler output.\n\nReturns an object of type Chains.\n\niters: total number of iterations in each sampler run, of which length(start:thin:iters) outputted iterations will be stored in the object.\nparams: number of parameters to store.\nvalue: array whose first, second (optional), and third (optional) dimensions index outputted iterations, parameter elements, and runs of an MCMC sampler, respectively.\nstart: number of the first iteration to be stored.\nthin: number of steps between consecutive iterations to be stored.\nchains: number of simulation runs for which to store output, or indices to the runs (default: 1, 2, …).\nnames: names to assign to the parameter elements (default: \"Param1\", \"Param2\", …).\n\n\n\n\n\n","category":"type"},{"location":"output.html#Base.getindex","page":"Output","title":"Base.getindex","text":"Base.getindex(c::Chains, window, names, chains)\n\nSubset MCMC sampler output. The syntax c[i, j, k] is converted to getindex(c, i, j, k).\n\nSubsetted sampler output stored in the same type of object as that supplied in the call.\n\nc : sampler output to subset.\nwindow : indices of the form start:stop or start:thin:stop can be used to subset iterations, where start and stop define a range for the subset and thin will apply additional thinning to existing sampler output.\nnames : indices for subsetting of parameters that can be specified as strings, integers, or booleans identifying parameters to be kept. ModelChains may additionally be indexed by model node symbols.\nchains : indices for chains can be integers or booleans.\n\nA value of : can be specified for any of the dimensions to indicate no subsetting.\n\n\n\n\n\n","category":"function"},{"location":"output.html#Base.setindex!","page":"Output","title":"Base.setindex!","text":"Base.setindex!(c::AbstractChains, value, iters, names, chains)\n\nStore MCMC sampler output at a given index. The syntax c[i, j, k] = value is converted to setindex!(c, value, i, j, k).\n\nReturns an object of the same type as c with the sampler output stored in the specified indices.\n\nc : object within which to store sampler output.\nvalue : sampler output.\niters : iterations can be indexed as a start:stop or start:thin:stop range, a single numeric index, or a vector of indices; and are taken to be relative to the index range store in the c.range field.\nnames : indices for subsetting of parameters can be specified as strings, integers, or booleans.\nchains : indices for chains can be integers or booleans.\n\nA value of : can be specified for any of the dimensions to indicate no subsetting.\n\n\n\n\n\n","category":"function"},{"location":"output.html#Base.cat","page":"Output","title":"Base.cat","text":"Base.cat(c1::AbstractChains, args::AbstractChains...; dims::Integer)\n\nConcatenate input MCMC chains along a specified dimension. For dimensions other than the specified one, all input chains must have the same sizes, which will also be the sizes of the output chain. The size of the output chain along the specified dimension will be the sum of the sizes of the input chains in that dimension. vcat concatenates vertically along dimension 1, and has the alternative syntax [chain1; chain2; ...]. hcat concatenates horizontally along dimension 2, and has the alternative syntax [chain1 chain2 ...].\n\nReturns a Chains object containing the concatenated input.\n\ndim : dimension (1, 2, or 3) along which to concatenate the input chains.\nc1, args... : Chains to concatenate.\n\n\n\n\n\n","category":"function"},{"location":"output.html#Base.keys-Tuple{AbstractChains}","page":"Output","title":"Base.keys","text":"Base.keys(c::AbstractChains)\n\nReturns names of parameter elements.\n\nc : Chain to return names of.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Base.show-Tuple{IO,AbstractChains}","page":"Output","title":"Base.show","text":"Base.show(io::IO, c::AbstractChains)\n\nPrints header and values of Chain.\n\nio : IO stream on which to print.\nAbstractChains : Chain to print.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Base.size","page":"Output","title":"Base.size","text":"Base.size(c::AbstractChains)\n\nReturns Tuple containing last iteration of MCMC sampler output and dimensions of Chain dimensions of c.value.\n\nc : Chain object of interest.\n\n\n\n\n\nBase.size(c::AbstractChains, ind)\n\nReturns last iteration of MCMC sampler output, or dimension derived from C, according to value of ind.\n\nc : Chain object of interest.\nind : index of tuple to return; 1 returns last iteration of MCMC sampler output, 2 and 3 return dimensions of c.value.\n\n\n\n\n\n","category":"function"},{"location":"output.html#File-I/O","page":"Output","title":"File I/O","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"fileio.jl\"]\r\nFilter =","category":"page"},{"location":"output.html#Base.read-Union{Tuple{T}, Tuple{AbstractString,Type{T}}} where T<:AbstractChains","page":"Output","title":"Base.read","text":"Base.read(name::AbstractString, ::Type{T}) where {T<:AbstractChains}\n\nRead a chain from an external file.\n\nReturns an AbstractChains subtype read from an external file.\n\nname : file to read or write. Recommended convention is for the file name to be specified with a .jls extension.\nT : chain type to read.\nc : chain to write.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Base.write-Tuple{AbstractString,AbstractChains}","page":"Output","title":"Base.write","text":"Base.write(name::AbstractString, c::AbstractChains)\n\nWrite a chain to an external file.\n\nReturns a written external file containing a subtype.\n\nname : file to read or write. Recommended convention is for the file name to be specified with a .jls extension.\nT : chain type to read.\nc : chain to write.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.readcoda-Tuple{AbstractString,AbstractString}","page":"Output","title":"Main.MCPhylo.readcoda","text":"readcoda(output::AbstractString, index::AbstractString)\n\nRead MCMC sampler output generated in the CODA format by OpenBUGS. The function only retains those sampler iterations at which all model parameters were monitored.\n\nReturns a Chains object containing the read sampler output.\n\noutput : text file containing the iteration numbers and sampled values for the model parameters.\nindex : text file containing the names of the parameters, followed by the first and last rows in which their output can be found in the output file.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Discrete-Diagnostics","page":"Output","title":"Discrete Diagnostics","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"discretediag.jl\"]\r\nFilter =","category":"page"},{"location":"output.html#Main.MCPhylo.discretediag-Tuple{AbstractChains}","page":"Output","title":"Main.MCPhylo.discretediag","text":"discretediag(c::AbstractChains; frac::Real=0.3,\n              method::Symbol=:weiss, nsim::Int=1000)\n\nCompute the convergence diagnostic for a discrete variable. Several options are available by choosing method to be one of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT. The first four are based off of Pearson’s chi-square test of homogeneity. The diagnostic tests whether the proportion of the categories of the discrete variable are similar in each chain. The last two methods test whether the transition probabilities between each category are similar between each chain. Along with a between chain assessment of convergence, a within-chain assessment is carried out by comparing a specified fraction (frac), or window, of the beginning of a chain to the specified fraction of the end of the chain. For within-chain assessment, users should ensure that there is sufficient separation between the windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.\n\nA ChainSummary type object with parameters contained in the rows of the value field. The first three columns correspond to the test statistic, degrees of freedom, and p-value of the between-chain assessment. The next columns are the test statistic, degrees of freedom, and p-value for each chain of the within-chain assessment.\n\nc : sampler output on which to perform calculations.\nfrac : proportion of iterations to include in the first window.\nmethod : Specify which method to use. One of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT`.\nnsim : For the bootstrap methods (:DARBOOT, :MCBOOT, and :billingsleyBOOT) the number of bootstrap simulations.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Gelman-Diagnostic","page":"Output","title":"Gelman Diagnostic","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"gelmandiag.jl\"]\r\nFilter =","category":"page"},{"location":"output.html#Main.MCPhylo.gelmandiag-Tuple{AbstractChains}","page":"Output","title":"Main.MCPhylo.gelmandiag","text":"gelmandiag(c::AbstractChains; alpha::Real=0.05, mpsrf::Bool=false,\n            transform::Bool=false)\n\nCompute the convergence diagnostics of Gelman, Rubin, and Brooks for MCMC sampler output. The diagnostics are designed to asses convergence of posterior means estimated with multiple autocorrelated samples (chains). They does so by comparing the between and within-chain variances with metrics called potential scale reduction factors (PSRF). Both univariate and multivariate factors are available to assess the convergence of parameters individually and jointly. Scale factors close to one are indicative of convergence. As a rule of thumb, convergence is concluded if the 0.975 quantile of an estimated factor is less than 1.2. Multiple chains are required for calculations. It is recommended that at least three chains be generated, each with different starting values chosen to be diffuse with respect to the anticipated posterior distribution. Use of multiple chains in the diagnostic provides for more robust assessment of convergence than is possible with single chain diagnostics.\n\nReturns a ChainSummary type object of the form:\n\nstruct ChainSummary\n  value::Array{Float64, 3}\n  rownames::Vector{AbstractString}\n  colnames::Vector{AbstractString}\n  header::AbstractString\nend\n\nwith parameters contained in the rows of the value field, and scale reduction factors and upper-limit quantiles in the first and second columns.\n\nc : sampler output on which to perform calculations.\nalpha : quantile (1 - alpha / 2) at which to estimate the upper limits of scale reduction factors.\nmpsrf : whether to compute the multivariate potential scale reduction factor. This factor will not be calculable if any one of the parameters in the output is a linear combination of others.\ntransform : whether to apply log or logit transformations, as appropriate, to parameters in the chain to potentially produce output that is more normally distributed, an assumption of the PSRF formulations.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Geweke-Diagnostic","page":"Output","title":"Geweke Diagnostic","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.gewekediag","category":"page"},{"location":"output.html#Main.MCPhylo.gewekediag","page":"Output","title":"Main.MCPhylo.gewekediag","text":"gewekediag(x::Vector{T}; first::Real=0.1, last::Real=0.5,\n            etype=:imse, args...) where {T<:Real}\n\n\n\n\n\ngewekediag(c::AbstractChains; first::Real=0.1, last::Real=0.5,\n            etype=:imse, args...)\n\nCompute the convergence diagnostic of Geweke [37] for MCMC sampler output. The diagnostic is designed to asses convergence of posterior means estimated with autocorrelated samples. It computes a normal-based test statistic comparing the sample means in two windows containing proportions of the first and last iterations. Users should ensure that there is sufficient separation between the two windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and test Z-scores and p-values in the first and second columns. Results are chain-specific.\n\nc : sampler output on which to perform calculations.\nfirst : proportion of iterations to include in the first window.\nlast : proportion of iterations to include in the last window.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\nx : vector on which to perform calculations.\n\n\n\n\n\n","category":"function"},{"location":"output.html#Heidel-Diagnostic","page":"Output","title":"Heidel Diagnostic","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.heideldiag","category":"page"},{"location":"output.html#Main.MCPhylo.heideldiag","page":"Output","title":"Main.MCPhylo.heideldiag","text":"heideldiag(x::Vector{T}; alpha::Real=0.05, eps::Real=0.1,\n            etype=:imse, start::Integer=1, args...) where {T<:Real}\n\n\n\n\n\nheideldiag(c::AbstractChains; alpha::Real=0.05, eps::Real=0.1,\n            etype=:imse, args...)\n\nCompute the convergence diagnostic of Heidelberger and Welch for MCMC sampler output. The diagnostic is designed to assess convergence of posterior means estimated with autocorrelated samples and to determine whether a target degree of accuracy is achieved. A stationarity test is performed for convergence assessment by iteratively discarding 10% of the initial samples until the test p-value is non-significant and stationarity is concluded or until 50% have been discarded and stationarity is rejected, whichever occurs first. Then, a halfwidth test is performed by calculating the relative halfwidth of a posterior mean estimation interval as z_1 - alpha  2 hats  bartheta; where z is a standard normal quantile, hats is the Monte Carlo standard error, and bartheta is the estimated posterior mean. If the relative halfwidth is greater than a target ratio, the test is rejected. Rejection of the stationarity or halfwidth test suggests that additional samples are needed.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and numbers of burn-in sequences to discard, whether the stationarity tests are passed (1 = yes, 0 = no), their p-values (p  alpha implies stationarity), posterior means, halfwidths of their (1 - alpha) 100 estimation intervals, and whether the halfwidth tests are passed (1 = yes, 0 = no) in the columns. Results are chain-specific.\n\nc : sampler output on which to perform calculations.\nalpha : significance level for evaluations of stationarity tests and calculations of relative estimation interval halfwidths.\neps : target ratio for the relative halfwidths.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\nx : vector on which to perform calculations.\nstart : ??\n\n\n\n\n\n","category":"function"},{"location":"output.html#Raftery-and-Lewis-Diagnostic","page":"Output","title":"Raftery and Lewis Diagnostic","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.rafterydiag","category":"page"},{"location":"output.html#Main.MCPhylo.rafterydiag","page":"Output","title":"Main.MCPhylo.rafterydiag","text":"rafterydiag(x::Vector{T}; q::Real=0.025, r::Real=0.005,\n                  s::Real=0.95, eps::Real=0.001,\n                  range::AbstractRange=1:1:length(x)) where {T<:Real}\n\n\n\n\n\nrafterydiag(c::AbstractChains; q::Real=0.025, r::Real=0.005,\n                 s::Real=0.95, eps::Real=0.001)\n\nCompute the convergence diagnostic of Raftery and Lewis for MCMC sampler output. The diagnostic is designed to determine the number of autocorrelated samples required to estimate a specified quantile theta_q, such that Pr(theta le theta_q) = q, within a desired degree of accuracy. In particular, if hattheta_q is the estimand and Pr(theta le hattheta_q) = hatP_q the estimated cumulative probability, then accuracy is specified in terms of r and s, where Pr(q - r  hatP_q  q + r) = s. Thinning may be employed in the calculation of the diagnostic to satisfy its underlying assumptions. However, users may not want to apply the same (or any) thinning when estimating posterior summary statistics because doing so results in a loss of information. Accordingly, sample sizes estimated by the diagnostic tend to be conservative (too large).\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and thinning intervals employed, numbers of samples to discard as burn-in sequences, total numbers (N) to burn-in and retain, numbers of independent samples that would be needed (Nmin), and dependence factors (N  Nmin) in the columns. Results are chain-specific.\n\nc : sampler output on which to perform calculations.\nq : posterior quantile of interest.\nr : margin of error for estimated cumulative probabilities.\ns : probability for the margin of error.\neps : tolerance within which the probabilities of transitioning from initial to retained iterations are within the equilibrium probabilities for the chain. This argument determines the number of samples to discard as a burn-in sequence and is typically left at its default value.\nx : vector on which to perform calculations.\nrange : ??\n\n\n\n\n\n","category":"function"},{"location":"output.html#Monte-Carlo-Standard-Errors","page":"Output","title":"Monte Carlo Standard Errors","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.mcse","category":"page"},{"location":"output.html#Main.MCPhylo.mcse","page":"Output","title":"Main.MCPhylo.mcse","text":"mcse(x::Vector{T}, method::Symbol=:imse; args...) where {T<:Real}\n\nCompute Monte Carlo standard errors.\n\nReturns the numeric standard error value.\n\nx : time series of values on which to perform calculations.\nmethod : method used for the calculations. Options are\n:bm : batch means, with optional argument size::Integer=100 determining the number of sequential values to include in each batch. This method requires that the number of values in x is at least 2 times the batch size.\n:imse : initial monotone sequence estimator.\n:ipse : initial positive sequence estimator.\nargs... : additional arguments for the calculation method.\n\n\n\n\n\n","category":"function"},{"location":"output.html#ModelChains","page":"Output","title":"ModelChains","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Main.MCPhylo.ModelChains","category":"page"},{"location":"output.html#Main.MCPhylo.ModelChains","page":"Output","title":"Main.MCPhylo.ModelChains","text":"ModelChains(c::Chains, m::Model)\n\nSee Chains().\n\n\n\n\n\n","category":"type"},{"location":"output.html#Model-Based-Inference","page":"Output","title":"Model-Based Inference","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"modelstats.jl\"]\r\nFilter =","category":"page"},{"location":"output.html#Distributions.logpdf","page":"Output","title":"Distributions.logpdf","text":"logpdf(mc::ModelChains,\n        nodekeys::Vector{Symbol}=keys(mc.model, :stochastic))\n\n\n\n\n\n","category":"function"},{"location":"output.html#Distributions.logpdf-Tuple{ModelChains,Function,Array{Symbol,1}}","page":"Output","title":"Distributions.logpdf","text":"logpdf(mc::ModelChains, f::Function, nodekeys::Vector{Symbol})\n\nCompute the sum of log-densities at each iteration of MCMC output for stochastic nodes.\n\nReturns a ModelChains object of resulting summed log-densities at each MCMC iteration of the supplied chain.\n\nmc : sampler output from a model fit with the mcmc()` function.\nnodekey/nodekeys : stochastic model node(s) over which to sum densities (default: all).\nf : ??\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.dic-Tuple{ModelChains}","page":"Output","title":"Main.MCPhylo.dic","text":"dic(mc::ModelChains)\n\nCompute the Deviance Information Criterion (DIC) of Spiegelhalter et al. and Gelman et al. from MCMC sampler output.\n\nReturns a ChainSummary type object with DIC results from the methods of Spiegelhalter and Gelman in the first and second rows of the value field, and the DIC value and effective numbers of parameters in the first and second columns; where\n\ntextDIC = -2 mathcalL(barTheta) + 2 p\n\nsuch that mathcalL(barTheta) is the log-likelihood of model outputs given the expected values of model parameters Theta, and p is the effective number of parameters. The latter is defined as p_D = -2 barmathcalL(Theta) + 2 mathcalL(barTheta) for the method of Spiegelhalter and as p_V = frac12 operatornamevar(-2 mathcalL(Theta)) for the method of Gelman. Results are for all chains combined.\n\nmc : sampler output from a model fit with the mcmc() function.\n\n\n\n\n\n","category":"method"},{"location":"output.html#StatsBase.predict","page":"Output","title":"StatsBase.predict","text":"predict(mc::ModelChains,\n         nodekeys::Vector{Symbol}=keys(mc.model, :output))\n\nGenerate MCMC draws from a posterior predictive distribution.\n\nReturns a ModelChains object of draws simulated at each MCMC iteration of the supplied chain. For observed data node y, simulation is from the posterior predictive distribution\n\np(tildey  y) = int p(tildey  Theta) p(Theta  y) dTheta\n\nwhere tildey is an unknown observation on the node, p(tildey  Theta) is the data likelihood, and p(Theta  y) is the posterior distribution of unobserved parameters Theta.\n\nmc : sampler output from a model fit with the mcmc()` function.\nnodekey/nodekeys : observed Stochastic model node(s) for which to generate draws from the predictive distribution (default: all observed data nodes).\n\n\n\n\n\n","category":"function"},{"location":"output.html#Plot","page":"Output","title":"Plot","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"plot.jl\"]\r\nFilter =","category":"page"},{"location":"output.html#Main.MCPhylo.autocorplot-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.autocorplot","text":"autocorplot(c::AbstractChains, indeces::Vector{Int64};                maxlag::Integer=round(Int, 10 * log10(length(c.range))),                legend::Bool=false, na...)\n\n–- INTERNAL –- Helper function called by the plot function when a autocorrelation plot is needed.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.barplot-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.barplot","text":"barplot(c::AbstractChains, indeces::Vector{Int64};\n        legend::Bool=false, position::Symbol=:stack, na...)\n\n–- INTERNAL –- Helper function called by the plot function when a barplot is needed.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.check_vars-Tuple{Array{AbstractString,1},Array{String,1}}","page":"Output","title":"Main.MCPhylo.check_vars","text":"checkvars(simnames::Vector{AbstractString},              vars::Vector{String})::Vector{Int64}\n\n–- INTERNAL –- Helper function that returns a list of indeces that correspond to specific variables. Only those variables get plotted in later steps.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.contourplot-Tuple{AbstractChains}","page":"Output","title":"Main.MCPhylo.contourplot","text":"contourplot(c::AbstractChains; <keyword arguments>)::Vector{Plots.Plot}\n\nFunction that takes a MCMC chain and creates contourplots. If variables are limited with 'vars' keyword argument, at least 2 variables have to be specified, or no contourplot can be drawn.\n\nArguments\n\n'vars::Vector{String}': specifies the variables of the chain that are plotted\n\n. 'filename::String'=\"\": when given, the plots will be saved to a file\n\n'fmt::Symbol': specifies the format of the output file\n'nrow::Integer' / 'ncol::Integer': Define layout of the plot window(s), i.e.                                    how many plots on each page\n'legend::Bool=false': Turn plot legend on / off\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.contourplot_int-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.contourplot_int","text":"contourplot_int(c::AbstractChains, indeces::Vector{Int64};                   bins::Integer=100, na...)\n\n–- INTERNAL –- Helper function called by the contourplot function.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.densityplot-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.densityplot","text":"densityplot(c::AbstractChains, indeces::Vector{Int64}; legend::Bool=false,               trim::Tuple{Real, Real}=(0.025, 0.975), na...)\n\n–- INTERNAL –- Helper function called by the plot function when a densityplot is needed.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.draw-Union{Tuple{T}, Tuple{Array{T,N} where N}} where T<:Plots.Plot","page":"Output","title":"Main.MCPhylo.draw","text":"draw(p::Array{T}; fmt::Symbol=:svg, filename::String=\"\", nrow::Integer=3,\n     ncol::Integer=2, byrow::Bool=false, ask::Bool=true) where T<:Plots.Plot\n\n–- INTERNAL –- Helper function for the plot functions. Displays plots and - if wanted - saves them to a file.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.meanplot-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.meanplot","text":"meanplot(c::AbstractChains, indeces::Vector{Int64};\n         legend::Bool=false, na...)\n\n–- INTERNAL –- Helper function called by the plot function when a meanplot is needed.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.mixeddensityplot-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.mixeddensityplot","text":"mixeddensityplot(c::AbstractChains, indeces::Vector{Int64};\n                 barbounds::Tuple{Real, Real}=(0, Inf), args...)\n\n–- INTERNAL –- Helper function called by the plot function. Checks for each variable if it is discrete or not and plots a barplot for discrete variables and a densityplot for indiscrete variables.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.traceplot-Tuple{AbstractChains,Array{Int64,1}}","page":"Output","title":"Main.MCPhylo.traceplot","text":"traceplot(c::AbstractChains, indeces::Vector{Int64};\n          legend::Bool=false, na...)\n\n–- INTERNAL –- Helper function called by the plot function when a traceplot is needed.\n\n\n\n\n\n","category":"method"},{"location":"output.html#RecipesBase.plot","page":"Output","title":"RecipesBase.plot","text":"plot(c::AbstractChains, ptype::Vector{Symbol}=[:trace, :density];        <keyword arguments>)::Array{Plots.Plot}\n\nFunction that takes a MCMC chain and creates various different plots (trace & density by default).\n\nArguments\n\n'vars::Vector{String}': specifies the variables of the chain that are plotted\n\n. 'filename::String'=\"\": when given, the plots will be saved to a file\n\n'fmt::Symbol': specifies the format of the output file\n'nrow::Integer' / 'ncol::Integer': Define layout of the plot window(s), i.e.                                    how many plots on each page\n'legend::Bool=false': Turn plot legend on / off\n'args': Plottype specific arguments, like the number of bins for the contour         plot or if the barplots bars should be stacked or not. Check the         specific plot functions below to use these arguments.\n\n\n\n\n\n","category":"function"},{"location":"output.html#RecipesBase.plot-Tuple{AbstractChains,Symbol,Array{Int64,1}}","page":"Output","title":"RecipesBase.plot","text":"plot(c::AbstractChains, ptype::Symbol, indeces::Vector{Int64};        legend::Bool=false, args...)\n\n–- INTERNAL –- Helper function to the actual plot function. Calls the specific plotting functions that are needed.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Posterior-Summary-Statistics","page":"Output","title":"Posterior Summary Statistics","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"stats.jl\"]\r\nFilter =","category":"page"},{"location":"output.html#DataAPI.describe-Tuple{IO,AbstractChains}","page":"Output","title":"DataAPI.describe","text":"describe(io::IO, c::AbstractChains;\n              q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975], etype=:bm, args...)\n\nCompute summary statistics for MCMC sampler output.\n\nReturns results from calls to summarystats(c, etype, args...) and quantile(c, q) are printed for all chains combined, and a value of nothing is returned.\n\nc : sampler output on which to perform calculations.\nq : probabilities at which to calculate quantiles.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.changerate-Tuple{AbstractChains}","page":"Output","title":"Main.MCPhylo.changerate","text":"changerate(c::AbstractChains)\n\nEstimate the probability, or rate per iteration, Pr(theta^i ne theta^i-1) of a state space change for iterations i = 2 ldots N in MCMC sampler output. Estimation is performed for each parameter univariately as well as for the full parameter vector multivariately. For continuous output generated from samplers, like Metropolis-Hastings, whose algorithms conditionally accept candidate draws, the probability can be viewed as the acceptance rate.\n\nReturns a ChainSummary type object with parameters in the rows of the value field, and the estimated rates in the column. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.hpd-Tuple{AbstractChains}","page":"Output","title":"Main.MCPhylo.hpd","text":"hpd(c::AbstractChains; alpha::Real=0.05)\n\n\n\n\n\n","category":"method"},{"location":"output.html#Main.MCPhylo.hpd-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:Real","page":"Output","title":"Main.MCPhylo.hpd","text":"hpd(x::Vector{T}; alpha::Real=0.05) where {T<:Real}\n\nCompute highest posterior density (HPD) intervals of Chen and Shao [16] for MCMC sampler output. HPD intervals have the desirable property of being the smallest intervals that contain a given probability. However, their calculation assumes unimodal marginal posterior distributions, and they are not invariant to transformations of parameters like central (quantile-based) posterior intervals.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and lower and upper intervals in the first and second columns. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\nalpha : the 100 * (1 - alpha)% interval to compute.\nx : vector on which to perform calculations.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Statistics.cor-Tuple{AbstractChains}","page":"Output","title":"Statistics.cor","text":"cor(c::AbstractChains)\n\nCompute cross-correlations for MCMC sampler output.\n\nReturns a ChainSummary type object with the first and second dimensions of the value field indexing the model parameters between which correlations. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\n\n\n\n\n\n","category":"method"},{"location":"output.html#Statistics.quantile-Tuple{AbstractChains}","page":"Output","title":"Statistics.quantile","text":"quantile(c::AbstractChains; q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975])\n\nCompute posterior quantiles for MCMC sampler output.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and quantiles in the columns. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\nq : probabilities at which to compute quantiles.\n\n\n\n\n\n","category":"method"},{"location":"output.html#StatsBase.autocor-Tuple{AbstractChains}","page":"Output","title":"StatsBase.autocor","text":"autocor(c::AbstractChains; lags::Vector=[1, 5, 10, 50],\n         relative::Bool=true)\n\nCompute lag-k autocorrelations for MCMC sampler output.\n\nReturns a ChainSummary type object with model parameters indexed by the first dimension of value, lag-autocorrelations by the second, and chains by the third.\n\nc : sampler output on which to perform calculations.\nlags : lags at which to compute autocorrelations.\nrelative : whether the lags are relative to the thinning interval of the output (true) or relative to the absolute iteration numbers (false).\n\n\n\n\n\n","category":"method"},{"location":"output.html#StatsBase.summarystats-Tuple{AbstractChains}","page":"Output","title":"StatsBase.summarystats","text":"summarystats(c::AbstractChains; etype=:bm, args...)\n\nCompute posterior summary statistics for MCMC sampler output.\n\nReturns a ChainSummary type object with parameters in the rows of the value field; and the sample mean, standard deviation, standard error, Monte Carlo standard error, and effective sample size in the columns. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\n\n\n\n\n\n","category":"method"},{"location":"toc.html#MCPhylo-Documentation","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"All functions provided by the MCPhylo package are detailed below, organized according to the file they are sourced from.","category":"page"},{"location":"toc.html#Here's-an-example-list","page":"MCPhylo Documentation","title":"Here's an example list","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"one\ntwo\nthree\nfour\nLaTeX syntax works too\nwe can even make links to google.","category":"page"},{"location":"toc.html#Here's-an-example-inset","page":"MCPhylo Documentation","title":"Here's an example inset","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"inset text\r\nthis is all in a box\r\ntext in a box","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"note: Note\nThis is the content of the note.","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"warning: I can write anything here apparently!\nAnd this is another one.these can be multi-line","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"Pages = [\"Tree.md\", \"Likelihood.md\", \"Parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"Sampler.md\", \"samplers.md\", \"Utils.md\"]","category":"page"},{"location":"intro.html#MCPhylo","page":"Introduction","title":"MCPhylo","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package does phylogenetic computations in Julia. It is an extension of the Mamba package which does Markov Chain Monte Carlo (MCMC) sampling for Bayesian analysis. (https://mambajl.readthedocs.io/en/latest/) MCPhylo extends Mamba by a tree module to perform phylogenetic computations.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"which currently supports the output of newick strings for tree structures. The goal is to facilitate phylogenetic computations in computational historical linguistics. To facilitate the inference of phylogenetic trees, Probabilistic Path Hamiltonian Dynamics (https://arxiv.org/pdf/1702.07814.pdf) are implemented.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package is currently under heavy development.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package needs at least Julia 1.3.1. This package is not backwards compatible!","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This module is build on a forked instance of Mamba 0.12.0","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Note This package uses multithreading. (https://docs.julialang.org/en/v1/base/multi-threading/)","category":"page"},{"location":"intro.html#General-Information","page":"Introduction","title":"General Information","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"In order to use the current version of the package clone the repo and place it into your current working directory.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"include(\"./src/MCPhylo.jl\")\r\nusing .MCPhylo","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Installation of the package may also work.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"using Pkg\r\nPkg.add(\"https://github.com/erathorn/JuliaTree\")","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The setup of a model is as in the original Mamba package.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Nexus and CSV files with binarized cognate data are supported.","category":"page"},{"location":"intro.html#New-Functions","page":"Introduction","title":"New Functions","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The standard mcmc function from Mamba takes an extra Boolean argument trees indicating if the sampled trees should be stored. If set to true the trees will be stored. The default is false.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"You can flush the model parameters and the sampled trees to a file, using the to_file function. It takes as a first argument an MCMC object and second a path to a folder where the results should be stored. This file can be read by the Tracer software (https://github.com/beast-dev/tracer/). Additionally, if trees are stored it will create a file with newick strings of these trees.","category":"page"},{"location":"intro.html#New-and-Adjusted-Samplers","page":"Introduction","title":"New & Adjusted Samplers","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"PNUTS is a sampler which does Phylogenetic No-U-Turn sampling (Wahle (forthcomming)). It samples tree stochastic nodes.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"RWM Random walk metroplis hastings sampling can work with trees now. For numerical nodes the sampler and the function signature is as in the original Mamba package. For tree structures the signature is slightly different: RWM(:tree, :all) or RWM(:tree, [:NNI, :Swing]) The first variant uses all available tree manipulation moves (see Tree Manipulation), the second variant only makes use of a user defined subset of these moves. Ladderization of the tree is not an eligible tree manipulation move","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"NUTS can take the argument dtype=:Zygote to use Zygote for the calculation of the gradient. The default is finite differencing.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Slice can also sample trees. It does a slice sampling operation on the branch lengths of the tree.","category":"page"},{"location":"intro.html#Tree-Functionalities","page":"Introduction","title":"Tree Functionalities","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"For the available tree functionalities see: Tree Functionalities, and for exact documentation of the functions involved, see the Tree Functionality page linked along the left-hand side of the page.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Pages = [\"tree.md\", \"likelihood.md\", \"parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"sampler.md\", \"samplers.md\", \"substitution.md\", \"utils.md\"]","category":"page"},{"location":"tree.html#Tree-Functionality","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"MCPhylo offers several tree functionalities. The underlying type is that of a GeneralNode. It provides the functionality necessary to do MCMC operations with tree structures.","category":"page"},{"location":"tree.html#Node-Type","page":"Tree Functionality","title":"Node Type","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Node_Type.jl\"]\r\nFilter =","category":"page"},{"location":"tree.html#Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.GeneralNode","text":"Node\n\nThis data type holds the basic Node structure. The type T is used to specify the type of the data stored in the node.\n\nIf nchild is 0 the Node is a leaf node.\nIf root is False the Node is a child of another node.\ninc_length specifies the length of the incomming branch.\nbinary specifies the path from the root to the Node. 1 and 0 represent left and right turns respectively.\n\n\n\n\n\n","category":"type"},{"location":"tree.html#Main.MCPhylo.Node-Tuple{}","page":"Tree Functionality","title":"Main.MCPhylo.Node","text":"function Node()::Node\n\nThis function will initialize an empty node.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Converter","page":"Tree Functionality","title":"Converter","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.from_df\r\nMain.MCPhylo.newick(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.to_covariance\r\nMain.MCPhylo.to_covariance_ultra\r\nMain.MCPhylo.to_df\r\nMain.MCPhylo.to_distance_matrix","category":"page"},{"location":"tree.html#Main.MCPhylo.from_df","page":"Tree Functionality","title":"Main.MCPhylo.from_df","text":"from_df(df::DataFrame)::Node\n\nThis function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.\n\nReturns the root node of the tree.\n\ndf : Dataframe used to create a tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.newick-Tuple{T} where T<:GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.newick","text":"newick(node::Node)::String\n\nCreates a newick representation of the tree.\n\nReturns a properly formatted newick String.\n\nnode : root node of tree used to create the newick string.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.to_covariance","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance","text":"to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N<:GeneralNode,T<: Real}\n\nCalcualte the variance-covariance matrix from tree. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.\n\nReturns an Array of Real numbers.\n\ntree : Node in tree of interest.\nblv : branchlength vector of tree. \n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.to_covariance_ultra","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance_ultra","text":"to_covariance_ultra(tree::Node)::Array{T,2} where T<: Real\n\nGet the covariance matrix of the ultrametric version of tree with height 1.\n\nReturns an Array of Real numbers.\n\ntree : root of tree used to perform calculation.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.to_df","page":"Tree Functionality","title":"Main.MCPhylo.to_df","text":"to_df(root::Node)::DataFrame\n\nThis function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry df[i,j] is the length of the edge connecting node i with node j.\n\nReturns a Dataframe.\n\nroot : root of tree used to create matrix represenation.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.to_distance_matrix","page":"Tree Functionality","title":"Main.MCPhylo.to_distance_matrix","text":"to_distance_matrix(tree::T)::Array{Float64,2} where T <:GeneralNode\n\nCalculate the distance matrix over the set of leaves.\n\nReturns an Array of Floats.\n\ntree : root node of tree used to perform caclulcation.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Basics","page":"Tree Functionality","title":"Tree Basics","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"This file is a bit larger, and so will be broken into (hopefully coherent) subgroups, listed here:","category":"page"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Tree Editing","category":"page"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Return Functions","category":"page"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Metavariable Functions","category":"page"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Variable Functions","category":"page"},{"location":"tree.html#Tree-Editing","page":"Tree Functionality","title":"Tree Editing","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.add_child!\r\nMain.MCPhylo.delete_node!\r\nMain.MCPhylo.insert_node!\r\nMain.MCPhylo.remove_child!\r\nMain.MCPhylo.create_tree_from_leaves\r\n","category":"page"},{"location":"tree.html#Main.MCPhylo.add_child!","page":"Tree Functionality","title":"Main.MCPhylo.add_child!","text":"add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)\n\nThis function adds a child to the mother node. The arity of the mother node is increased by 1 and the root status of the child is set to False.\n\nmother_node : Node to add a child to.\nchild : Node to add to mother_node.children.\nchild_position : index at which to add the new child node; optional.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.delete_node!","page":"Tree Functionality","title":"Main.MCPhylo.delete_node!","text":"delete_node!(node::Node)::Nothing\n\nThis functions deletes node from a tree and assigns all its children to its mother node.\n\nnode : Node to be deleted.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.insert_node!","page":"Tree Functionality","title":"Main.MCPhylo.insert_node!","text":"insert_node!(mother::Node, children::Vector{T})::T where T<:AbstractNode\n\nThis function inserts a node into a tree after a mother node and gains a subset of the mother's children as its children.\n\nReturns the inserted node.\n\nmother : Node under which to add the newly-inserted node.\nchildren : Children of node referenced by \"mother\" to reassign as children of the newly-inserted node.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.remove_child!","page":"Tree Functionality","title":"Main.MCPhylo.remove_child!","text":"remove_child!(mother_node::Node, left::Bool)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. An input of \"True\" removes the left child, while \"False\" removes the right child.\n\nReturns the removed node.\n\nmother_node : Node from which to remove a child.\nleft : boolean value determining which child of mother_node to remove.\n\n\n\n\n\nremove_child!(mother_node::Node, child::Node)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node.\n\nThe removed node is returned.\n\nmother_node : Node from which to remove a child.\nchild : specific Node to remove.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.create_tree_from_leaves","page":"Tree Functionality","title":"Main.MCPhylo.create_tree_from_leaves","text":"create_tree_from_leaves(leaf_nodes::Vector{T})::Node\n\nThis function creates a  random binary tree from a list of leaf nodes.\n\nThe root node as access point for the tree is returned.\n\nleaf_nodes : Names of nodes to create.\nnode_size : used to initialize node.data\ncu : ??\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Return-Functions","page":"Tree Functionality","title":"Return Functions","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_mother\r\nMain.MCPhylo.get_sister\r\nMain.MCPhylo.node_height\r\nMain.MCPhylo.random_node\r\n\r\n","category":"page"},{"location":"tree.html#Main.MCPhylo.get_mother","page":"Tree Functionality","title":"Main.MCPhylo.get_mother","text":"function get_mother(node::T)::T  where T<:GeneralNode\n\nThis function gets the mother of node. It does so by looking for the respective binary representation of the mother node.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.get_sister","page":"Tree Functionality","title":"Main.MCPhylo.get_sister","text":"get_sister(node::T)::T  where T<:GeneralNode\n\nThis function gets the sister of node. It does so by looking for the respective binary representation of the sister.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.node_height","page":"Tree Functionality","title":"Main.MCPhylo.node_height","text":"node_height(root::T, mv::Float64)::Float64  where T<:GeneralNode\n\nCalculate the height of a node.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.random_node","page":"Tree Functionality","title":"Main.MCPhylo.random_node","text":"function random_node(root::T)::T  where T<:GeneralNode\n\nThis function returns a random node from the tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Metavariable-Functions","page":"Tree Functionality","title":"Metavariable Functions","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.tree_length(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.tree_height\r\nMain.MCPhylo.get_branchlength_vector\r\nMain.MCPhylo.get_sum_seperate_length!\r\nMain.MCPhylo.check_binary\r\nMain.MCPhylo.path_length","category":"page"},{"location":"tree.html#Main.MCPhylo.tree_length-Tuple{T} where T<:GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_length","text":"tree_length(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree length.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.tree_height","page":"Tree Functionality","title":"Main.MCPhylo.tree_height","text":"tree_height(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree height.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.get_branchlength_vector","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(root::N)::Vector{T}  where {N <:GeneralNode, T<:Real}\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(t::TreeStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(root::N, out_vec::Vector{T}) where {N<:GeneralNode, T<:Real}\n\nDo post order traversal to retrieve a vector of branch lengths.\n\n\n\n\n\nget_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\npost_order : Vector of Nodes of a tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.get_sum_seperate_length!","page":"Tree Functionality","title":"Main.MCPhylo.get_sum_seperate_length!","text":"get_sum_seperate_length!(root::T)::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\nget_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.check_binary","page":"Tree Functionality","title":"Main.MCPhylo.check_binary","text":"check_binary(root::Node)::Bool\n\nchecks to see if given tree is binary; returns true if properly formatted and false otherwise\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.path_length","page":"Tree Functionality","title":"Main.MCPhylo.path_length","text":"path_length(ancestor::T, descendant::T)::Float64  where T<:GeneralNode\n\nNote: The function assumes there is an ancestral relationship between the two nodes.\n\nThis function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Variable-Functions","page":"Tree Functionality","title":"Variable Functions","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.force_ultrametric!\r\nMain.MCPhylo.number_nodes!\r\nMain.MCPhylo.set_branchlength_vector!\r\nMain.MCPhylo.set_binary!","category":"page"},{"location":"tree.html#Main.MCPhylo.force_ultrametric!","page":"Tree Functionality","title":"Main.MCPhylo.force_ultrametric!","text":"force_ultrametric!(root::T) where T<:GeneralNode\n\nForce an ultrametric version of the tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.number_nodes!","page":"Tree Functionality","title":"Main.MCPhylo.number_nodes!","text":"number_nodes!(root::T)::Nothing  where T<:GeneralNode\n\nThis function assigns a unique, sequential number to each node. Leaves are numbered first in alphabetical order.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.set_branchlength_vector!","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T <: Real\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(root::N, blenvec::Array{T}) where {N<:GeneralNode, T<:Real}\n\nThis function sets the branch lengths of a tree to the values specified in blenvec.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.set_binary!","page":"Tree Functionality","title":"Main.MCPhylo.set_binary!","text":"set_binary!(root::Node)\n\nAssign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Clustering","page":"Tree Functionality","title":"Tree Clustering","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.neighbor_joining\r\nMain.MCPhylo.upgma","category":"page"},{"location":"tree.html#Main.MCPhylo.neighbor_joining","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining","text":"neighbor_joining(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix used to create Tree.\nleaf_names : Array containing names of leaf nodes.\n\n\n\n\n\nneighbor_joining(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix from which to create tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.upgma","page":"Tree Functionality","title":"Main.MCPhylo.upgma","text":"upgma(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix from which to create the tree.\nleaf_names : array of strings containing names of leaf nodes.\n\n\n\n\n\nupgma(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves.\n\nReturns a node of the resulting tree, from which it can be traversed.\n\ndm : Matrix from which to create the tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Consensus","page":"Tree Functionality","title":"Tree Consensus","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Consensus.jl\"]\r\nFilter =","category":"page"},{"location":"tree.html#Main.MCPhylo.check_node!-Union{Tuple{T}, Tuple{T,Array{T,1},Dict{String,Int64},Dict{T,Tuple{T,Dict{Int64,T}}},Dict{T,Tuple{T,Dict{Int64,T}}}}, Tuple{T,Array{T,1},Dict{String,Int64},Dict{T,Tuple{T,Dict{Int64,T}}},Dict{T,Tuple{T,Dict{Int64,T}}},Union{Nothing, Dict{Int64,Bool}}}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.check_node!","text":"check_node!(\n    ref_node::T, leaves::Vector{T},\n    leaf_ranks_reverse::Dict{String, Int64},\n    xleft_dict::Dict{T, Tuple{T, Dict{Int64, T}}},\n    xright_dict::Dict{T, Tuple{T, Dict{Int64, T}}},\n    marked_nodes::Union{Dict{Int64, Bool, Nothing}}=nothing\n)::Union{Nothing, Tuple{T, T, T, Dict{Int64, T}, Dict{Int64, T}}} where T<:AbstractNode\n\n–- INTERNAL –- Helper function that handles major chunk of code that onewaycompatible and merge_tree share\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.count_cluster_occurences-Tuple{Array{BitArray{1},1}}","page":"Tree Functionality","title":"Main.MCPhylo.count_cluster_occurences","text":"count_cluster_occurences(bit_vectors::BitVector)\n    ::PriorityQueue{BitVector, Int64}\n\n–- INTERNAL –- Helper function for greedyconsensustree that counts the occurrences of each bit vector representing a cluster. Returns a priority queue.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.depth_dicts-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.depth_dicts","text":"depth_dicts(leaves::Vector{T})\n    ::Tuple{Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}} where T<:AbstractNode\n\n–- INTERNAL –- Helper function for onewaycompatible and merge_trees!. Creates a dictionary based on a vector of leaf nodes, and stores the depth of each node, as well as the left and right path leading to it. Based on section 6.1 of the paper.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.find_common_clusters","text":"find_common_clusters(ref_tree, tree:T)\n    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}\n\n–- INTERNAL –- Use Day's algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees.\n\nReturns dictionary.\n\nref_tree : Tree used to create dictionary.\ntree : Tree used to create dictionary.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.get_cluster_start_indeces-Union{Tuple{T}, Tuple{Array{T,1},T}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.get_cluster_start_indeces","text":"get_cluster_start_indeces(ref_nodes::T, tree::T)\n    ::Dict{T, Int64} where T<:AbstractNode\n\n–- INTERNAL –- Helper function to obtain the cluster start indeces for a tree (tree), based on the nodes of another tree (ref_nodes).\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.get_leaf_ranks-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.get_leaf_ranks","text":"function get_leaf_ranks(nodes::Vector{T})\n    ::Dict{String, Int64} where T<:AbstractNode\n\n–- INTERNAL –- Enumerate the leaf nodes in a tree. Returns a dictionary of this mapping.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.greedy_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.greedy_consensus_tree","text":"greedy_consensus_tree(trees::Vector{T})::T where T<:AbstractNode\n\nConstruct the greedy consensus tree from a set of trees that share the same leafset.  Returns the root node of the greedy consensus tree, from which it can be traversed. This algorithm is based on section 5 and 6.1 of:\n\nJesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.loose_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.loose_consensus_tree","text":"loose_consensus_tree(trees::Vector{T})::T where T<:AbstractNode\n\nConstruct the loose consensus tree from a set of trees that share the same leafset. I.e. a tree with all the clusters that appear in at least one tree and are compatible with all trees. Returns the root node of the loose consensus tree, from which it can be traversed. This algorithm is based on section 4 and 6.1 of:\n\nJesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.majority_consensus_tree","text":"majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T<:AbstractNode\n\nConstruct the majority rule consensus tree from a set of trees that share the same leafset. By default the output tree includes clusters that occur in over 50% of the trees. This can be customized when calling the function. The function returns the root node of the majority consensus tree, from which it can be traversed. The algorithm is based on section 3 and 6.1 of:\n\nJesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.max_leaf_rank","text":"max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T<:AbstractNode\n\n–- INTERNAL –- Recursive helper function to find the highest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.merge_trees!","text":"merge_trees!(ref_tree::T, tree::T)::Vector{T}} where T<:AbstractNode\n\n–- INTERNAL –- Merge two compatible trees, i.e. inserts all cluster of the first tree, which aren't already in the second tree, into the second tree\n\nReturns a Tuple containing the root node of the merged tree, as well as a vector of nodes that were added.\n\nref_tree : tree used to determine common clusters.\ntree : tree used to determine common clusters.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.min_leaf_rank","text":"min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T<:AbstractNode\n\n–– INTERNAL –- Recursive helper function to find the lowest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.one_way_compatible","text":"one_way_compatible(ref_tree::T, tree::T)::T where T<:AbstractNode\n\n–- INTERNAL –- Takes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.\n\nReturns root node of edited tree.\n\nref_tree : tree used to determine clusters.\ntree : tree used to determine clusters.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.order_tree!","text":"order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())\n    ::Vector{T} where T<:AbstractNode\n\n–- INTERNAL –- Helper function to order a tree based on cluster indeces and return the leaves of the ordered tree\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.set_node_stats!-Union{Tuple{T}, Tuple{T,Array{T,1},Bool}, Tuple{T,Array{T,1},Bool,Float64}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.set_node_stats!","text":"set_node_stats!(tree::T, trees::Vector{T}, majority::Bool)\n    ::Nothing where T<:AbstractNode\n\n–- INTERNAL –- Helper function for the construction of a consensus tree. Calculates the inc_lengths and statistics of the nodes in the consensus tree. If dealing with a (in-progress) majority consensus tree, this function will also delete its non-majority clusters (handled by the 'majority' boolean).\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.x_left-Tuple{T} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_left","text":"x_left(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\n–- INTERNAL –- Helper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.x_right-Tuple{T} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_right","text":"x_right(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\n–- INTERNAL –- Helper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Tree-Distance","page":"Tree Functionality","title":"Tree Distance","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Distance.jl\"]\r\nFilter =","category":"page"},{"location":"tree.html#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T<:GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.BHV_bounds","text":"BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T <:GeneralNode\n\nThis function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.\n\nReturns tuple of floats.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T<:GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.RF","text":"RF(tree1::T, tree2::T)::Int64 where T <:GeneralNode\n\nCalculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.\n\nReturns result of algorithm as integer.\n\ntree1 : tree used to determine RF distance.\ntree2 : tree used to determine RF distance.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.get_bipartitions-Tuple{T} where T<:GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_bipartitions","text":"get_bipartitions(tree::T)::Vector{Tuple} where T <:GeneralNode\n\nGet a vector of all bipartions of tree.\n\nReturns a vector containing Tuples of sets representing the bipartions.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Tree-Ladderizing","page":"Tree Functionality","title":"Tree Ladderizing","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Ladderizing.jl\"]\r\nFilter =","category":"page"},{"location":"tree.html#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T,Bool}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree!","text":"ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T<:AbstractNode)\n\nThis function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants.\n\nroot : root Node of tree.\nascending : Boolean, determines whether to sort in ascending (true) or descending (false) order.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T,Bool}} where T<:AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree","text":"ladderize_tree(root::T, ascending::Bool=true)::T where T<:AbstractNode)\n\nThis function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants.\n\nroot : root Node of tree.\nascending : Boolean, determines whether to sort in ascending (true) or descending (false) order.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Tree-Legacy","page":"Tree Functionality","title":"Tree Legacy","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Legacy.jl\"]\r\nFilter =","category":"page"},{"location":"tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\npost_order : Vector of Nodes of a tree.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Tree-moves","page":"Tree Functionality","title":"Tree moves","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.NNI!\r\nMain.MCPhylo.NNI\r\nMain.MCPhylo.change_edge_length!\r\nMain.MCPhylo.move!\r\nMain.MCPhylo.perform_spr\r\nMain.MCPhylo.randomize!\r\nMain.MCPhylo.risky_SPR!\r\nMain.MCPhylo.risky_SPR\r\nMain.MCPhylo.slide\r\nMain.MCPhylo.slide!\r\nMain.MCPhylo.swing!\r\nMain.MCPhylo.swing","category":"page"},{"location":"tree.html#Main.MCPhylo.NNI!","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI(root::T, target::T, lor::Bool)::Int64   where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The parameter target specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used lor=true.\n\nThe function returns 1 if the move was successful and 0 else.\n\nroot : root node of tree on which to perform the NNI.\ntarget : specific node of tree to interchange.\nlor : Bool; \"true\" uses the left child of target, \"false,\" the right child.\n\n\n\n\n\nNNI!(root::T, target::Int64)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node.\n\nThe function returns 1 if the move was successful and 0 else.\n\nroot : root node of tree on which to perform the NNI.\ntarget : specific node of tree to interchange.\n\n\n\n\n\nNNI!(root::T, target::Int64)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\nNNI!(root::T)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node.\n\nThe function returns 1 if the move was successful and 0 else.\n\nroot : root node of tree on which to perform the NNI.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.NNI","page":"Tree Functionality","title":"Main.MCPhylo.NNI","text":"NNI(root::T)::T  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root.\n\nReturns a mutated copy while leaving the original tree intact.\n\nroot : root node of tree on which to perform the NNI.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.change_edge_length!","page":"Tree Functionality","title":"Main.MCPhylo.change_edge_length!","text":"change_edge_length!(root::T) where T <:GeneralNode\n\nPick a random node and increase or decrease its length randomly.\n\nroot : root node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.move!","page":"Tree Functionality","title":"Main.MCPhylo.move!","text":"move!(node1::Node, node2::Node, proportion::Float64)\n\nChange the incoming length of node1 and node2 while keeping their combined length constant.\n\nnode1 : Node whose inclength will be modified; this node's inclength will be the total inc_length of both nodes, times proportion.\nnode2 : Node whose inclength will be modified; this node's inclength will be the remainder of total - the new inc_length value of node1.\nproportion : Float64, determines proportion of the inc_length of both nodes assigned to node1.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.perform_spr","page":"Tree Functionality","title":"Main.MCPhylo.perform_spr","text":"perform_spr(root::Node)\n\nperforms SPR on binary tree.\n\nReturns root of tree post-SPR.\n\nroot : Node of tree on which to perform SPR.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.randomize!","page":"Tree Functionality","title":"Main.MCPhylo.randomize!","text":"randomize!(root::Node, num::Int64=100)::nothing\n\nThis function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.\n\nroot : root node of tree to be edited.\nnum : amount of NNI moves to perform.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.risky_SPR!","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR!","text":"    risky_SPR!(root::Node)::AbstractNode\n\nPerforms SPR on tree in place.\n\nReturns reference to root of altered tree. Does not check for correct formatting of tree.\n\nroot : root node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.risky_SPR","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR","text":"    risky_SPR(root::Node)::AbstractNode\nPerforms SPR on tree in place. Takes reference to root of tree\nReturns copy of root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.slide","page":"Tree Functionality","title":"Main.MCPhylo.slide","text":"slide(root::T)::T where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\nReturns root Node of new tree.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.slide!","page":"Tree Functionality","title":"Main.MCPhylo.slide!","text":"slide!(root::T) where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.swing!","page":"Tree Functionality","title":"Main.MCPhylo.swing!","text":"swing!(root::T) where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.swing","page":"Tree Functionality","title":"Main.MCPhylo.swing","text":"swing(root::T)::T where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\nReturns root Node of new tree.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Pruning","page":"Tree Functionality","title":"Tree Pruning","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.prune_tree!\r\nMain.MCPhylo.prune_tree","category":"page"},{"location":"tree.html#Main.MCPhylo.prune_tree!","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree!","text":"prune_tree!(root::T, node_names::Vector{String})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree.\n\nroot : root Node of tree to prune.\nnode_names : vector of strings, used to specify nodes to remove.\n\n\n\n\n\nprune_tree!(root::T, node_names::Vector{T})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree.\n\nroot : root node of tree to prune.\nnode_names: vector of Node objects to be removed from tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.prune_tree","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree","text":"prune_tree(root::T, node_names::Vector{String})::T where T<:AbstractNode\n\nThis function removes specific nodes, including their descendants, from a tree.\n\nroot : root Node of tree to prune.\nnode_names : vector of strings, used to specify nodes to remove.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Search","page":"Tree Functionality","title":"Tree Search","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.find_binary\r\nMain.MCPhylo.find_num\r\nMain.MCPhylo.find_root","category":"page"},{"location":"tree.html#Main.MCPhylo.find_binary","page":"Tree Functionality","title":"Main.MCPhylo.find_binary","text":"find_binary(root::T, bin::String)::T where T<:GeneralNode\n\nFind a node by its binary representation. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure whether the node is in the tree at all.\n\nReturns a reference to the desired Node.\n\nroot : root Node of tree to search.\nbin : binary representation of desired Node as a String.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.find_num","page":"Tree Functionality","title":"Main.MCPhylo.find_num","text":"find_num(root::T, num::Int64)  where T<:GeneralNode\n\nFind a node by its number. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure whether the node is in the tree at all.\n\nReturns reference to Node.\n\nroot : root Node of tree to be searched.\nnum : number of desired Node.\n\n\n\n\n\nfind_num(root::T, num::Int64, rn::Vector{T})::Bool  where T<:GeneralNode\n\nDo a post order traversal to find the node corresponding to the num.\n\nReturns true if node is found, false otherwise. Desired Node is pushed to rn.\n\nroot : root Node of tree to be searched.\nnum : number of desired Node.\nrn : Vector of Nodes; desired Node is pushed to this vector when found.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.find_root","page":"Tree Functionality","title":"Main.MCPhylo.find_root","text":"find_root(node::Node)::Node\n\nFinds the root of tree indicated by Node.\n\nReturns reference to root Node of the tree.\n\nnode : Node in Tree of interest.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Traversal","page":"Tree Functionality","title":"Tree Traversal","text":"","category":"section"},{"location":"tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_leaves\r\nMain.MCPhylo.level_order\r\nMain.MCPhylo.level_traverse\r\nMain.MCPhylo.post_order\r\nMain.MCPhylo.pre_order","category":"page"},{"location":"tree.html#Main.MCPhylo.get_leaves","page":"Tree Functionality","title":"Main.MCPhylo.get_leaves","text":"get_leaves(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function returns leaf nodes of a tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used.\n\nReturns a vector of leaf Nodes.\n\nroot : root Node of tree to traverse.\ntraversal : vector of Nodes; leaf Nodes, once found, are pushed to this vector.\n\n\n\n\n\nget_leaves(root::T)::Vector{T} where T<:GeneralNode\n\nThis function returns the leaves of a tree. Only the root node needs to be supplied.\n\nReturns vector of leaf Nodes.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.level_order","page":"Tree Functionality","title":"Main.MCPhylo.level_order","text":"level_order(node::T)::Array{T} where T<:GeneralNode\n\nThis function does level order traversal. Only the root node needs to be supplied.\n\nReturns Array of Nodes.\n\nnode : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.level_traverse","page":"Tree Functionality","title":"Main.MCPhylo.level_traverse","text":"level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T <:GeneralNode\n\nThis function traverses a level of the tree specified through node. The level is specified via the level argument and the nodes visited are stored in the stack. This function is intended as the internal worker for the level_order function.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.post_order","page":"Tree Functionality","title":"Main.MCPhylo.post_order","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\ntraversal : vector of Nodes; nodes are pushed to this vector as the tree is traversed.\n\n\n\n\n\npost_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Main.MCPhylo.pre_order","page":"Tree Functionality","title":"Main.MCPhylo.pre_order","text":"pre_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a pre order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the pre order traversal.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\ntraversal : vector of Nodes; nodes are pushed to this vector as the tree is traversed.\n\n\n\n\n\npre_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does pre order traversal. Only the root node needs to be supplied.\n\nReturns vector of Nodes.\n\nroot : root Node of tree.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils.html","page":"Utils","title":"Utils","text":"Functions found in all files of Utils folder, ordered according to file of origin.","category":"page"},{"location":"utils.html#utils","page":"Utils","title":"utils","text":"","category":"section"},{"location":"utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utils.html#Main.MCPhylo.lcp-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractString","page":"Utils","title":"Main.MCPhylo.lcp","text":"lcp(str1::T, str2::T)::T where T <: AbstractString\n\nGet the longest common prefix.\n\n\n\n\n\n","category":"method"},{"location":"utils.html#FileIO","page":"Utils","title":"FileIO","text":"","category":"section"},{"location":"utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"Utils/FileIO.jl\"]","category":"page"},{"location":"utils.html#Main.MCPhylo.to_file-Tuple{ModelChains,AbstractString}","page":"Utils","title":"Main.MCPhylo.to_file","text":"to_file(model::ModelChains, outpath::AbstractString)\n\nThis function writes the results of the MCMC runs into files. The destination of the files is specified using outpath. It will create a files for each chain. A params_x.log file storing each parameter sample. In this case x specifies the index of the chain. The file is compatible with MCMC analysis tools like Tracer (http://tree.bio.ed.ac.uk/software/tracer/). If in addition trees are sampled, they are stored in newick format in a file called trees_x.nwk, where x again specifies the index of the respective chain.\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"parser.html","page":"Parser","title":"Parser","text":"Parser functions create DataFrame and/or Tree representations from data stored as various filetypes.","category":"page"},{"location":"parser.html#CSV","page":"Parser","title":"CSV","text":"","category":"section"},{"location":"parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser/ParseCSV.jl\"]\r\nFilter = ","category":"page"},{"location":"parser.html#Main.MCPhylo.ParseCSV","page":"Parser","title":"Main.MCPhylo.ParseCSV","text":"ParseCSV(filename::String, header::Bool=true)\n\nThis function parses a CSV file containing input for the MCMC compuation. The file should follow the conventions used for MrBayes. For example:\n\nSwedish_0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,?,0,0,?,0,0\nWelsh_N_0,0,0,0,0,0,0,?,0,0,0,0,?,?,0,0,?,0,0,0,1,?,?,0\nSardinian_N_0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,?,0,0,0,0,0\n\nSet input for \"header\" to false if no header is present in the file.\n\nReturns ntax, nchar as Integer values, gap as a String; df is returned as a DataFrame, and stores language names and data.\n\nfilename : Name of CSV file to parse.\nheader : Boolean value. \"true\" denotes there is a header to be skipped; input \"false\" if the file does not contain a header. \n\n\n\n\n\n","category":"function"},{"location":"parser.html#Main.MCPhylo.create_csvdf","page":"Parser","title":"Main.MCPhylo.create_csvdf","text":"function create_csvdf(filecontnt::Array{String}, separator::AbstractString=\",\")::DataFrame\n\nThis function parses a CSV file and returns its content as a DataFrame.\n\nNOTE: May later on be replaced by the respective DataFrames function.\n\n\n\n\n\n","category":"function"},{"location":"parser.html#Newick","page":"Parser","title":"Newick","text":"","category":"section"},{"location":"parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNewick.jl\"]\r\nFilter = ","category":"page"},{"location":"parser.html#Main.MCPhylo.ParseNewick-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNewick","text":"ParseNewick(filename::String)::Array{AbstractNode, 1}\n\nThis function takes a filename as a String, and returns an array of trees(represented as Node objects). The file should solely consist of newick tree representations, separated by line. The function checks for proper newick formatting, and will return an error if the file is incorrectly formatted.\n\nReturns an Array of Nodes; each Node is the root of the tree represented by a newick string in the file.\n\nfilename : name of file containing newick strings to parse.\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Nexus","page":"Parser","title":"Nexus","text":"","category":"section"},{"location":"parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNexus.jl\"]\r\nFilter = ","category":"page"},{"location":"parser.html#Main.MCPhylo.ParseNexus-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNexus","text":"ParseNexus(filename::String)\n\nThis function parses a NEXUS file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes.\n\nReturns ntax, nchar, gap, and missing_representation values; returns Dataframe storing language names and data.\n\nfilename : NEXUS file to be parsed.\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Main.MCPhylo.create_nexusdf-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.create_nexusdf","text":"create_nexusdf(filecontent::Array{String})::DataFrame\n\nThis function creates a DataFrame of the actual data. Used in ParseNexus().\n\nReturns DataFrame of language names and data derived from NEXUS file.\n\nfilecontent : Array of Strings; Strings are read from NEXUS file in ParseNexus().\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Main.MCPhylo.extract_meta_info-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.extract_meta_info","text":"extract_meta_info(content::Array{String})\n\nThis function extracts some meta information from the content of the nexus file. It \"eats-up\" the stack.\n\nReturns values derived from metadata (ntax, nchar, gap, missing_representation). Used in ParseNexus().\n\ncontent : Array of Strings; Strings are read from NEXUS file in ParseNexus().\n\n\n\n\n\n","category":"method"},{"location":"parser.html#General-Parser-Functions","page":"Parser","title":"General Parser Functions","text":"","category":"section"},{"location":"parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser.jl\"]\r\nFilter = ","category":"page"},{"location":"parser.html#Main.MCPhylo.make_tree_with_data","page":"Parser","title":"Main.MCPhylo.make_tree_with_data","text":"make_tree_with_data(filename::String, dialect::AbstractString=\"nexus\",\n\t\t\t\t\t\t gap::Union{Missing, AbstractString}=missing,\n\t\t\t\t\t\t miss::Union{Missing,AbstractString}=missing,\n\t\t\t\t\t\t header::Bool=false)\n\nGeneral parsing function; user specifies type of file to parse.\n\nReturns root Node of tree derived from data, as well as a DataFrame.\n\nfilename : Name of file to parse.\ndialect : Specifies filetype to parse; currently accepts EITHER \"nexus\" or \"csv\" as inputs.\ngap : specifies gap symbol for a CSV file; if \"dialect\" == \"csv\", this input is required, can be ommitted otherwise.\nmiss : specifies missing symbol for a CSV file; if \"dialect\" == \"csv\", this input is required, can be ommitted otherwise.\nheader : Boolean required for parsing CSV file, specifies if file contains a header; input not required when parsing a NEXUS file.\nbinary : Boolean, specifies whether a binary or nonbinary tree should be created for the given file. Defaults to true/binary tree.\n\n\n\n\n\n","category":"function"},{"location":"parser.html#Main.MCPhylo.make_tree_with_data_cu","page":"Parser","title":"Main.MCPhylo.make_tree_with_data_cu","text":"make_tree_with_data_cu(filename::String, dialect::AbstractString=\"nexus\",\n\t\t\t\t\t\t gap::Union{Missing, AbstractString}=missing,\n\t\t\t\t\t\t miss::Union{Missing,AbstractString}=missing,\n\t\t\t\t\t\t header::Bool=false)\n\nGeneral parsing function; user specifies type of file to parse.\n\nReturns root Node of tree derived from data, as well as a CuArray-stored DataFrame.\n\nfilename : Name of file to parse.\ndialect : Specifies filetype to parse; currently accepts EITHER \"nexus\" or \"csv\" as inputs.\ngap : specifies gap symbol for a CSV file; if \"dialect\" == \"csv\", this input is required, can be ommitted otherwise.\nmiss : specifies missing symbol for a CSV file; if \"dialect\" == \"csv\", this input is required, can be ommitted otherwise.\nheader : Boolean required for parsing CSV file, specifies if file contains a header; input not required when parsing a NEXUS file.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"The Model type is designed to store the set of all model nodes, including parameter set \\Theta as denoted in the Mamba Gibbs sampling scheme. In particular, it stores Dependent type objects in its nodes dictionary field. Valid models are ones whose nodes form directed acyclic graphs (DAGs). Sampling functions f_j_j=1^B are saved as Sampler objects in the vector of field samplers. Vector elements j=1,\\ldots,B correspond to sampling blocks Theta_j_j=1^B.","category":"page"},{"location":"model.html#Dependent","page":"Model","title":"Dependent","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Main.MCPhylo.Logical\r\nMain.MCPhylo.Stochastic\r\nMain.MCPhylo.setinits!\r\nMain.MCPhylo.setmonitor!\r\nMain.MCPhylo.update!","category":"page"},{"location":"model.html#Main.MCPhylo.Logical","page":"Model","title":"Main.MCPhylo.Logical","text":"Logical(f::Function, monitor::Union{Bool, Vector{Int}}=true)\n\nConstructor for a Logical model node. This function assumes a the output of the logical operation to be scalar.\n\nf: Function specifying the deterministic operation performed on its arguments. These arguments are other nodes of the model.\nmonitor : Indicates whether the results should be monitored, i.e.saved.\n\n\n\n\n\nLogical(d::Integer, f::Function, monitor::Union{Bool, Vector{Int}}=true)\n\nConstructor for a Logical model node.\n\nd : Specifies the dimension of the output.\nf : Specifies the deterministic operation performed on its arguments. These arguments are other nodes of the model.\nmonitor : Indicates whether the results should be monitored, i.e.saved.\n\n\n\n\n\nLogical(d::T, f::Function, monitor::Union{Bool, Vector{Int}}=true) where T<:GeneralNode\n\nConstructor for a Logical model node, which can hold a Node structure, i.e. a tree.\n\nf is a function specifying the deterministic operation performed on its arguments. These arguments are other nodes of the model.\nmonitor indicates whether the results should be monitored, i.e. saved.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.Stochastic","page":"Model","title":"Main.MCPhylo.Stochastic","text":"Stochastic(f::Function, monitor::Union{Bool, Vector{Int}}=true)\n\nConstructor for a Stochastic model node. This function assumes a the output of the logical operation to be scalar.\n\nf : Specifies the distributional relationship between the arguments and the node. These arguments are other nodes of the model.\nmonitor : Indicates whether the results should be monitored, i.e. saved.\n\n\n\n\n\nStochastic(d::Integer, f::Function, monitor::Union{Bool,\n    Vector{Int}}=true, cuda::Bool=false)\n\nConstructor for a Stochastic model node.\n\nd : Specifies dimensions of the output.\nf : Specifies the distributional relationship between the arguments and the node. These arguments are other nodes of the model.\nmonitor : indicates whether the results should be monitored, i.e. saved.\ncuda : indicates whether the function supports cuda functionality and the data is\n\nin the respective format. THIS FEATURE IS NOT FULLY SUPPORTED.\n\n\n\n\n\nStochastic(d::N, f::Function, monitor::Union{Bool, Vector{Int}}=true) where N<:GeneralNode\n\nConstructor for a Stochastic model node, which can hold a Node structure, i.e. a tree.\n\nf : Specifies the distributional reslationship between the arguments and the node.\n\nThese arguments are other nodes of the model.\n\nmonitor : Indicates whether the results should be monitored, i.e. saved.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.setinits!","page":"Model","title":"Main.MCPhylo.setinits!","text":"setinits!(l::AbstractLogical, m::Model, ::Any=nothing)\n\nSet initial values for a logical node.\n\nReturns the result of a call to setmonitor!(l, l.monitor) or setmonitor!(d, d.monitor).\n\nl : logical node to which to assign initial values.\nm : model containing the node.\n\n\n\n\n\nsetinits!(d::TreeLogical, m::Model, x::T) where {T<:Node}\n\nSet initial values for a logical node.\n\nReturns the result of a call to setmonitor!(l, l.monitor) or setmonitor!(d, d.monitor).\n\nl  : logical node to which to assign initial values.\nm  : model containing the node.\n\n\n\n\n\nsetinits!(s::ScalarStochastic, m::Model, x::Real)\n\nSet initial values for a stochastic node.\n\nReturns the node with its assigned initial values.\n\ns : stochastic node to which to assign initial values.\nm : model containing the node.\nx : values to assign to the node.\n\n\n\n\n\nsetinits!(s::ArrayStochastic, m::Model, x::DenseArray)\n\nSet initial values for a stochastic node.\n\nReturns the node with its assigned initial values.\n\ns : stochastic node to which to assign initial values.\nm : model containing the node.\nx : values to assign to the node.\n\n\n\n\n\nsetinits!(d::TreeStochastic, m::Model, x::T) where {T<:GeneralNode}\n\nSet initial values for a stochastic node.\n\nReturns the node with its assigned initial values.\n\ns or d : stochastic node to which to assign initial values.\nm : model containing the node.\nx : values to assign to the node.\n\n\n\n\n\nsetinits!(m::Model, inits::Dict{Symbol})\n\nSet the initial values of stochastic model nodes.\n\nReturns the model with stochastic nodes initialized and the iter field set equal to 0.\n\nm : model with nodes to be initialized.\ninits : initial values for stochastic model nodes. Dictionary keys and values should be given for each stochastic node.\n\n\n\n\n\nsetinits!(m::Model, inits::Vector{V} where V<:Dict{Symbol})\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.setmonitor!","page":"Model","title":"Main.MCPhylo.setmonitor!","text":"setmonitor!(d::AbstractDependent, monitor::Bool)\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : boolean indicating whether all elements are monitored.\n\n\n\n\n\nsetmonitor!(d::AbstractDependent, monitor::Vector{Int})\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : vector of element-wise indices of elements to monitor.\n\n\n\n\n\nsetmonitor!(d::AbstractTreeStochastic, monitor::Bool)\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : boolean indicating whether all elements are monitored.\n\n\n\n\n\nsetmonitor!(d::AbstractTreeStochastic, monitor::Vector{Int})\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : vector of element-wise indices of elements to monitor.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.update!","page":"Model","title":"Main.MCPhylo.update!","text":"update!(l::AbstractLogical, m::Model)\n\nUpdate the values of a logical node according to its relationship with others in a model.\n\nReturns the node with its values updated.\n\nl : logical node to update.\nm : model containing the node.\n\n\n\n\n\nupdate!(s::AbstractStochastic, m::Model)\n\nUpdate the values of a stochastic node according to its relationship with others in a model.\n\nReturns the node with its values updated.\n\ns : stochastic node to update.\nm : model containing the node.\n\n\n\n\n\nupdate!(m::Model, block::Integer=0)\n\n\n\n\n\nupdate!(m::Model, nodekeys::Vector{Symbol})\n\nUpdate values of logical and stochastic model node according to their relationship with others in a model.\n\nReturns the model with updated nodes.\n\nm : mode with nodes to be updated.\nblock : sampling block of nodes to be updated (default: all blocks).\nnodekeys : nodes to be updated in the given order.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Graph","page":"Model","title":"Graph","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Main.MCPhylo.draw\r\nMain.MCPhylo.graph2dot","category":"page"},{"location":"model.html#Main.MCPhylo.draw","page":"Model","title":"Main.MCPhylo.draw","text":"draw(m::Model; filename::AbstractString=\"\")\n\nDraw a GraphViz DOT-formatted graph representation of model nodes and their relationships.\n\nThe model drawn to an external file or standard output. Stochastic, logical, and input nodes will be represented by ellipses, diamonds, and rectangles, respectively. Nodes that are unmonitored in MCMC simulations will be gray-colored.\n\nm : model for which to construct a graph.\nfilename : external file to which to save the resulting graph, or an empty string to draw to standard output (default). If a supplied external file name does not include a dot (.), the file extension .dot will be appended automatically.\n\n\n\n\n\ndraw(p::Array{T}; fmt::Symbol=:svg, filename::String=\"\", nrow::Integer=3,\n     ncol::Integer=2, byrow::Bool=false, ask::Bool=true) where T<:Plots.Plot\n\n–- INTERNAL –- Helper function for the plot functions. Displays plots and - if wanted - saves them to a file.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.graph2dot","page":"Model","title":"Main.MCPhylo.graph2dot","text":"graph2dot(m::Model)\n\nDraw a GraphViz DOT-formatted graph representation of model nodes and their relationships.\n\nA character string representation of the graph suitable for in-line processing. Stochastic, logical, and input nodes will be represented by ellipses, diamonds, and rectangles, respectively. Nodes that are unmonitored in MCMC simulations will be gray-colored.\n\nm : model for which to construct a graph.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Initialization","page":"Model","title":"Initialization","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Modules = [MCPhylo]\r\nPages   = [\"initialization.jl\"]\r\nFilter =","category":"page"},{"location":"model.html#Main.MCPhylo.setinits!-Tuple{Model,Array{V,1} where V<:(Dict{Symbol,V} where V)}","page":"Model","title":"Main.MCPhylo.setinits!","text":"setinits!(m::Model, inits::Vector{V} where V<:Dict{Symbol})\n\n\n\n\n\n","category":"method"},{"location":"model.html#Main.MCPhylo.setinits!-Tuple{Model,Dict{Symbol,V} where V}","page":"Model","title":"Main.MCPhylo.setinits!","text":"setinits!(m::Model, inits::Dict{Symbol})\n\nSet the initial values of stochastic model nodes.\n\nReturns the model with stochastic nodes initialized and the iter field set equal to 0.\n\nm : model with nodes to be initialized.\ninits : initial values for stochastic model nodes. Dictionary keys and values should be given for each stochastic node.\n\n\n\n\n\n","category":"method"},{"location":"model.html#Main.MCPhylo.setinputs!-Tuple{Model,Dict{Symbol,V} where V}","page":"Model","title":"Main.MCPhylo.setinputs!","text":"setinputs!(m::Model, inputs::Dict{Symbol})\n\nSet the values of input model nodes.\n\nm : model with input nodes to be assigned.\ninputs : values for input model nodes. Dictionary keys and values should be given for each input node.\n\nReturns the model with values assigned to input nodes.\n\n\n\n\n\n","category":"method"},{"location":"model.html#Main.MCPhylo.setsamplers!-Tuple{Model,Array{V,1} where V<:Sampler}","page":"Model","title":"Main.MCPhylo.setsamplers!","text":"function setsamplers!(m::Model, samplers::Vector{V} where V<:Sampler)\n\nSet the samplers for the Stocastic nodes of a given Model.\n\nReturns the Model with updated samplers.\n\nm : Model to update.\nsamplers : block-specific sampelrs.\n\n\n\n\n\n","category":"method"},{"location":"model.html#MCMC","page":"Model","title":"MCMC","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Main.MCPhylo.mcmc","category":"page"},{"location":"model.html#Main.MCPhylo.mcmc","page":"Model","title":"Main.MCPhylo.mcmc","text":"mcmc(mc::ModelChains, iters::Integer; verbose::Bool=true, trees::Bool=false)\n\nThis function simulates additional draws from a model.\n\nmc is the results of a previous call to the mcmc function.\niters indicates the number of draws to simulate.\nverbose controls whether to print porgress statements to the console.\ntrees indicates if the states of the model nodes describing tree structures should be stored as well.\n\n\n\n\n\nmcmc(m::Model, inputs::Dict{Symbol},\n          inits::Vector{V} where V<:Dict{Symbol},\n          iters::Integer; burnin::Integer=0, thin::Integer=1,\n          chains::Integer=1, verbose::Bool=true, trees::Bool=false)\n\nSimulate MCMC draws from the model m.\n\ninputs is a dictionary storing the values for input model nodes. Dictionary keys and values should be given for each input node.\ninits contains dictionaries with initial values for stochastic model nodes. Dictionary keys and values should be given for each stochastic node. Consecutive runs of the simulator will iterate through the vector’s dictionary elements.\niter Specifies the number of draws to generate for each simulation run\nburnin specifies the number of initial draws to discard as a burn-in sequence to allow for convergence.\nthin is the step-size between draws to store in the output.\nchains specifies the number of simulation runs to perform.\nverbose indicates whether the sampler progress should be printed at the console.\ntrees indicates if the states of the model nodes describing tree structures should be stored as well.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Model-2","page":"Model","title":"Model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Main.MCPhylo.Model\r\nMain.MCPhylo.Base.keys\r\nMain.MCPhylo.Base.show\r\nMain.MCPhylo.showall","category":"page"},{"location":"model.html#Main.MCPhylo.Model","page":"Model","title":"Main.MCPhylo.Model","text":"Model(; iter::Integer=0, burnin::Integer=0,\n  samplers::Vector{Sampler}=Sampler[], nodes...)\n\nConstruct a Model object that defines a model for MCMC simulation.\n\nReturns a Model type object.\n\niter: current iteration of the MCMC simulation.\nburnin: number of initial draws to be discarded as a burn-in sequence to allow for convergence.\nsamplers: block-specific sampling functions.\nnodes...: arbitrary number of user-specified arguments defining logical and stochastic nodes in the model. Argument values must be Logical or Stochastic type objects. Their names in the model will be taken from the argument names.\n\n\n\n\n\n","category":"type"},{"location":"model.html#Base.keys","page":"Model","title":"Base.keys","text":"Base.keys(m::Model, ntype::Symbol, at...)\n\nExtract the symbols (keys) for all existing nodes or for nodes of a specified type.\n\nm : model containing the nodes of interest.\nntype : type of nodes to return. Options are\n:all : all input, logical, and stochastic model nodes.\n:assigned : nodes that have been assigned values.\n:block : stochastic nodes being updated by the sampling block(s) at::Integer=0 (default: all blocks).\n:dependent : logical and stochastic (dependent) nodes in topologically sorted order.\n:independent or :input : input (independent) nodes.\n:logical : logical nodes.\n:monitor : stochastic nodes being monitored in MCMC sampler output.\n:output : stochastic nodes upon which no other stochastic nodes depend.\n:source : nodes upon which the node at::Symbol or vector of nodes at::Vector{Symbol} depends.\n:stochastic : stochastic nodes.\n:target : topologically sorted nodes that depend on the sampling block(s) at::Integer=0 (default: all blocks), node at::Symbol , or vector of nodes at::Vector{Symbol} .\nat... : additional positional arguments to be passed to the ntype options, as described above.\n\n\n\n\n\nBase.keys(c::AbstractChains)\n\nReturns names of parameter elements.\n\nc : Chain to return names of.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Base.show","page":"Model","title":"Base.show","text":"Base.show(io::IO, m::Model)\n\nWrite a text representation of the model, nodes, and attributes to the current output stream.\n\n\n\n\n\nBase.show(io::IO, c::AbstractChains)\n\nPrints header and values of Chain.\n\nio : IO stream on which to print.\nAbstractChains : Chain to print.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.showall","page":"Model","title":"Main.MCPhylo.showall","text":"showall(io::IO, m::Model)\n\nWrite a verbose text representation of the model, nodes, and attributes to the current output stream.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Simulation","page":"Model","title":"Simulation","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Main.MCPhylo.gettune\r\nMain.MCPhylo.settune!\r\n\r\nMain.MCPhylo.gradlogpdf\r\nMain.MCPhylo.gradlogpdf!\r\nMain.MCPhylo.logpdf\r\nMain.MCPhylo.logpdf!\r\nMain.MCPhylo.sample!(::Main.MCPhylo.Model, ::Integer)\r\nMain.MCPhylo.unlist\r\nMain.MCPhylo.relist\r\nMain.MCPhylo.relist!\r\nMain.MCPhylo.update!","category":"page"},{"location":"model.html#Main.MCPhylo.gettune","page":"Model","title":"Main.MCPhylo.gettune","text":"gettune(m::Model, block::Integer)\n\n\n\n\n\ngettune(m::Model)\n\nGet block-sampler tuning parameters.\n\nReturns a Vector{Any} of all block-specific tuning parameters without block input, and turning parameters for the specified block otherwise.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.settune!","page":"Model","title":"Main.MCPhylo.settune!","text":"settune!(m::Model, tune, block::Integer)\n\n\n\n\n\nsettune!(m::Model, tune::Vector{Any})\n\nSet tuning parameters for one or all blocks.\n\nAssigns desired tune values to model.\n\nm : model containing the nodes of interest.\ntune : tune values to be assigned to models; if no block value is input, tune must be a Vector with length equal to m.samplers.\nblock : Integer denoting which block's tune value is to be reassigned.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Distributions.gradlogpdf","page":"Model","title":"Distributions.gradlogpdf","text":"gradlogpdf(m::Model, block::Integer=0, transform::Bool=false;\n                dtype::Symbol=:forward)\n\n\n\n\n\ngradlogpdf(m::Model, targets::Array{Symbol, 1})::Tuple{Float64, Array{Float64}}\n\nCompute the gradient of log-densities for stochastic nodes.\n\nReturns the resulting gradient vector. Method gradlogpdf!() additionally updates model m with supplied values x.\n\nm : model containing the stochastic nodes for which to compute the gradient.\nblock : sampling block of stochastic nodes for which to compute the gradient (default: all stochastic nodes).\nx: value (possibly different than the current one) at which to compute the gradient.\ntransform: whether to compute the gradient of block parameters on the link–transformed scale.\ndtype : type of differentiation for gradient calculations. Options are\n:central : central differencing.\n:forward : forward differencing.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.gradlogpdf!","page":"Model","title":"Main.MCPhylo.gradlogpdf!","text":"gradlogpdf!(m::Model, x::AbstractVector{T}, block::Integer=0,\n                  transform::Bool=false; dtype::Symbol=:forward) where {T<:Real}\n\n\n\n\n\ngradlogpdf!(m::Model, x::AbstractArray{T}, block::Integer=0,transform::Bool=false)\n where T<:GeneralNode\n\n\n\n\n\ngradlogpdf!(m::Model, x::N, block::Integer=0,transform::Bool=false)::Tuple{Float64, Vector{Float64}}\n    where N<:GeneralNode\n\nReturns the resulting gradient vector. Method gradlogpdf!() additionally updates model m with supplied values x.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Distributions.logpdf","page":"Model","title":"Distributions.logpdf","text":"logpdf(m::Model, block::Integer=0, transform::Bool=false)\n\n\n\n\n\nlogpdf(m::Model, nodekeys::Vector{Symbol}, transform::Bool=false)\n\nCompute the sum of log-densities for stochastic nodes.\n\nReturns the resulting numeric value of summed log-densities.\n\nm: model containing the stochastic nodes for which to evaluate log-densities.\nblock : sampling block of stochastic nodes over which to sum densities (default: all stochastic nodes).\nnodekeys : nodes over which to sum densities.\nx : value (possibly different than the current one) at which to evaluate densities.\ntransform : whether to evaluate evaluate log-densities of block parameters on the link–transformed scale.\n\n\n\n\n\nlogpdf(mc::ModelChains, f::Function, nodekeys::Vector{Symbol})\n\nCompute the sum of log-densities at each iteration of MCMC output for stochastic nodes.\n\nReturns a ModelChains object of resulting summed log-densities at each MCMC iteration of the supplied chain.\n\nmc : sampler output from a model fit with the mcmc()` function.\nnodekey/nodekeys : stochastic model node(s) over which to sum densities (default: all).\nf : ??\n\n\n\n\n\nlogpdf(mc::ModelChains,\n        nodekeys::Vector{Symbol}=keys(mc.model, :stochastic))\n\n\n\n\n\n","category":"function"},{"location":"model.html#Distributions.logpdf!","page":"Model","title":"Distributions.logpdf!","text":"logpdf!(m::Model, x::N, block::Integer=0,\n          transform::Bool=false) where N<:GeneralNode\n\n\n\n\n\nlogpdf!(m::Model, x::AbstractArray{T}, block::Integer=0,\n              transform::Bool=false) where {T<:Real}\n\nCompute the sum of log-densities for stochastic nodes.\n\nThe resulting numeric value of summed log-densities. Method logpdf!() additionally updates model m with supplied values x.\n\n\n\n\n\n","category":"function"},{"location":"model.html#StatsBase.sample!-Tuple{Model,Integer}","page":"Model","title":"StatsBase.sample!","text":"sample!(m::Model, block::Integer=0)\n\nGenerate one MCMC sample of values for a specified model.\n\nReturns the model updated with the MCMC sample and, in the case of block=0, the iter field incremented by 1.\n\nm : model specification.\nblock : block for which to sample values (default: all blocks).\n\n\n\n\n\n","category":"method"},{"location":"model.html#Main.MCPhylo.unlist","page":"Model","title":"Main.MCPhylo.unlist","text":"unlist(m::Model, block::Integer=0, transform::Bool=false)\n\n\n\n\n\nunlist(m::Model, monitoronly::Bool)\n\n\n\n\n\nunlist(m::Model, nodekeys::Vector{Symbol}, transform::Bool=false)\n\nConvert (unlist) sets of logical and/or stochastic node values to vectors.\n\nReturns vectors of concatenated node values.\n\nm : model containing nodes to be unlisted or relisted.\nblock : sampling block of nodes to be listed (default: all blocks).\nnodekeys : node(s) to be listed.\ntransform : whether to apply a link transformation in the conversion.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.relist","page":"Model","title":"Main.MCPhylo.relist","text":"relist(m::Model, x::AbstractArray{T}, block::Integer=0,\n        transform::Bool=false) where {T<:Real}\n\n\n\n\n\nrelist(m::Model, x::AbstractArray{T}, block::Integer=0,\n        transform::Bool=false) where {T<:GeneralNode}\n\n\n\n\n\nrelist(m::Model, x::AbstractArray{T},\n        nodekeys::Vector{Symbol}, transform::Bool=false) where {T<:Any}\n\n\n\n\n\nrelist(m::Model, x::N, nodekeys::Vector{Symbol}, transform::Bool=false) where N<:GeneralNode\n\nReverse of unlist; ie. Converts vectors to sets of logical and/or stochastic node values. Same inputs and return values as unlist.\n\n\n\n\n\n","category":"function"},{"location":"model.html#Main.MCPhylo.relist!","page":"Model","title":"Main.MCPhylo.relist!","text":"relist!(m::Model, x::AbstractArray{T}, block::Integer=0,\n          transform::Bool=false) where {T<:Any}\n\n\n\n\n\nrelist!(m::Model, x::AbstractArray{T}, nodekey::Symbol,\n              transform::Bool=false) where {T<:Real}\n\nReverse of unlist; ie. Converts vectors to sets of logical and/or stochastic node values. Same inputs as unlist.\n\nReturns m, with values copied to the nodes.\n\n\n\n\n\n","category":"function"},{"location":"likelihood.html#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"likelihood.html","page":"Likelihood","title":"Likelihood","text":"There are several prior distributions for tree structures implemented in this package. Also there is a function which calculates the likelihood of a tree given a model using Felsensteins algorithm.","category":"page"},{"location":"likelihood.html#Likelihood-Calculator-functionality","page":"Likelihood","title":"Likelihood Calculator functionality","text":"","category":"section"},{"location":"likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Likelihood/LikelihoodCalculator_Node.jl\"]\r\nFilter =","category":"page"},{"location":"likelihood.html#Main.MCPhylo.FelsensteinFunction-Union{Tuple{N}, Tuple{Array{N,1},Array{Float64,N} where N,Float64,Array{Float64,3},Int64,Array{Float64,1}}} where N<:GeneralNode","page":"Likelihood","title":"Main.MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(tree_postorder::Vector{N}, pi_::T, rates::Vector{Float64}, data::Array{Float64,3}, n_c::Int64, blv::Vector{Float64}) where {T<:Real, N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm. The function is written such that it is differentiable by Zygote 0.5.3.\n\nReturns log-likelihood as a Real number.\n\ntree_postorder : Vector of Nodes.\npi : Real number used in calculation.\nrates : Vector of Floats, used in calculation.\ndata : Array of Floats, currently a placeholder.\nn_c : Int64, nchar value derived from tree and dataset.\nblv : Vector of Floats, branchlength vector derived from tree.\n\n\n\n\n\n","category":"method"},{"location":"likelihood.html#Main.MCPhylo.FelsensteinFunction-Union{Tuple{N}, Tuple{M}, Tuple{Array{N,1},Array{Float64,N} where N,Array{Float64,N} where N,Array{M,2},Array{M,N} where N,Array{M,2},Float64,Array{Float64,4}}, Tuple{Array{N,1},Array{Float64,N} where N,Array{Float64,N} where N,Array{M,2},Array{M,N} where N,Array{M,2},Float64,Array{Float64,4},Bool}} where M<:Number where N<:GeneralNode","page":"Likelihood","title":"Main.MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(tree_postorder::Vector{N}, pi_::Array{Float64}, rates::Array{Float64},\n                     U::Array{Float64,2}, D::Array{Float64}, Uinv::Array{Float64,2},\n                     data::Array{Float64,4}, c_grad::Bool = true) where {N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm. If c_grad equals true (default) the analytic gradient regarding the branch lengths of the tree gets computed as well.\n\n\n\n\n\n","category":"method"},{"location":"likelihood.html#Prior","page":"Likelihood","title":"Prior","text":"","category":"section"},{"location":"likelihood.html","page":"Likelihood","title":"Likelihood","text":"Main.MCPhylo.CompoundDirichlet\r\nMain.MCPhylo.exponentialBL","category":"page"},{"location":"likelihood.html#Main.MCPhylo.CompoundDirichlet","page":"Likelihood","title":"Main.MCPhylo.CompoundDirichlet","text":"CompoundDirichlet(alpha::Float64, a::Float64, beta::Float64, c::Float64, nterm::Float64)\n\nThis structure implememts the CompoundDirichlet distribution described in Zhang, Rannala and Yang 2012. (DOI:10.1093/sysbio/sys030)\n\n\n\n\n\n","category":"type"},{"location":"likelihood.html#Main.MCPhylo.exponentialBL","page":"Likelihood","title":"Main.MCPhylo.exponentialBL","text":"exponentialBL(scale::Float64) <: ContinuousUnivariateDistribution\n\nThis structure implememts an exponential prior on the branch lengths of a tree.\n\n\n\n\n\n","category":"type"},{"location":"samplers.html#samplers","page":"Samplers","title":"samplers","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Functions found in all files of samplers folder, ordered according to file of origin.","category":"page"},{"location":"samplers.html#abc","page":"Samplers","title":"abc","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.ABC","category":"page"},{"location":"samplers.html#Main.MCPhylo.ABC","page":"Samplers","title":"Main.MCPhylo.ABC","text":"          ABC(params::ElementOrVector{Symbol},\n\n          scale::ElementOrVector{T}, summary::Function,\n\n          epsilon::Real; kernel::KernelDensityType=SymUniform,\n\n          dist::Function=(Tsim, Tobs) -> sqrt(sum(abs2, Tsim - Tobs)),\n\n          proposal::SymDistributionType=Normal, maxdraw::Integer=1,\n\n          nsim::Integer=1, decay::Real=1.0, randeps::Bool=false,\n\n          args...) where {T<:Real}\n\nConstruct a Sampler object for ABC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{ABCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nscale : scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution.  Values are relative to the unconstrained parameter space, where candidate draws are generated.\nsummary : function that takes a vector of observed or simulated data and returns a summary statistic or vector of statistics.\nepsilon : target tolerance for determining how similar observed and simulated data summary statistics need to be in order to accept a candidate draw.\nkernel : weighting kernel density of type Biweight, Cosine, Epanechnikov, Normal, SymTriangularDist, SymUniform, or Triweight to use in measuring similarity between observed and simulated data summary statistics.  Specified epsilon determines the standard deviation of Normal kernels and widths of the others.\ndist : positive function for the kernel density to compute distance between vectors of observed (Tobs) and simulated (Tsim) data summary statistics (default: Euclidean distance).\nproposal : symmetric distribution of type Biweight, Cosine, Epanechnikov, Normal, SymTriangularDist, SymUniform, or Triweight to be centered around current parameter values and used to generate proposal draws.  Specified scale determines the standard deviations of Normal proposals and widths of the others.\nmaxdraw : maximum number of unaccepted candidates to draw in each call of the sampler.  Draws are generated until one is accepted or the maximum is reached.  Larger values increase acceptance rates at the expense of longer runtimes.\nnsim : number of data sets to simulate in deciding whether to accept a candidate draw.  Larger values lead to closer approximations of the target distribution at the expense of longer runtimes.\ndecay : if 0 < decay <= 1, the rate at which internal tolerances are monotonically decreased from the initial distance between observed and simulated summary statistics toward the maximum of each subsequent distance and epsilon; if decay = 0, internal tolerances are fixed at epsilon.\nrandeps : whether to perturb internal tolerances by random exponential variates.\nargs... : additional keyword arguments to be passed to the dist function.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#amm","page":"Samplers","title":"amm","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.AMM","category":"page"},{"location":"samplers.html#Main.MCPhylo.AMM","page":"Samplers","title":"Main.MCPhylo.AMM","text":"AMM(params::ElementOrVector{Symbol}, Sigma::Matrix{T};\n    adapt::Symbol=:all, args...) where {T<:Real}\n\nConstruct a Sampler object for AMM sampling. Parameters are assumed to be  continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{AMMTune} type object.\n\nparams : stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nSigma : covariance matrix for the non-adaptive multivariate normal proposal distribution.  The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated.\nadapt : type of adaptation phase.  Options are\n:all : adapt proposal during all iterations.\n:burnin : adapt proposal during burn-in iterations.\n:none : no adaptation (multivariate Metropolis sampling with fixed proposal).\nargs... : additional keyword arguments to be passed to the AMMVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#amwg","page":"Samplers","title":"amwg","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.AMWG","category":"page"},{"location":"samplers.html#Main.MCPhylo.AMWG","page":"Samplers","title":"Main.MCPhylo.AMWG","text":"AMWG(params::ElementOrVector{Symbol},\n\nsigma::ElementOrVector{T};\n\nadapt::Symbol=:all,\n\nargs...) where {T<:Real}\n\nConstruct a Sampler object for AMWG sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{ABCTune} type object.\n\nparams:  stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nsigma: scaling value or vector of the same length as the combined elements of nodes\nparams, defining initial standard deviations for univariate normal proposal distributions. Standard deviations are relative to the unconstrained parameter space, where candidate draws are generated.\nadapt : type of adaptation phase.  Options are\n:all : adapt proposal during all iterations.\n:burnin : adapt proposal during burn-in iterations.\n:none : no adaptation (Metropolis-within-Gibbs sampling with fixed proposal).\nargs...: additional keyword arguments to be passed to the AMWGVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bhmc","page":"Samplers","title":"bhmc","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BHMC","category":"page"},{"location":"samplers.html#Main.MCPhylo.BHMC","page":"Samplers","title":"Main.MCPhylo.BHMC","text":"BHMC(params::ElementOrVector{Symbol}, traveltime::Real)\n\nConstruct a Sampler object for BHMC sampling. Parameters are assumed to   have binary numerical values (0 or 1).\n\nReturns a Sampler{BHMCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\ntraveltime: length of time over which particle paths are simulated. It is recommended that supplied values be of the form (n + frac12) pi, where optimal choices of n in mathbbZ^+ are expected to grow with the parameter space dimensionality.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bia","page":"Samplers","title":"bia","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BIA","category":"page"},{"location":"samplers.html#Main.MCPhylo.BIA","page":"Samplers","title":"Main.MCPhylo.BIA","text":"BIA(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for BIA sampling. Parameters are assumed to have    binary numerical values (0 or 1).\n\nReturns a Sampler{BIATune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the BIAVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bmc3","page":"Samplers","title":"bmc3","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BMC3","category":"page"},{"location":"samplers.html#Main.MCPhylo.BMC3","page":"Samplers","title":"Main.MCPhylo.BMC3","text":"BMC3(params::ElementOrVector{Symbol}; k::F=1) where {F<:BMC3Form}\n\nConstruct a Sampler object for BMC3 sampling. Parameters are assumed to have binary numerical values (0 or 1).\n\nReturns a Sampler{BMC3Tune{typeof(k)}} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nk: number of parameters or vector of parameter indices to select at random for simultaneous updating in each call of the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bmg","page":"Samplers","title":"bmg","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BMG","category":"page"},{"location":"samplers.html#Main.MCPhylo.BMG","page":"Samplers","title":"Main.MCPhylo.BMG","text":"BMG(params::ElementOrVector{Symbol}; k::F=1) where {F<:BMGForm}\n\nConstruct a Sampler object for BMG sampling. Parameters are assumed to have  binary numerical values (0 or 1).\n\nReturns a Sampler{BMGTune{typeof(k)}} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nk:  number of parameters or vector of parameter indices to select at random for simultaneous updating in each call of the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#dgs","page":"Samplers","title":"dgs","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.DGS","category":"page"},{"location":"samplers.html#Main.MCPhylo.DGS","page":"Samplers","title":"Main.MCPhylo.DGS","text":"DGS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object for which DGS sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to have discrete univariate distributions with finite supports.\n\nReturns a Sampler{DSTune{Function}} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#hmc","page":"Samplers","title":"hmc","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.HMC","category":"page"},{"location":"samplers.html#Main.MCPhylo.HMC","page":"Samplers","title":"Main.MCPhylo.HMC","text":"HMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nepsilon: step size.\nL: number of steps to take in the Leapfrog algorithm.\nSigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.\ndtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.\n\n\n\n\n\nHMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer, Sigma::Matrix{T}; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#mala","page":"Samplers","title":"mala","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.MALA","category":"page"},{"location":"samplers.html#Main.MCPhylo.MALA","page":"Samplers","title":"Main.MCPhylo.MALA","text":"MALA(params::ElementOrVector{Symbol}, epsilon::Real; args...)\n\nConstruct a Sampler object for MALA sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{MALATune}` type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nepsilon: factor by which the drift and covariance matrix of the proposal distribution are scaled.\nSigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.\ndtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.\n\n\n\n\n\nMALA(params::ElementOrVector{Symbol}, epsilon::Real, Sigma::Matrix{T}; args...)\n\nConstruct a Sampler object for MALA sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{MALATune}` type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#miss","page":"Samplers","title":"miss","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.MISS","category":"page"},{"location":"samplers.html#Main.MCPhylo.MISS","page":"Samplers","title":"Main.MCPhylo.MISS","text":"MISS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object to sampling missing output values. The constructor should only be used to sample stochastic nodes upon which no other stochastic node depends. So-called ‘output nodes’ can be identified with the keys() function. Moreover, when the MISS constructor is included in a vector of Sampler objects to define a sampling scheme, it should be positioned at the beginning of the vector. This ensures that missing output values are updated before any other samplers are executed.\n\nReturns a Sampler{Dict{Symbol, MISSTune}} type object.\n\nparams: stochastic node(s) that contain missing values (NaN) to be updated with the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#nuts","page":"Samplers","title":"nuts","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.NUTS","category":"page"},{"location":"samplers.html#Main.MCPhylo.NUTS","page":"Samplers","title":"Main.MCPhylo.NUTS","text":"NUTS(params::ElementOrVector{Symbol}; dtype::Symbol=:forward, args...)\n\nConstruct a Sampler object for NUTS sampling, with the algorithm’s step size parameter adaptively tuned during burn-in iterations. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{NUTSTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\ndtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.\nargs...: additional keyword arguments to be passed to the NUTSVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#P-NUTS","page":"Samplers","title":"P-NUTS","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.PNUTS","category":"page"},{"location":"samplers.html#Main.MCPhylo.PNUTS","page":"Samplers","title":"Main.MCPhylo.PNUTS","text":"PNUTS(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for PNUTS sampling. The Parameter is assumed to be a tree.\n\nReturns a Sampler{PNUTSTune} type object.\n\nparams: stochastic node to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the PNUTSVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#rwm","page":"Samplers","title":"rwm","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.RWM(::Main.MCPhylo.ElementOrVector{Symbol}, ::Main.MCPhylo.ElementOrVector{T}; args...) where {T<:Real}\r\nMain.MCPhylo.RWM(::Main.MCPhylo.ElementOrVector{Symbol}, ::Main.MCPhylo.ElementOrVector{Symbol}; args...)","category":"page"},{"location":"samplers.html#Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{T,1}, T}}} where T<:Real","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol},\n              scale::ElementOrVector{T}; args...) where {T<:Real})\n\nConstruct a Sampler object for RWM sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{RWMTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nscale: scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution. Values are relative to the unconstrained parameter space, where candidate draws are generated.\nargs...: additional keyword arguments to be passed to the RWMVariate constructor.\n\n\n\n\n\n","category":"method"},{"location":"samplers.html#Main.MCPhylo.RWM-Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{Symbol,1}, Symbol}}","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol}, moves::Array{Symbol}; args...)\n\nConstruct the RWM sampler for Trees. If you set moves to :all it will use all eligible moves to change the tree. These are currently: NNI, SPR, Slide, Swing, :EdgeLength\n\nReturns a Sampler{RWMTune} type object.\n\n\n\n\n\n","category":"method"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#slice","page":"Samplers","title":"slice","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.Slice","category":"page"},{"location":"samplers.html#Main.MCPhylo.Slice","page":"Samplers","title":"Main.MCPhylo.Slice","text":"Slice(params::ElementOrVector{Symbol},                 width::ElementOrVector{T},                 ::Type{F}=Multivariate;                 transform::Bool=false) where {T<:Real, F<:SliceForm}\n\nConstruct a Sampler object for Slice sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{SliceTune{Univariate}} or Sampler{SliceTune{Multivariate}} type object if sampling univariately or multivariately, respectively.\n\nparams: stochastic node(s) to be updated with the sampler.\nwidth: scaling value or vector of the same length as the combined elements of nodes params, defining initial widths of a hyperrectangle from which to simulate values.\nF : sampler type. Options are\n:Univariate : sequential univariate sampling of parameters.\n:Multivariate : joint multivariate sampling.\ntransform: whether to sample parameters on the link-transformed scale (unconstrained parameter space). If true, then constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function, and width is interpreted as being relative to the unconstrained parameter space. Otherwise, sampling is relative to the untransformed space.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#slicesimplex","page":"Samplers","title":"slicesimplex","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.SliceSimplex","category":"page"},{"location":"samplers.html#Main.MCPhylo.SliceSimplex","page":"Samplers","title":"Main.MCPhylo.SliceSimplex","text":"SliceSimplex(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for which SliceSimplex sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to be continuous and constrained to a simplex.\n\nReturns a Sampler{SliceSimplexTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the SliceSimplexVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#sampler","page":"Samplers","title":"sampler","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.Sampler","category":"page"},{"location":"samplers.html#Main.MCPhylo.Sampler","page":"Samplers","title":"Main.MCPhylo.Sampler","text":"Sampler(params::Vector{Symbol}, f::Function, tune::Any=Dict())\n\nConstruct a Sampler object that defines a sampling function for a block of stochastic nodes.\n\nReturns a Sampler{typeof(tune)} type object.\n\nparams: node(s) being block-updated by the sampler.\nf: function for the eval field of the constructed sampler and whose arguments are the other model nodes upon which the sampler depends, typed argument model::Model that contains all model nodes, and/or typed argument block::Integer that is an index identifying the corresponding sampling function in a vector of all samplers for the associated model. Through the arguments, all model nodes and fields can be accessed in the body of the function. The function may return an updated sample for the nodes identified in its params field. Such a return value can be a structure of the same type as the node if the block consists of only one node, or a dictionary of node structures with keys equal to the block node symbols if one or more. Alternatively, a value of nothing may be returned. Return values that are not nothing will be used to automatically update the node values and propagate them to dependent nodes. No automatic updating will be done if nothing is returned.\ntune: tuning parameters needed by the sampling function.\n\n\n\n\n\n","category":"type"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"}]
}
