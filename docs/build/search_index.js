var documenterSearchIndex = {"docs":
[{"location":"distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"there are no docstrings in this folder","category":"page"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [MCPhylo]\r\nPages   = [\"distributions/constructors.jl\", \"distributionstruct.jl\", \"extensions.jl\", \"pdmatdistribution.jl\", \"pdmats2.jl\", \"Phylodist.jl\", \"transformdistribution.jl\", \"TreeConstraints.jl\"]","category":"page"},{"location":"Sampler.html#Sampler","page":"Sampler","title":"Sampler","text":"","category":"section"},{"location":"Sampler.html","page":"Sampler","title":"Sampler","text":"Modules = [MCPhylo]\r\nPages   = [\"Sampler/SamplerFunctions.jl\", \"PNUTS.jl\", \"ProbPathHMC.jl\"]","category":"page"},{"location":"Utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"utils.jl\", \"Utils/FileIO.jl\", \"SIMD_Mat.jl\"]","category":"page"},{"location":"Utils.html#Main.MCPhylo.lcp-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractString","page":"Utils","title":"Main.MCPhylo.lcp","text":"lcp(str1::T, str2::T)::T where T <: AbstractString\n\nGet the longest common prefix.\n\n\n\n\n\n","category":"method"},{"location":"output.html#output","page":"Output","title":"output","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"there are no docstrings in this folder","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"output/chains.jl\", \"chainsummary.jl\", \"discretediag.jl\", \"fileio.jl\", \"gelmandiag.jl\", \"gewekediag.jl\", \"heideldiag.jl\", \"mcse.jl\", \"modelchains.jl\", \"modelstats.jl\", \"plot.jl\", \"rafterydiag.jl\", \"stats.jl\"]","category":"page"},{"location":"toc.html","page":"Table of Content","title":"Table of Content","text":"","category":"page"},{"location":"parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser/ParseCSV.jl\", \"ParseNewick.jl\", \"ParseNexus.jl\", \"Parser.jl\"]","category":"page"},{"location":"parser.html#Main.MCPhylo.ParseCSV","page":"Parser","title":"Main.MCPhylo.ParseCSV","text":"ParseCSV(filename::String)\n\nThis function parses a CSV file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes.\n\n\n\n\n\n","category":"function"},{"location":"parser.html#Main.MCPhylo.create_csvdf","page":"Parser","title":"Main.MCPhylo.create_csvdf","text":"function create_csvdf(filecontnt::Array{String}, separator::AbstractString=\",\")::DataFrame\n\nThis function parses a CSV file and returns its content as a DataFrame.\n\nNOTE: May later on be replaced by the respective DataFrames function.\n\n\n\n\n\n","category":"function"},{"location":"parser.html#Main.MCPhylo.ParseNewick-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNewick","text":"ParseNewick(filename::String)\n\nThis is the main function, which parses a file, containing Newick strings.\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Main.MCPhylo.ParseNexus-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNexus","text":"ParseNexus(filename::String)\n\nThis function parses a NEXUS file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes.\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Main.MCPhylo.create_nexusdf-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.create_nexusdf","text":"create_nexusdf(filecontent::Array{String})::DataFrame\n\nThis function creates a DataFrame of the acutal data.\n\n\n\n\n\n","category":"method"},{"location":"parser.html#Main.MCPhylo.extract_meta_info-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.extract_meta_info","text":"extract_meta_info(content::Array{String})\n\nThis function extracts some meta information from the content of the nexus file. It \"eats-up\" the stack\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree-Functionality","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree/Converter.jl\", \"Node_Type.jl\", \"Tree_Basics.jl\", \"Tree_Clustering.jl\", \"Tree_Consensus.jl\", \"Tree_Distance.jl\", \"Tree_Ladderizing.jl\", \"Tree_Legacy.jl\", \"Tree_moves.jl\", \"Tree_Pruning.jl\", \"Tree_Search.jl\", \"Tree_Traversal.jl\"]","category":"page"},{"location":"Tree.html#Main.MCPhylo.from_df-Tuple{DataFrames.DataFrame}","page":"Tree Functionality","title":"Main.MCPhylo.from_df","text":"from_df(df::DataFrame)::Node\n\nThis function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T,AbstractString}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.newick","text":"newick(root::T, newickstring::AbstractString) where T<:GeneralNode\n\nDo the newick recursion. It is meant as the internal iterator function.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.newick","text":"newick(node::Node)::String\n\nCreates a newick represnetation of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,1}}} where T<:Real where N<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance","text":"to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N<:GeneralNode,T<: Real}\n\nCalcualte the variance-covariance matrix from tree. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_covariance_ultra-Union{Tuple{N}, Tuple{T}, Tuple{N}} where N<:Main.MCPhylo.GeneralNode where T<:Real","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance_ultra","text":"to_covariance_ultra(tree::Node)::Array{T,2} where T<: Real\n\nGet the covariance matrix of the ultrametric version of tree with height 1.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_df-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}","page":"Tree Functionality","title":"Main.MCPhylo.to_df","text":"to_df(root::Node)::DataFrame\n\nThis function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry df[i,j] is the length of the edge connecting node i with node j.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_distance_matrix-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.to_distance_matrix","text":"to_distance_matrix(tree::T)::Array{Float64,2} where T <:GeneralNode\n\nCalculate the distance matrix over the set of leaves.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.add_child!","page":"Tree Functionality","title":"Main.MCPhylo.add_child!","text":"add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)\n\nThis function adds a child to the mother node. The arity of the mother node is increased by 1 and the root status of the child is set to False.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.check_binary-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}","page":"Tree Functionality","title":"Main.MCPhylo.check_binary","text":"check_binary(root::Node)::Bool\nchecks to see if given tree is binary; returns true if properly formatted and false otherwise\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.create_tree_from_leaves","page":"Tree Functionality","title":"Main.MCPhylo.create_tree_from_leaves","text":"create_tree_from_leaves(leaf_nodes::Vector{T})::Node\n\nThis function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.create_tree_from_leaves_bin-Tuple{Array{String,1},Int64}","page":"Tree Functionality","title":"Main.MCPhylo.create_tree_from_leaves_bin","text":"create_tree_from_leaves(leaf_nodes::Vector{T})::Node\n\nThis function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.delete_node!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.delete_node!","text":"delete_node!(node::Node)::Nothing\n\nThis functions deletes node from a tree and assigns all its children to its mother node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.force_ultrametric!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.force_ultrametric!","text":"force_ultrametric!(root::T) where T<:GeneralNode\n\nForce an ultrametric version of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Tuple{Main.MCPhylo.TreeStochastic}","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(t::TreeStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{N}, Tuple{N}} where N<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(root::N)::Vector{T}  where {N <:GeneralNode, T<:Real}\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,1}}} where T<:Real where N<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(root::N, out_vec::Vector{T}) where {N<:GeneralNode, T<:Real}\n\nDo post order traversal to retrieve a vector of branch lengths.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_mother-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_mother","text":"function get_mother(node::T)::T  where T<:GeneralNode\n\nThis function gets the mother of node. It does so by looking for the respective binary representation of the mother node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_sister-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_sister","text":"get_sister(node::T)::T  where T<:GeneralNode\n\nThis function gets the sister of node. It does so by looking for the respective binary representation of the sister.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_sum_seperate_length!-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_sum_seperate_length!","text":"get_sum_seperate_length!(root::Node)::Vector{Float64}\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_sum_seperate_length!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_sum_seperate_length!","text":"get_sum_seperate_length!(root::Node)::Vector{Float64}\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.insert_node!-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.insert_node!","text":"insert_node!(mother::Node, children::Vector{T})::T where T<:AbstractNode\n\nThis function inserts a node into a tree after a mother node and gains a subset of the mother's children as its children. Returns the inserted node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.node_height-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.node_height","text":"node_height(root::T, mv::Float64)::Float64  where T<:GeneralNode\n\nCalculate the height of a node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.number_nodes!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.number_nodes!","text":"number_nodes!(root::T)::Nothing  where T<:GeneralNode\n\nThis function assigns a unique, sequential number to each node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.path_length-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.path_length","text":"path_length(ancestor::T, descendant::T)::Float64  where T<:GeneralNode\n\nNote: The function assumes there is an ancestral relationship between the two nodes.\n\nThis function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.random_node-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.random_node","text":"function random_node(root::T)::T  where T<:GeneralNode\n\nThis function returns a random node from the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.remove_child!-Union{Tuple{N}, Tuple{N,Bool}} where N<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.remove_child!","text":"remove_child!(mother_node::Node, left::Bool)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. The removed node is returned.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.remove_child!-Union{Tuple{N}, Tuple{N,N}} where N<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.remove_child!","text":"remove_child!(mother_node::Node, child::Node)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. The removed node is returned.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.set_binary!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.set_binary!","text":"set_binary!(root::Node)\n\nAssign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.set_branchlength_vector!-Tuple{Main.MCPhylo.TreeStochastic,Main.MCPhylo.ArrayStochastic}","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T <: Real\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.set_branchlength_vector!-Union{Tuple{T}, Tuple{Main.MCPhylo.TreeStochastic,Array{T,N} where N}} where T<:Real","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T <: Real\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.set_branchlength_vector!-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,N} where N}} where T<:Real where N<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(root::N, blenvec::Array{T}) where {N<:GeneralNode, T<:Real}\n\nThis function sets the branch lengths of a tree to the values specified in blenvec.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.tree_height-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_height","text":"tree_height(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree height.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T,Float64}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_length","text":"tree_length(root::T, tl::Float64)::Float64 where T<:GeneralNode\n\nThis function does the internal tree length recursion\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_length","text":"tree_length(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree length.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.neighbor_joining-Tuple{Array{Float64,2},Array{String,1}}","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining","text":"neighbor_joining(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.neighbor_joining-Tuple{Array{Float64,2}}","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining","text":"neighbor_joining(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.neighbor_joining_int-Tuple{Array{Float64,2},Array{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool},1}}","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining_int","text":"neighbor_joining_int(dm::Array{Float64,2},leaves::Vector{Node})\n\nInternal function that is called by both neighbor_joining methods. Contains the actual neighbor-joining algorithm, i.e. builds a phylogenetic tree from the given distance matrix and array of leaves. Returns a node of that tree, from which it can be traversed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.upgma-Tuple{Array{Float64,2},Array{String,1}}","page":"Tree Functionality","title":"Main.MCPhylo.upgma","text":"upgma(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.upgma-Tuple{Array{Float64,2}}","page":"Tree Functionality","title":"Main.MCPhylo.upgma","text":"upgma(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.upgma_int-Tuple{Array{Float64,2},Array{Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool},Float64,Int64},1}}","page":"Tree Functionality","title":"Main.MCPhylo.upgma_int","text":"upgma_int(dm::Array{Float64,2},leaves::Vector{Node})\n\nInternal function that is called by both UPGMA methods. Contains the actual UPGMA algorithm, i.e. builds a phylogenetic tree from the given distance matrix and array of leaves. Returns a node of that tree, from which it can be traversed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.find_common_clusters","text":"find_common_clusters(ref_tree, tree:T)\n    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}\n\nUse Day's algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.majority_consensus_tree","text":"majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T<:AbstractNode\n\nConstruct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.max_leaf_rank","text":"max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T<:AbstractNode\n\nRecursive helper function to find the highest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.merge_trees!","text":"merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T<:AbstractNode\n\nMerge two compatible trees, i.e. inserts all cluster of the first tree, which aren't already in the second tree, into the secon tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.min_leaf_rank","text":"min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T <: AbstractNode\n\nRecursive helper function to find the lowest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.one_way_compatible","text":"one_way_compatible(ref_tree::T, tree::T)::T where T<:AbstractNode\n\nTakes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.order_tree!","text":"order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())\n    ::Vector{T} where T<:AbstractNode\n\nHelper function to order a tree based on cluster indeces and return the leaves of the ordered tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_left","text":"x_left(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_right","text":"x_right(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.BHV_bounds","text":"BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T <:GeneralNode\n\nThis function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.RF","text":"RF(tree1::T, tree2::T)::Int64 where T <:GeneralNode\n\nCalculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_bipartitions","text":"get_bipartitions(tree::T)::Vector{Tuple} where T <:GeneralNode\n\nGet a vector of all bipartions of tree. The resulting vector contains Tuples of sets representing the bipartions.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree!","text":"ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T<:AbstractNode)\n\nThis function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree","text":"ladderize_tree(root::T, ascending::Bool=true)::T where T<:AbstractNode)\n\nThis function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T,Int64}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI!(root::T, target::Int64)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T,T,Bool}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI(root::T, target::T, lor::Bool)::Int64   where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The parameter target specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used lor=true. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI!(root::T)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.NNI-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.NNI","text":"NNI(root::T)::T  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root and returns a mutated copy while leaving the original tree intact.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.change_edge_length!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.change_edge_length!","text":"change_edge_length!(root::T) where T <:GeneralNode\n\nPick a random node and increase or decrease its length randomly.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.move!-Union{Tuple{T}, Tuple{T,T,Float64}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.move!","text":"move!(node1::Node, node2::Node, proportion::Float64)\n\nChange the incomming length of node1 and node2 while keeping there combined length constant.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.perform_spr-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}","page":"Tree Functionality","title":"Main.MCPhylo.perform_spr","text":"perform_spr(root::Node)\n\nperforms SPR on binary tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.randomize!-Union{Tuple{T}, Tuple{T}, Tuple{T,Int64}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.randomize!","text":"randomize!(root::Node, num::Int64=100)::nothing\n\nThis function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.risky_SPR!-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR!","text":"    risky_SPR!(root::Node)::AbstractNode\nPerforms SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not\nReturns reference to root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.risky_SPR-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR","text":"    risky_SPR(root::Node)::AbstractNode\nPerforms SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not\nReturns copy of root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.slide!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.slide!","text":"slide!(root::T) where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.slide-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.slide","text":"slide(root::T)::T where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters. The new tree is returned.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.swing!-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.swing!","text":"swing!(root::T) where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.swing-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.swing","text":"swing(root::T)::T where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children. The new tree is returned.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.prune_tree!-Union{Tuple{T}, Tuple{T,Array{String,1}}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree!","text":"prune_tree!(root::T, node_names::Vector{String})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.prune_tree!-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree!","text":"prune_tree!(root::T, node_names::Vector{T})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.prune_tree-Union{Tuple{T}, Tuple{T,Array{String,1}}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree","text":"prune_tree(root::T, node_names::Vector{String})::T where T<:AbstractNode\n\nThis function returns a copy of a tree with specific nodes including their descendants removed\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.find_binary-Union{Tuple{T}, Tuple{T,String}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.find_binary","text":"find_binary(root::T, bin::String)::T where T<:GeneralNode\n\nFind a node by its binary representation. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure wheter the node is in the tree at all.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.find_num-Union{Tuple{I}, Tuple{T}, Tuple{T,I,Array{T,1}}} where I<:Integer where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.find_num","text":"find_num(root::T, num::Int64, rn::Vector{T})::Bool  where T<:GeneralNode\n\nDo a post order traversal to find the node corresponding to the num.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.find_num-Union{Tuple{I}, Tuple{T}, Tuple{T,I}} where I<:Integer where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.find_num","text":"find_num(root::T, num::Int64)  where T<:GeneralNode\n\nFind a node by its number. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure wheter the node is in the tree at all.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.find_root-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}","page":"Tree Functionality","title":"Main.MCPhylo.find_root","text":"find_root(node::Node)::Node\n\nTakes a node in a tree and finds the root of that tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_leaves-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_leaves","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_leaves-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_leaves","text":"post_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.level_order-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.level_order","text":"level_order(node::T)::Array{T} where T<:GeneralNode\n\nThis function does level order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.level_traverse-Union{Tuple{T}, Tuple{T,Int64,Array{T,N} where N}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.level_traverse","text":"level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T <:GeneralNode\n\nThis function traverses a level of the tree specified through node. The level is specified via the level argument and the nodes visited are stored in the stack. This function is intended as the internal worker for the level_order function.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.post_order-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.post_order","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.post_order-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.post_order","text":"post_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.pre_order-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.pre_order","text":"pre_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a pre order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the pre order traversal.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.pre_order-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.pre_order","text":"pre_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does pre order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"method"},{"location":"model.html#model","page":"Model","title":"model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"there are no docstrings in this folder","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"Modules = [MCPhylo]\r\nPages   = [\"model/dependent.jl\", \"dependent_tree.jl\", \"graph.jl\", \"initialization.jl\", \"mcmc.jl\", \"model.jl\", \"simulation.jl\"]","category":"page"},{"location":"Likelihood.html#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Likelihood/LikelihoodCalculator_Node.jl\", \"Prior.jl\"]","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.FelsensteinFunction-Union{Tuple{N}, Tuple{T}, Tuple{Array{N,1},T,Array{Float64,1},Array{Float64,3},Int64,Array{Float64,1}}} where N<:Main.MCPhylo.GeneralNode where T<:Real","page":"Likelihood","title":"Main.MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(treepostorder::Vector{N}, pi::T, rates::Vector{Float64}, data::Array{Float64,3}, n_c::Int64, blv::Vector{Float64}) where {T<:Real, N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm.\n\nThe function is written such that it is differentiable by Zygote 0.5.3.\n\n\n\n\n\n","category":"method"},{"location":"Likelihood.html#Main.MCPhylo.BirthDeath","page":"Likelihood","title":"Main.MCPhylo.BirthDeath","text":"Strict Molecular Clock - BirthDeath Implemented following Yang & Rannala 1997 doi.org/10.1093/oxfordjournals.molbev.a025811\n\n\n\n\n\n","category":"type"},{"location":"Likelihood.html#Main.MCPhylo.BirthDeathSimplified","page":"Likelihood","title":"Main.MCPhylo.BirthDeathSimplified","text":"Strict Molecular Clock - Simplified Birth Death Implemented folloing Yang & Rannala 1996 doi.org/10.1007/BF02338839\n\n\n\n\n\n","category":"type"},{"location":"samplers.html#samplers","page":"Samplers","title":"samplers","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Modules = [MCPhylo]\r\nPages   = [\"samplers/abc.jl\", \"amm.jl\", \"amwg.jl\", \"bhmc.jl\", \"bia.jl\", \"bmc3.jl\", \"bmg.jl\", \"dgs.jl\", \"hmc.jl\", \"mala.jl\", \"miss.jl\", \"nuts.jl\", \"rwm.jl\", \"rwmc.jl\", \"sampler.jl\", \"slice.jl\", \"slicesimplex.jl\"]","category":"page"},{"location":"samplers.html#Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{Symbol,1}, Symbol}}} where T<:Real","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol}, moves::Array{Symbol}; args...)\n\nConstruct the RWM sampler for Trees. If you set moves to :all it will use all eligible moves to change the tree. These are currently: NNI, Slide, Swing, :EdgeLength\n\n\n\n\n\n","category":"method"},{"location":"Substitution.html#Substitution","page":"Substitution","title":"Substitution","text":"","category":"section"},{"location":"Substitution.html","page":"Substitution","title":"Substitution","text":"Modules = [MCPhylo]\r\nPages   = [\"Substitution/SubstitutionMat.jl\"]","category":"page"},{"location":"Substitution.html#Main.MCPhylo.exponentiate_binary-Tuple{Number,Float64,Float64}","page":"Substitution","title":"Main.MCPhylo.exponentiate_binary","text":"exponentiate_binary(pi::Float64, t::float::64, r::Float64)::Array{Float64,2}\n\nThis function returns the expontiatied matrix for the restriction site model. Following Felsenstein 1981\n\n\n\n\n\n","category":"method"}]
}
