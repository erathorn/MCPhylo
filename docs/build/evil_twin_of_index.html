<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · MCPhylo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCPhylo</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Adhams part</a></li><li><a class="tocitem" href="toc.html">Table of Content</a></li><li><a class="tocitem" href="test1.html">Tree Functionality</a></li><li><a class="tocitem" href="test2.html">Likelihood</a></li><li><a class="tocitem" href="parser.html">Parser</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="evil_twin_of_index.html">-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="evil_twin_of_index.html">-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/Julia_Tree/blob/master/docs/src/evil_twin_of_index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>List of all functions (minus private ones) in the alphabetical order, capital letters first </p><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.BHV_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T &lt;:GeneralNode</code></pre><p>This function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Distance.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.NNI!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NNI!(root::T, target::Int64)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T,T,Bool}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T,T,Bool}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.NNI!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NNI(root::T, target::T, lor::Bool)::Int64   where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The parameter <code>target</code> specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used <code>lor=true</code>. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.NNI!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.NNI!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NNI!(root::T)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successfull and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.NNI-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.NNI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NNI(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code> and returns a mutated copy while leaving the original tree intact.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.RF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RF(tree1::T, tree2::T)::Int64 where T &lt;:GeneralNode</code></pre><p>Calculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Distance.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{Symbol,1}, Symbol}}} where T&lt;:Real" href="#Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{Symbol,1}, Symbol}}} where T&lt;:Real"><code>Main.MCPhylo.RWM</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWM(params::ElementOrVector{Symbol}, moves::Array{Symbol}; args...)</p><p>Construct the RWM sampler for Trees. If you set moves to :all it will use all eligible moves to change the tree. These are currently: NNI, Slide, Swing, :EdgeLength</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/samplers/rwm.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.add_child!" href="#Main.MCPhylo.add_child!"><code>Main.MCPhylo.add_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)</code></pre><p>This function adds a child to the mother node. The arity of the mother node is increased by <code>1</code> and the root status of the child is set to <code>False</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.create_tree_from_leaves" href="#Main.MCPhylo.create_tree_from_leaves"><code>Main.MCPhylo.create_tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_tree_from_leaves(leaf_nodes::Vector{T})::Node</code></pre><p>This function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.delete_node!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.delete_node!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.delete_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_node!(node::Node)::Nothing</code></pre><p>This functions deletes node from a tree and assigns all its children to its mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_root-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}" href="#Main.MCPhylo.find_root-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}"><code>Main.MCPhylo.find_root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_root(node::Node)::Node</code></pre><p>Takes a node in a tree and finds the root of that tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Search.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Tuple{Main.MCPhylo.TreeStochastic}" href="#Main.MCPhylo.get_branchlength_vector-Tuple{Main.MCPhylo.TreeStochastic}"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(t::TreeStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L473-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Union{Tuple{N}, Tuple{N}} where N&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_branchlength_vector-Union{Tuple{N}, Tuple{N}} where N&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(root::N)::Vector{T}  where {N &lt;:GeneralNode, T&lt;:Real}</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L460-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Legacy.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,1}}} where T&lt;:Real where N&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,1}}} where T&lt;:Real where N&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(root::N, out_vec::Vector{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>Do post order traversal to retrieve a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L482-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_leaves-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_leaves-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_leaves-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_leaves-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sister-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_sister-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_sister</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_sister(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the sister of <code>node</code>. It does so by looking for the respective binary representation of the sister.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L392-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.insert_node!-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.insert_node!-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.insert_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insert_node!(mother::Node, children::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>This function inserts a node into a tree after a mother node and gains a subset of the mother&#39;s children as its children. Returns the inserted node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.ladderize_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T&lt;:AbstractNode)</code></pre><p>This function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Ladderizing.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.ladderize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree(root::T, ascending::Bool=true)::T where T&lt;:AbstractNode)</code></pre><p>This function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Ladderizing.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_order-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.level_order-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.level_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">level_order(node::T)::Array{T} where T&lt;:GeneralNode</code></pre><p>This function does level order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.majority_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T&lt;:AbstractNode</code></pre><p>Construct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L422-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.neighbor_joining-Tuple{Array{Float64,2},Array{String,1}}" href="#Main.MCPhylo.neighbor_joining-Tuple{Array{Float64,2},Array{String,1}}"><code>Main.MCPhylo.neighbor_joining</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighbor_joining(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Clustering.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.neighbor_joining-Tuple{Array{Float64,2}}" href="#Main.MCPhylo.neighbor_joining-Tuple{Array{Float64,2}}"><code>Main.MCPhylo.neighbor_joining</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighbor_joining(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Clustering.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T,AbstractString}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T,AbstractString}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newick(root::T, newickstring::AbstractString) where T&lt;:GeneralNode</code></pre><p>Do the newick recursion. It is meant as the internal iterator function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newick(node::Node)::String</code></pre><p>Creates a newick represnetation of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.path_length-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.path_length-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.path_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">path_length(ancestor::T, descendant::T)::Float64  where T&lt;:GeneralNode</code></pre><p>Note: The function assumes there is an ancestral relationship between the two nodes.</p><p>This function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L372-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.post_order-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.post_order-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.post_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.post_order-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.post_order-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.post_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.pre_order-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.pre_order-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.pre_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pre_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a pre order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the pre order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.pre_order-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.pre_order-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.pre_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pre_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does pre order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree!-Union{Tuple{T}, Tuple{T,Array{String,1}}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.prune_tree!-Union{Tuple{T}, Tuple{T,Array{String,1}}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.prune_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prune_tree!(root::T, node_names::Vector{String})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Pruning.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree!-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.prune_tree!-Union{Tuple{T}, Tuple{T,Array{T,1}}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.prune_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prune_tree!(root::T, node_names::Vector{T})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Pruning.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree-Union{Tuple{T}, Tuple{T,Array{String,1}}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.prune_tree-Union{Tuple{T}, Tuple{T,Array{String,1}}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.prune_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prune_tree(root::T, node_names::Vector{String})::T where T&lt;:AbstractNode</code></pre><p>This function returns a copy of a tree with specific nodes including their descendants removed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Pruning.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.randomize!-Union{Tuple{T}, Tuple{T}, Tuple{T,Int64}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.randomize!-Union{Tuple{T}, Tuple{T}, Tuple{T,Int64}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.randomize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomize!(root::Node, num::Int64=100)::nothing</code></pre><p>This function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.remove_child!-Union{Tuple{N}, Tuple{N,Bool}} where N&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.remove_child!-Union{Tuple{N}, Tuple{N,Bool}} where N&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.remove_child!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_child!(mother_node::Node, left::Bool)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. The removed node is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.remove_child!-Union{Tuple{N}, Tuple{N,N}} where N&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.remove_child!-Union{Tuple{N}, Tuple{N,N}} where N&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.remove_child!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_child!(mother_node::Node, child::Node)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. The removed node is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_branchlength_vector!-Tuple{Main.MCPhylo.TreeStochastic,Main.MCPhylo.ArrayStochastic}" href="#Main.MCPhylo.set_branchlength_vector!-Tuple{Main.MCPhylo.TreeStochastic,Main.MCPhylo.ArrayStochastic}"><code>Main.MCPhylo.set_branchlength_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T &lt;: Real</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L507-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_branchlength_vector!-Union{Tuple{T}, Tuple{Main.MCPhylo.TreeStochastic,Array{T,N} where N}} where T&lt;:Real" href="#Main.MCPhylo.set_branchlength_vector!-Union{Tuple{T}, Tuple{Main.MCPhylo.TreeStochastic,Array{T,N} where N}} where T&lt;:Real"><code>Main.MCPhylo.set_branchlength_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T &lt;: Real</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L498-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_branchlength_vector!-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,N} where N}} where T&lt;:Real where N&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.set_branchlength_vector!-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,N} where N}} where T&lt;:Real where N&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.set_branchlength_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_branchlength_vector!(root::N, blenvec::Array{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>This function sets the branch lengths of a tree to the values specified in blenvec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L521-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.slide!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.slide!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slide!(root::T) where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.slide-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.slide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slide(root::T)::T where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters. The new tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.swing!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.swing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swing!(root::T) where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.swing-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.swing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swing(root::T)::T where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children. The new tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L139-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,1}}} where T&lt;:Real where N&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N,Array{T,1}}} where T&lt;:Real where N&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.to_covariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N&lt;:GeneralNode,T&lt;: Real}</code></pre><p>Calcualte the variance-covariance matrix from <code>tree</code>. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_df-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}" href="#Main.MCPhylo.to_df-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}"><code>Main.MCPhylo.to_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_df(root::Node)::DataFrame</code></pre><p>This function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry <code>df[i,j]</code> is the length of the edge connecting node <code>i</code> with node <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_distance_matrix-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.to_distance_matrix-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.to_distance_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_distance_matrix(tree::T)::Array{Float64,2} where T &lt;:GeneralNode</code></pre><p>Calculate the distance matrix over the set of leaves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_height-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.tree_height-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.tree_height</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_height(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T,Float64}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T,Float64}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.tree_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_length(root::T, tl::Float64)::Float64 where T&lt;:GeneralNode</code></pre><p>This function does the internal tree length recursion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.tree_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_length(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L280-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.upgma-Tuple{Array{Float64,2},Array{String,1}}" href="#Main.MCPhylo.upgma-Tuple{Array{Float64,2},Array{String,1}}"><code>Main.MCPhylo.upgma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upgma(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Clustering.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.upgma-Tuple{Array{Float64,2}}" href="#Main.MCPhylo.upgma-Tuple{Array{Float64,2}}"><code>Main.MCPhylo.upgma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upgma(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Clustering.jl#L22-L28">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 9 November 2020 17:52">Monday 9 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
