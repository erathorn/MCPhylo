<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree Functionality · MCPhylo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCPhylo</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Adhams part</a></li><li><a class="tocitem" href="toc.html">Table of Content</a></li><li class="is-active"><a class="tocitem" href="test1.html">Tree Functionality</a></li><li><a class="tocitem" href="test2.html">Likelihood</a></li><li><a class="tocitem" href="parser.html">Parser</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="test1.html">Tree Functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="test1.html">Tree Functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/Julia_Tree/blob/master/docs/src/test1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-Functionality"><a class="docs-heading-anchor" href="#Tree-Functionality">Tree Functionality</a><a id="Tree-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Functionality" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.from_df-Tuple{DataFrames.DataFrame}" href="#Main.MCPhylo.from_df-Tuple{DataFrames.DataFrame}"><code>Main.MCPhylo.from_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_df(df::DataFrame)::Node</code></pre><p>This function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance_ultra-Union{Tuple{N}, Tuple{T}, Tuple{N}} where N&lt;:Main.MCPhylo.GeneralNode where T&lt;:Real" href="#Main.MCPhylo.to_covariance_ultra-Union{Tuple{N}, Tuple{T}, Tuple{N}} where N&lt;:Main.MCPhylo.GeneralNode where T&lt;:Real"><code>Main.MCPhylo.to_covariance_ultra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_covariance_ultra(tree::Node)::Array{T,2} where T&lt;: Real</code></pre><p>Get the covariance matrix of the ultrametric version of <code>tree</code> with height 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Converter.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.check_binary-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}" href="#Main.MCPhylo.check_binary-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}"><code>Main.MCPhylo.check_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_binary(root::Node)::Bool
checks to see if given tree is binary; returns true if properly formatted and false otherwise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L638-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.create_tree_from_leaves_bin-Tuple{Array{String,1},Int64}" href="#Main.MCPhylo.create_tree_from_leaves_bin-Tuple{Array{String,1},Int64}"><code>Main.MCPhylo.create_tree_from_leaves_bin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_tree_from_leaves(leaf_nodes::Vector{T})::Node</code></pre><p>This function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.force_ultrametric!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.force_ultrametric!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.force_ultrametric!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">force_ultrametric!(root::T) where T&lt;:GeneralNode</code></pre><p>Force an ultrametric version of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_mother-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_mother-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_mother</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_mother(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the mother of <code>node</code>. It does so by looking for the respective binary representation of the mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L403-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sum_seperate_length!-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_sum_seperate_length!-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_sum_seperate_length!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_sum_seperate_length!(root::Node)::Vector{Float64}</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L550-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sum_seperate_length!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_sum_seperate_length!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_sum_seperate_length!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_sum_seperate_length!(root::Node)::Vector{Float64}</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L539-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.node_height-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.node_height-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.node_height</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">node_height(root::T, mv::Float64)::Float64  where T&lt;:GeneralNode</code></pre><p>Calculate the height of a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.number_nodes!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.number_nodes!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.number_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_nodes!(root::T)::Nothing  where T&lt;:GeneralNode</code></pre><p>This function assigns a unique, sequential number to each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L434-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.random_node-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.random_node-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.random_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function random_node(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function returns a random node from the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L446-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_binary!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.set_binary!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.set_binary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_binary!(root::Node)</code></pre><p>Assign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Basics.jl#L413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.neighbor_joining_int-Tuple{Array{Float64,2},Array{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool},1}}" href="#Main.MCPhylo.neighbor_joining_int-Tuple{Array{Float64,2},Array{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool},1}}"><code>Main.MCPhylo.neighbor_joining_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighbor_joining_int(dm::Array{Float64,2},leaves::Vector{Node})</code></pre><p>Internal function that is called by both neighbor_joining methods. Contains the actual neighbor-joining algorithm, i.e. builds a phylogenetic tree from the given distance matrix and array of leaves. Returns a node of that tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Clustering.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.upgma_int-Tuple{Array{Float64,2},Array{Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool},Float64,Int64},1}}" href="#Main.MCPhylo.upgma_int-Tuple{Array{Float64,2},Array{Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool},Float64,Int64},1}}"><code>Main.MCPhylo.upgma_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upgma_int(dm::Array{Float64,2},leaves::Vector{Node})</code></pre><p>Internal function that is called by both UPGMA methods. Contains the actual UPGMA algorithm, i.e. builds a phylogenetic tree from the given distance matrix and array of leaves. Returns a node of that tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Clustering.jl#L40-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.find_common_clusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_common_clusters(ref_tree, tree:T)
    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}</code></pre><p>Use Day&#39;s algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.max_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:AbstractNode</code></pre><p>Recursive helper function to find the highest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.merge_trees!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T&lt;:AbstractNode</code></pre><p>Merge two compatible trees, i.e. inserts all cluster of the first tree, which aren&#39;t already in the second tree, into the secon tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.min_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T &lt;: AbstractNode</code></pre><p>Recursive helper function to find the lowest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.one_way_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one_way_compatible(ref_tree::T, tree::T)::T where T&lt;:AbstractNode</code></pre><p>Takes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.order_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())
    ::Vector{T} where T&lt;:AbstractNode</code></pre><p>Helper function to order a tree based on cluster indeces and return the leaves of the ordered tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L297-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.x_left</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_left(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>Helper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L363-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.x_right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_right(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>Helper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Consensus.jl#L387-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_bipartitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bipartitions(tree::T)::Vector{Tuple} where T &lt;:GeneralNode</code></pre><p>Get a vector of all bipartions of <code>tree</code>. The resulting vector contains Tuples of sets representing the bipartions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Distance.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.change_edge_length!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.change_edge_length!-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.change_edge_length!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_edge_length!(root::T) where T &lt;:GeneralNode</code></pre><p>Pick a random node and increase or decrease its length randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.move!-Union{Tuple{T}, Tuple{T,T,Float64}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.move!-Union{Tuple{T}, Tuple{T,T,Float64}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.move!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">move!(node1::Node, node2::Node, proportion::Float64)</code></pre><p>Change the incomming length of node1 and node2 while keeping there combined length constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.perform_spr-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}" href="#Main.MCPhylo.perform_spr-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}"><code>Main.MCPhylo.perform_spr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perform_spr(root::Node)</code></pre><p>performs SPR on binary tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L287-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR!-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}" href="#Main.MCPhylo.risky_SPR!-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}"><code>Main.MCPhylo.risky_SPR!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    risky_SPR!(root::Node)::AbstractNode
Performs SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not
Returns reference to root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}" href="#Main.MCPhylo.risky_SPR-Tuple{Main.MCPhylo.GeneralNode{String,Float64,Array{Float64,2},Array{Float64,2},Int64,String,Bool}}"><code>Main.MCPhylo.risky_SPR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    risky_SPR(root::Node)::AbstractNode
Performs SPR on tree in place; takes reference to root of tree, boolean value necessary to determine if tree should be treated as binary or not
Returns copy of root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_moves.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_binary-Union{Tuple{T}, Tuple{T,String}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.find_binary-Union{Tuple{T}, Tuple{T,String}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.find_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_binary(root::T, bin::String)::T where T&lt;:GeneralNode</code></pre><p>Find a node by its binary representation. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure wheter the node is in the tree at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Search.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_num-Union{Tuple{I}, Tuple{T}, Tuple{T,I,Array{T,1}}} where I&lt;:Integer where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.find_num-Union{Tuple{I}, Tuple{T}, Tuple{T,I,Array{T,1}}} where I&lt;:Integer where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.find_num</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_num(root::T, num::Int64, rn::Vector{T})::Bool  where T&lt;:GeneralNode</code></pre><p>Do a post order traversal to find the node corresponding to the <code>num</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Search.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_num-Union{Tuple{I}, Tuple{T}, Tuple{T,I}} where I&lt;:Integer where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.find_num-Union{Tuple{I}, Tuple{T}, Tuple{T,I}} where I&lt;:Integer where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.find_num</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_num(root::T, num::Int64)  where T&lt;:GeneralNode</code></pre><p>Find a node by its number. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure wheter the node is in the tree at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Search.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_traverse-Union{Tuple{T}, Tuple{T,Int64,Array{T,N} where N}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.level_traverse-Union{Tuple{T}, Tuple{T,Int64,Array{T,N} where N}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.level_traverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T &lt;:GeneralNode</code></pre><p>This function traverses a level of the tree specified through <code>node</code>. The level is specified via the <code>level</code> argument and the nodes visited are stored in the <code>stack</code>. This function is intended as the internal worker for the level_order function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/5c5698557fdaea3ec294e6da44bb157adde87d96/src/Tree/Tree_Traversal.jl#L113-L120">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="toc.html">« Table of Content</a><a class="docs-footer-nextpage" href="test2.html">Likelihood »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 9 November 2020 17:52">Monday 9 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
