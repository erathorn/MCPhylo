var documenterSearchIndex = {"docs":
[{"location":"parser/#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Parser functions read data stored in various filetypes.","category":"page"},{"location":"parser/#CSV","page":"Parser","title":"CSV","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\nPages   = [\"Parser/ParseCSV.jl\"]\nFilter = ","category":"page"},{"location":"parser/#MCPhylo.ParseCSV","page":"Parser","title":"MCPhylo.ParseCSV","text":"ParseCSV(filename::String, gap::AbstractString, miss::AbstractString, header::Bool=true)\n\nThis function parses a CSV file containing input for the MCMC compuation. The file should follow the conventions used for MrBayes. For example:\n\nSwedish_0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,?,0,0,?,0,0\nWelsh_N_0,0,0,0,0,0,0,?,0,0,0,0,?,?,0,0,?,0,0,0,1,?,?,0\nSardinian_N_0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,?,0,0,0,0,0\n\nSet input for \"header\" to false if no header is present in the file. Returns ntax, nchar as Integer values, gap as a String; df is returned as a DataFrame, and stores language names and data.\n\nfilename : Name of CSV file to parse.\nheader : Boolean value. \"true\" denotes there is a header to be skipped; input \"false\" if the file does not contain a header.\n\n\n\n\n\n","category":"function"},{"location":"parser/#MCPhylo.create_csvdf","page":"Parser","title":"MCPhylo.create_csvdf","text":"function create_csvdf(filecontnt::Array{String}, separator::AbstractString=\",\")::Tuple{Array{String}, Array{Char}}\n\nThis function parses a CSV file and returns its content as a DataFrame. NOTE: May later on be replaced by the respective DataFrames function.\n\n\n\n\n\n","category":"function"},{"location":"parser/#Nexus","page":"Parser","title":"Nexus","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\nPages   = [\"ParseNexus.jl\"]\nFilter = ","category":"page"},{"location":"parser/#MCPhylo.ParseNexus-Tuple{String}","page":"Parser","title":"MCPhylo.ParseNexus","text":"ParseNexus(filename::String)\n\nThis function parses a NEXUS file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes. Returns ntax, nchar, gap, and missing_representation values; returns Dataframe storing language names and data.\n\nfilename : NEXUS file to be parsed.\n\n\n\n\n\n","category":"method"},{"location":"parser/#MCPhylo.create_nexusdf-Tuple{Array{String, N} where N}","page":"Parser","title":"MCPhylo.create_nexusdf","text":"create_nexusdf(filecontent::Array{String})::Tuple{Array{SubString}, Array{Char}}\n\nThis function creates a DataFrame of the actual data. Used in ParseNexus(). Returns DataFrame of language names and data derived from NEXUS file.\n\nfilecontent : Array of Strings; Strings are read from NEXUS file in ParseNexus().\n\n\n\n\n\n","category":"method"},{"location":"parser/#MCPhylo.extract_meta_info-Tuple{Array{String, N} where N}","page":"Parser","title":"MCPhylo.extract_meta_info","text":"extract_meta_info(content::Array{String})\n\nThis function extracts some meta information from the content of the nexus file. It \"eats-up\" the stack. Returns values derived from metadata (ntax, nchar, gap, missing_representation). Used in ParseNexus().\n\ncontent : Array of Strings; Strings are read from NEXUS file in ParseNexus().\n\n\n\n\n\n","category":"method"},{"location":"parser/#General-Parser-Functions","page":"Parser","title":"General Parser Functions","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\nPages   = [\"Parser.jl\"]\nFilter = ","category":"page"},{"location":"parser/#MCPhylo.make_tree_with_data","page":"Parser","title":"MCPhylo.make_tree_with_data","text":"make_tree_with_data(filename::String, dialect::AbstractString=\"nexus\",\n\t\t\t\t\t\t gap::Union{Missing, AbstractString}=missing,\n\t\t\t\t\t\t miss::Union{Missing,AbstractString}=missing,\n\t\t\t\t\t\t header::Bool=false; binary::Bool=true)::Tuple{GeneralNode, Array{Float64}}\n\nGeneral parsing function; user specifies type of file to parse. Returns root Node of tree derived from data, as well as a DataFrame.\n\nfilename : Name of file to parse.\ndialect : Specifies filetype to parse; currently accepts EITHER \"nexus\" or \"csv\" as inputs.\ngap : specifies gap symbol for a CSV file; if \"dialect\" == \"csv\", this input is required, can be ommitted otherwise.\nmiss : specifies missing symbol for a CSV file; if \"dialect\" == \"csv\", this input is required, can be ommitted otherwise.\nheader : Boolean required for parsing CSV file, specifies if file contains a header; input not required when parsing a NEXUS file.\nbinary : Boolean, specifies whether a binary or nonbinary tree should be created for the given file. Defaults to true/binary tree.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Functions found in all files of samplers folder, ordered according to file of origin.","category":"page"},{"location":"samplers/#ABC","page":"Samplers","title":"ABC","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.ABC","category":"page"},{"location":"samplers/#MCPhylo.ABC","page":"Samplers","title":"MCPhylo.ABC","text":"ABC(params::ElementOrVector{Symbol},\nscale::ElementOrVector{T}, summary::Function,\nepsilon::Real; kernel::KernelDensityType=SymUniform,\ndist::Function=(Tsim, Tobs) -> sqrt(sum(abs2, Tsim - Tobs)),\nproposal::SymDistributionType=Normal, maxdraw::Integer=1,\nnsim::Integer=1, decay::Real=1.0, randeps::Bool=false,\nargs...)\n\nConstruct a `Sampler` object for ABC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\nReturns a `Sampler{ABCTune}` type object.\n* `params`: stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic `unlist()` function.\n* `scale` : scaling value or vector of the same length as the combined elements of nodes `params` for the `proposal` distribution.  Values are relative to the unconstrained parameter space, where candidate draws are generated.\n* `summary` : function that takes a vector of observed or simulated data and returns a summary statistic or vector of statistics.\n* `epsilon` : target tolerance for determining how similar observed and simulated data summary statistics need to be in order to accept a candidate draw.\n* `kernel` : weighting kernel density of type `Biweight`, `Cosine`, `Epanechnikov`, `Normal`, `SymTriangularDist`, `SymUniform`, or `Triweight` to use in measuring similarity between observed and simulated data summary statistics.  Specified `epsilon` determines the standard deviation of Normal kernels and widths of the others.\n* `dist` : positive function for the kernel density to compute distance between vectors of observed (`Tobs`) and simulated (`Tsim`) data summary statistics (default: Euclidean distance).\n* `proposal` : symmetric distribution of type `Biweight`, `Cosine`, `Epanechnikov`, `Normal`, `SymTriangularDist`, `SymUniform`, or `Triweight` to be centered around current parameter values and used to generate proposal draws.  Specified `scale` determines the standard deviations of Normal proposals and widths of the others.\n* `maxdraw` : maximum number of unaccepted candidates to draw in each call of the sampler.  Draws are generated until one is accepted or the maximum is reached.  Larger values increase acceptance rates at the expense of longer runtimes.\n* `nsim` : number of data sets to simulate in deciding whether to accept a candidate draw.  Larger values lead to closer approximations of the target distribution at the expense of longer runtimes.\n* `decay` : if `0 < decay <= 1`, the rate at which internal tolerances are monotonically decreased from the initial distance between observed and simulated summary statistics toward the maximum of each subsequent distance and `epsilon`; if `decay = 0`, internal tolerances are fixed at `epsilon`.\n* `randeps` : whether to perturb internal tolerances by random exponential variates.\n* `args...` : additional keyword arguments to be passed to the `dist` function.\n\n\n\n\n\nABC(params::ElementOrVector{Symbol},\nscale::ElementOrVector{T}, summary::Function,\nepsilon::Real, proposal::Function; kernel::KernelDensityType=SymUniform,\ndist::Function=(Tsim, Tobs) -> sqrt(sum(abs2, Tsim - Tobs)),\nmaxdraw::Integer=1,\nnsim::Integer=1, decay::Real=1.0, randeps::Bool=false,\nargs...)\n\nConstruct a `Sampler` object for ABC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\nReturns a `Sampler{ABCTune}` type object.\n* `params`: stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic `unlist()` function.\n* `summary` : function that takes a vector of observed or simulated data and returns a summary statistic or vector of statistics.\n* `epsilon` : target tolerance for determining how similar observed and simulated data summary statistics need to be in order to accept a candidate draw.\n* `proposal` : a proposal function which proposes a new value. \n* `kernel` : weighting kernel density of type `Biweight`, `Cosine`, `Epanechnikov`, `Normal`, `SymTriangularDist`, `SymUniform`, or `Triweight` to use in measuring similarity between observed and simulated data summary statistics.  Specified `epsilon` determines the standard deviation of Normal kernels and widths of the others.\n* `dist` : positive function for the kernel density to compute distance between vectors of observed (`Tobs`) and simulated (`Tsim`) data summary statistics (default: Euclidean distance).\n* `maxdraw` : maximum number of unaccepted candidates to draw in each call of the sampler.  Draws are generated until one is accepted or the maximum is reached.  Larger values increase acceptance rates at the expense of longer runtimes.\n* `nsim` : number of data sets to simulate in deciding whether to accept a candidate draw.  Larger values lead to closer approximations of the target distribution at the expense of longer runtimes.\n* `decay` : if `0 < decay <= 1`, the rate at which internal tolerances are monotonically decreased from the initial distance between observed and simulated summary statistics toward the maximum of each subsequent distance and `epsilon`; if `decay = 0`, internal tolerances are fixed at `epsilon`.\n* `randeps` : whether to perturb internal tolerances by random exponential variates.\n* `args...` : additional keyword arguments to be passed to the `dist` function.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#Empirical","page":"Samplers","title":"Empirical","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.Empirical","category":"page"},{"location":"samplers/#MCPhylo.Empirical","page":"Samplers","title":"MCPhylo.Empirical","text":"function Empirical(params::ElementOrVector{Symbol}, width::Int64; replace::Bool=false)\n\nThis Sampler generates Samples from a distribution by selecting a random value from this distribution. The move will always be accepted. Sampling can be done with or without replacement.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#HMC","page":"Samplers","title":"HMC","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.HMC","category":"page"},{"location":"samplers/#MCPhylo.HMC","page":"Samplers","title":"MCPhylo.HMC","text":"HMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nepsilon: step size.\nL: number of steps to take in the Leapfrog algorithm.\nSigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#MISS","page":"Samplers","title":"MISS","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.MISS","category":"page"},{"location":"samplers/#MCPhylo.MISS","page":"Samplers","title":"MCPhylo.MISS","text":"MISS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object to sampling missing output values. The constructor should only be used to sample stochastic nodes upon which no other stochastic node depends. So-called ‘output nodes’ can be identified with the keys() function. Moreover, when the MISS constructor is included in a vector of Sampler objects to define a sampling scheme, it should be positioned at the beginning of the vector. This ensures that missing output values are updated before any other samplers are executed.\n\nReturns a Sampler{Dict{Symbol, MISSTune}} type object.\n\nparams: stochastic node(s) that contain missing values (NaN) to be updated with the sampler.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#NUTS","page":"Samplers","title":"NUTS","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.NUTS","category":"page"},{"location":"samplers/#MCPhylo.NUTS","page":"Samplers","title":"MCPhylo.NUTS","text":"NUTS(params::ElementOrVector{Symbol}; variant::Symbol=:classic, epsilon::Real = -Inf, kwargs...)\n\nConstruct a Sampler object for NUTS sampling, with the algorithm´s step size parameter adaptively tuned during burn-in iterations. Parameters are assumed to be continuous, but may be constrained or unconstrained. The variant parameter controls whether the Riemannian variant of the NUTS algorithm (https://arxiv.org/abs/1304.1920) or the classical variant (https://jmlr.org/papers/v15/hoffman14a.html) is used.\n\nReturns a Sampler{NUTSTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nvariant : variant of the NUTS sampler. Options are\n:classic : classic version (default)\n:riemann : Riemannian version.\nepsilon: step size which can be presupplied. If the standard (-Inf) is chosen, it will be automatically adapted\n\n\n\n\n\n","category":"function"},{"location":"samplers/#P-NUTS","page":"Samplers","title":"P-NUTS","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.PNUTS","category":"page"},{"location":"samplers/#MCPhylo.PNUTS","page":"Samplers","title":"MCPhylo.PNUTS","text":"PNUTS(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for PNUTS sampling. The Parameter is assumed to be a tree.\n\nReturns a Sampler{PNUTSTune} type object.\n\nparams: stochastic node to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the PNUTSVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#PPHMC","page":"Samplers","title":"PPHMC","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.PPHMC","category":"page"},{"location":"samplers/#MCPhylo.PPHMC","page":"Samplers","title":"MCPhylo.PPHMC","text":"PPHMC(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for PPHMC sampling. The Parameter is assumed to be a tree.\n\nReturns a Sampler{PPHMCTune} type object.\n\nparams: stochastic node to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the PNUTSVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#RWM","page":"Samplers","title":"RWM","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.RWM","category":"page"},{"location":"samplers/#MCPhylo.RWM","page":"Samplers","title":"MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol},\n              scale::ElementOrVector{T}; args...) where {T<:Real})\n\nConstruct a Sampler object for RWM sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{RWMTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.\nscale: scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution. Values are relative to the unconstrained parameter space, where candidate draws are generated.\nargs...: additional keyword arguments to be passed to the RWMVariate constructor.\n\n\n\n\n\nRWM(params::ElementOrVector{Symbol}, moves::Array{Symbol}; args...)\n\nConstruct the RWM sampler for Trees. If you set moves to :all it will use all eligible moves to change the tree. These are currently: NNI, SPR, Slide, Swing, :EdgeLength\n\nReturns a Sampler{RWMTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#Slice","page":"Samplers","title":"Slice","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.Slice","category":"page"},{"location":"samplers/#MCPhylo.Slice","page":"Samplers","title":"MCPhylo.Slice","text":"Slice(params::ElementOrVector{Symbol},\n            width::ElementOrVector{T},\n            ::Type{F}=Multivariate;\n            transform::Bool=false) where {T<:Real, F<:SliceForm}\n\nConstruct a Sampler object for Slice sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{SliceTune{Univariate}} or Sampler{SliceTune{Multivariate}} type object if sampling univariately or multivariately, respectively.\n\nparams: stochastic node(s) to be updated with the sampler.\nwidth: scaling value or vector of the same length as the combined elements of nodes params, defining initial widths of a hyperrectangle from which to simulate values.\nF : sampler type. Options are\n:Univariate : sequential univariate sampling of parameters.\n:Multivariate : joint multivariate sampling.\ntransform: whether to sample parameters on the link-transformed scale (unconstrained parameter space). If true, then constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function, and width is interpreted as being relative to the unconstrained parameter space. Otherwise, sampling is relative to the untransformed space.\n\n\n\n\n\n","category":"function"},{"location":"samplers/#SliceSimplex","page":"Samplers","title":"SliceSimplex","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"MCPhylo.SliceSimplex","category":"page"},{"location":"samplers/#MCPhylo.SliceSimplex","page":"Samplers","title":"MCPhylo.SliceSimplex","text":"SliceSimplex(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for which SliceSimplex sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to be continuous and constrained to a simplex.\n\nReturns a Sampler{SliceSimplexTune} type object.\n\nparams: stochastic node(s) to be updated with the sampler.\nargs...: additional keyword arguments to be passed to the SliceSimplexVariate constructor.\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"There are several prior distributions for tree structures implemented in this package. Also there is a function which calculates the likelihood of a tree given a model using Felsensteins algorithm.","category":"page"},{"location":"likelihood/#Likelihood-Calculator-functionality","page":"Likelihood","title":"Likelihood Calculator functionality","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\nPages   = [\"Likelihood/LikelihoodCalculator_Node.jl\"]\nFilter =","category":"page"},{"location":"likelihood/#MCPhylo.FelsensteinFunction-Union{Tuple{V}, Tuple{A}, Tuple{M}, Tuple{N}, Tuple{Vector{N}, Array{Float64, N} where N, Float64, A, V, A, Float64, Array{Float64, 3}, Function}, Tuple{Vector{N}, Array{Float64, N} where N, Float64, A, V, A, Float64, Array{Float64, 3}, Function, Bool}} where {N<:GeneralNode, M<:Number, A<:AbstractArray, V<:(AbstractVector{T} where T)}","page":"Likelihood","title":"MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(tree_postorder::Vector{N}, pi_::Array{Float64}, rates::Array{Float64},\n                     U::Array{Float64,2}, D::Array{Float64}, Uinv::Array{Float64,2},\n                     data::Array{Float64,4}, c_grad::Bool = true) where {N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm. If c_grad equals true (default) the analytic gradient regarding the branch lengths of the tree gets computed as well.\n\n\n\n\n\n","category":"method"},{"location":"likelihood/#Prior","page":"Likelihood","title":"Prior","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"MCPhylo.TreeDistribution","category":"page"},{"location":"likelihood/#MCPhylo.TreeDistribution","page":"Likelihood","title":"MCPhylo.TreeDistribution","text":"TreeDistribution(length_distr::LengthDistribution, topology_distr::TopologyDistribution)\n\nWrapper struct for the TreeDistribution. Contains a length distribution and a topology distribution. Can be constructed with no arguments, one of the distributions, or both of  them. Fallbacks are UniformBranchLength for the length distribution & and UniformTopology for the topology distribution.\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#Branch-length-distributions","page":"Likelihood","title":"Branch length distributions","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"MCPhylo.CompoundDirichlet\nMCPhylo.exponentialBL\nMCPhylo.UniformBranchLength\nMCPhylo.BirthDeath\nMCPhylo.BirthDeathSimplified","category":"page"},{"location":"likelihood/#MCPhylo.CompoundDirichlet","page":"Likelihood","title":"MCPhylo.CompoundDirichlet","text":"CompoundDirichlet(alpha::Float64, a::Float64, beta::Float64, c::Float64, nterm::Float64)\n\nThis structure implememts the CompoundDirichlet distribution described in Zhang, Rannala and Yang 2012. (DOI:10.1093/sysbio/sys030)\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#MCPhylo.exponentialBL","page":"Likelihood","title":"MCPhylo.exponentialBL","text":"exponentialBL(scale::Float64) <: ContinuousUnivariateDistribution\n\nThis structure implememts an exponential prior on the branch lengths of a tree.\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#MCPhylo.UniformBranchLength","page":"Likelihood","title":"MCPhylo.UniformBranchLength","text":"UniformBranchLength()\n\nFallback struct that is used when no length distribution is given \n\n\n\n\n\n","category":"type"},{"location":"likelihood/#MCPhylo.BirthDeath","page":"Likelihood","title":"MCPhylo.BirthDeath","text":"Strict Molecular Clock - BirthDeath Implemented following Yang & Rannala 1997 doi.org/10.1093/oxfordjournals.molbev.a025811\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#MCPhylo.BirthDeathSimplified","page":"Likelihood","title":"MCPhylo.BirthDeathSimplified","text":"Strict Molecular Clock - Simplified Birth Death Implemented folloing Yang & Rannala 1996 doi.org/10.1007/BF02338839\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#Topology-distributions","page":"Likelihood","title":"Topology distributions","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"MCPhylo.UniformConstrained\nMCPhylo.UniformTopology","category":"page"},{"location":"likelihood/#MCPhylo.UniformConstrained","page":"Likelihood","title":"MCPhylo.UniformConstrained","text":"UniformConstrained(\n    constraint_dict::Dict{Symbol, \n                          Union{Vector{Vector{S}}, Vector{Tuple{Vector{S}, Vector{S}}}}\n                          } where S <: AbstractString)\n\nWrapper struct for the topology distribution. Contains a dictionary with constraints. Empty constructor results in an empty dictionary as a fallback.\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#MCPhylo.UniformTopology","page":"Likelihood","title":"MCPhylo.UniformTopology","text":"UniformTopology()\n\nFallback struct that is used when no topology distribution is given.\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#Gamma-Rates","page":"Likelihood","title":"Gamma Rates","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"MCPhylo.discrete_gamma_rates","category":"page"},{"location":"likelihood/#MCPhylo.discrete_gamma_rates","page":"Likelihood","title":"MCPhylo.discrete_gamma_rates","text":"function discrete_gamma_rates(α::T, β::S,k::Int64; method::Symbol=:mean, sig::Int64=1)::Array{Float64} where {T<:Real, S<:Real}\n\nThis function calculates the rates of the discretized gamma distribution. It returns a vector of either the mean or the median weights in each category, such that each category is of equal proportion.\n\nSee: Yang, 1994, Maximum likelihood phylogenetic estimation from DNA sequences with variable rates over sites: Approximate methods. (https://doi.org/10.1007/BF00160154)\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Substitution-Models","page":"Likelihood","title":"Substitution Models","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"MCPhylo.JC\nMCPhylo.Restriction\nMCPhylo.freeK\nMCPhylo.GTR","category":"page"},{"location":"likelihood/#MCPhylo.JC","page":"Likelihood","title":"MCPhylo.JC","text":"JC(base_freq::Vector{Float64},\n    SubstitutionRates::Vector{Float64})::Tuple{Array{Float64,2}, Array{Float64,1}, Array{Float64,2}}\n\nCalculate the eigenvalue decomposition of the Q matrix of the Jukes-Cantor model. The SubstitutionRates are ignored, and just for call stability.\n\nThe function returns the Eigenvectors, Eigenvalues and inverse of eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#MCPhylo.Restriction","page":"Likelihood","title":"MCPhylo.Restriction","text":"Restriction(base_freq::Vector{Float64},\n            SubstitutionRates::Vector{Float64})::Tuple{Array{Float64,2}, Array{Float64,1}, Array{Float64,2}}\n\nCalculate the eigenvalue decomposition of the Q matrix of the restriction site model. The SubstitutionRates are ignored, and just for call stability.\n\nThe function returns the Eigenvectors, Eigenvalues, inverse of eigenvectors and     the scale factor for expected number changes per site\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#MCPhylo.freeK","page":"Likelihood","title":"MCPhylo.freeK","text":"function freeK(base_freq::Vector{Float64},SubstitutionRates::AbstractArray)::Tuple{Array{N,2}, Array{N,1}, Array{N,2}, M} where {N <: Number, M <: Number}\n\nFreeK model of substitution.\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#MCPhylo.GTR","page":"Likelihood","title":"MCPhylo.GTR","text":"GTR(base_freq::Vector{Float64},\n    SubstitutionRates::Vector{Float64})::Tuple{Array{Float64,2}, Array{Float64,1}, Array{Float64,2}}\n\nCalculate the eigenvalue decomposition of the Q matrix of the General Time Reversible model.\n\nThe function returns the Eigenvectors, Eigenvalues and inverse of eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Functions found in all files of Utils folder, ordered according to file of origin.","category":"page"},{"location":"utils/#utils","page":"Utils","title":"utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utils/#MCPhylo.assign_mcmc_work-Tuple{Function, AbstractArray, SimulationParameters, Union{Nothing, ConvergenceStorage}}","page":"Utils","title":"MCPhylo.assign_mcmc_work","text":"assignmcmcwork(f::Function, lsts::AbstractArray                    )::Tuple{Vector{Tuple{Chains, Model, ModelState}},                       Array{Float64, 2}, Vector{AbstractString}}\n\n–- INTERNAL –- Starts the MCMC chain generation (on multiple workers if possible) and also starts parallel ASDSF - if possible and requested by the user.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MCPhylo.lcp-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractString","page":"Utils","title":"MCPhylo.lcp","text":"lcp(str1::T, str2::T)::T where T <: AbstractString\n\nGet the longest common prefix.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MCPhylo.mcmc_or_convergence-Tuple{AbstractArray}","page":"Utils","title":"MCPhylo.mcmc_or_convergence","text":"mcmcorconvergence(args::AbstractArray)     ::Union{Tuple{Chains, Model, ModelState}},             Tuple{Vector{Vector{Float64}}, ConvergenceStorage}\n\n–- INTERNAL –- Used in pmap call in assignmcmcwork to correctly dispatch arguments to either calculate convergence statistics or mcmc chains.\n\n\n\n\n\n","category":"method"},{"location":"model/#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"The Model type is designed to store the set of all model nodes, including parameter set \\Theta. In particular, it stores Dependent type objects in its nodes dictionary field. Valid models are ones whose nodes form directed acyclic graphs (DAGs). Sampling functions f_j_j=1^B are saved as Sampler objects in the vector of field samplers. Vector elements j=1,\\ldots,B correspond to sampling blocks Theta_j_j=1^B.","category":"page"},{"location":"model/#Dependent","page":"Model","title":"Dependent","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"MCPhylo.Logical\nMCPhylo.Stochastic","category":"page"},{"location":"model/#MCPhylo.Logical","page":"Model","title":"MCPhylo.Logical","text":"Logical(f::Function, monitor::Union{Bool, Vector{Int}}=true)\n\nConstructor for a Logical model node. This function assumes the output of the logical operation to be a scalar.\n\nf: Function specifying the deterministic operation performed on its arguments. These arguments are other nodes of the model.\nmonitor : Indicates whether the results should be monitored, i.e.saved.\n\n\n\n\n\nLogical(d::Integer, f::Function, monitor::Union{Bool, Vector{Int}}=true)\n\nConstructor for a Logical model node.\n\nd : Specifies the dimension of the output.\nf : Specifies the deterministic operation performed on its arguments. These arguments are other nodes of the model.\nmonitor : Indicates whether the results should be monitored, i.e.saved.\n\n\n\n\n\nLogical(d::T, f::Function, monitor::Union{Bool, Vector{Int}}=true) where T<:GeneralNode\n\nConstructor for a Logical model node, which can hold a Node structure, i.e. a tree.\n\nf is a function specifying the deterministic operation performed on its arguments. These arguments are other nodes of the model.\nmonitor indicates whether the results should be monitored, i.e. saved.\n\n\n\n\n\n","category":"type"},{"location":"model/#MCPhylo.Stochastic","page":"Model","title":"MCPhylo.Stochastic","text":"Stochastic(f::Function, monitor::Union{Bool, Vector{Int}}=true)\n\nConstructor for a Stochastic model node. This function assumes the output of the logical operation to be scalar.\n\nf : Specifies the distributional relationship between the arguments and the node. These arguments are other nodes of the model.\nmonitor : Indicates whether the results should be monitored, i.e. saved.\n\n\n\n\n\nStochastic(d::N, f::Function, monitor::Union{Bool, Vector{Int}}=true) where N<:GeneralNode\n\nConstructor for a Stochastic model node, which can hold a Node structure, i.e. a tree.\n\nf : Specifies the distributional reslationship between the arguments and the node.\n\nThese arguments are other nodes of the model.\n\nmonitor : Indicates whether the results should be monitored, i.e. saved.\n\n\n\n\n\n","category":"type"},{"location":"model/#Graph","page":"Model","title":"Graph","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"MCPhylo.draw\nMCPhylo.graph2dot","category":"page"},{"location":"model/#MCPhylo.draw","page":"Model","title":"MCPhylo.draw","text":"draw(m::Model; filename::AbstractString=\"\")\n\nDraw a GraphViz DOT-formatted graph representation of model nodes and their relationships.\n\nThe model drawn to an external file or standard output. Stochastic, logical, and input nodes will be represented by ellipses, diamonds, and rectangles, respectively. Nodes that are unmonitored in MCMC simulations will be gray-colored.\n\nm : model for which to construct a graph.\nfilename : external file to which to save the resulting graph, or an empty string to draw to standard output (default). If a supplied external file name does not include a dot (.), the file extension .dot will be appended automatically.\n\n\n\n\n\n","category":"function"},{"location":"model/#MCPhylo.graph2dot","page":"Model","title":"MCPhylo.graph2dot","text":"graph2dot(m::Model)\n\nDraw a GraphViz DOT-formatted graph representation of model nodes and their relationships.\n\nA character string representation of the graph suitable for in-line processing. Stochastic, logical, and input nodes will be represented by ellipses, diamonds, and rectangles, respectively. Nodes that are unmonitored in MCMC simulations will be gray-colored.\n\nm : model for which to construct a graph.\n\n\n\n\n\n","category":"function"},{"location":"model/#Initialization","page":"Model","title":"Initialization","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"Modules = [MCPhylo]\nPages   = [\"initialization.jl\"]\nFilter =","category":"page"},{"location":"model/#MCPhylo.SimulationParameters-Tuple{}","page":"Model","title":"MCPhylo.SimulationParameters","text":"SimulationParameters(; burnin::Int64=0, thin::Int64=1, chains::Int64=1,\n                     verbose::Bool=true, trees::Bool=false,\n                     asdsf::Bool=false, freq::Int64=50,\n                     min_splits::Float64=0.1)::SimulationParameters\n\nConstruct a SimulationParameters object that defines the simulation parameters for a MCMC simulation.\n\nReturns a SimulationParameters type object.\n\nburnin: controls how many trees are discarded before saving\nthin: controls thinning of saved trees\nchains: controls how many chains there are\nverbose: controls if sampler output is printed to the console\ntrees: controls if trees should be created during simulation\nasdsf: controls if ASDSF should be calculated\nfreq: controls at which interval trees are used for ASDSF\nmin_splits: controls the default minimal splits threshold\n\n\n\n\n\n","category":"method"},{"location":"model/#MCPhylo.setinits!-Tuple{Model, Dict{Symbol, V} where V}","page":"Model","title":"MCPhylo.setinits!","text":"setinits!(m::Model, inits::Dict{Symbol})\n\nSet the initial values of stochastic model nodes.\n\nReturns the model with stochastic nodes initialized and the iter field set equal to 0.\n\nm : model with nodes to be initialized.\ninits : initial values for stochastic model nodes. Dictionary keys and values should be given for each stochastic node.\n\n\n\n\n\n","category":"method"},{"location":"model/#MCPhylo.setinits!-Tuple{Model, Vector{V} where V<:(Dict{Symbol, V} where V)}","page":"Model","title":"MCPhylo.setinits!","text":"setinits!(m::Model, inits::Vector{V} where V<:Dict{Symbol})\n\n\n\n\n\n","category":"method"},{"location":"model/#MCPhylo.setinputs!-Tuple{Model, Dict{Symbol, V} where V}","page":"Model","title":"MCPhylo.setinputs!","text":"setinputs!(m::Model, inputs::Dict{Symbol})\n\nSet the values of input model nodes.\n\nm : model with input nodes to be assigned.\ninputs : values for input model nodes. Dictionary keys and values should be given for each input node.\n\nReturns the model with values assigned to input nodes.\n\n\n\n\n\n","category":"method"},{"location":"model/#MCPhylo.setsamplers!-Tuple{Model, Vector{V} where V<:Sampler}","page":"Model","title":"MCPhylo.setsamplers!","text":"function setsamplers!(m::Model, samplers::Vector{V} where V<:Sampler)\n\nSet the samplers for the Stocastic nodes of a given Model.\n\nReturns the Model with updated samplers.\n\nm : Model to update.\nsamplers : block-specific sampelrs.\n\n\n\n\n\n","category":"method"},{"location":"model/#MCMC","page":"Model","title":"MCMC","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"Main.MCPhylo.mcmc","category":"page"},{"location":"model/#MCPhylo.mcmc","page":"Model","title":"MCPhylo.mcmc","text":"mcmc(mc::ModelChains, iters::Integer; verbose::Bool=true, trees::Bool=false)\n\nThis function simulates additional draws from a model.\n\nmc is the results of a previous call to the mcmc function.\niters indicates the number of draws to simulate.\nverbose controls whether to print progress statements to the console.\ntrees indicates if the states of the model nodes describing tree structures should be stored as well.\n\n\n\n\n\nmcmc(m::Model, inputs::Dict{Symbol},\n          inits::Vector{V} where V<:Dict{Symbol},\n          iters::Integer; burnin::Integer=0, thin::Integer=1,\n          chains::Integer=1, verbose::Bool=true, trees::Bool=false,\n          params::SimulationParameters=SimulationParameters())\n\nSimulate MCMC draws from the model m.\n\ninputs is a dictionary storing the values for input model nodes. Dictionary keys and values should be given for each input node.\ninits contains dictionaries with initial values for stochastic model nodes. Dictionary keys and values should be given for each stochastic node. Consecutive runs of the simulator will iterate through the vector’s dictionary elements.\niter Specifies the number of draws to generate for each simulation run\nburnin specifies the number of initial draws to discard as a burn-in sequence to allow for convergence.\nthin is the step-size between draws to store in the output.\nchains specifies the number of simulation runs to perform.\nverbose indicates whether the sampler progress should be printed at the console.\ntrees indicates if the states of the model nodes describing tree structures should be stored as well.\nparams pass one Struct to set all simulation parameters, instead of setting each individually\n\n\n\n\n\n","category":"function"},{"location":"model/#Model-Building","page":"Model","title":"Model Building","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"MCPhylo.Model","category":"page"},{"location":"model/#MCPhylo.Model","page":"Model","title":"MCPhylo.Model","text":"Model(; iter::Integer=0, burnin::Integer=0,\n  samplers::Vector{Sampler}=Sampler[], nodes...)\n\nConstruct a Model object that defines a model for MCMC simulation.\n\nReturns a Model type object.\n\niter: current iteration of the MCMC simulation.\nburnin: number of initial draws to be discarded as a burn-in sequence to allow for convergence.\nsamplers: block-specific sampling functions.\nnodes...: arbitrary number of user-specified arguments defining logical and stochastic nodes in the model. Argument values must be Logical or Stochastic type objects. Their names in the model will be taken from the argument names.\n\n\n\n\n\n","category":"type"},{"location":"distributions/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Modules = [MCPhylo]\nPages   = [\"distributions/constructors.jl\", \"distributionstruct.jl\", \"extensions.jl\", \"pdmatdistribution.jl\", \"pdmats2.jl\", \"Phylodist.jl\", \"transformdistribution.jl\", \"TreeConstraints.jl\"]\nFilter = ","category":"page"},{"location":"distributions/#MCPhylo.PhyloDist","page":"Distributions","title":"MCPhylo.PhyloDist","text":"This structure implements a Distribution whos likelihood is calculated\naccording to Felsensteins algorithm.\n\n\n\n\n\n","category":"type"},{"location":"distributions/#MCPhylo.PhyloDist-Union{Tuple{R}, Tuple{S}, Tuple{T}, Tuple{T, S, R, R, Function}} where {T<:GeneralNode, S<:(DenseArray{Float64, N} where N), R<:Real}","page":"Distributions","title":"MCPhylo.PhyloDist","text":"function PhyloDist(my_tree::T, base_freq::S, substitution_rates::R, rates::R, substitution_model::Function) where {T<:GeneralNode, S<:DenseArray{Float64}, R<:Real}\n\nConvenience function which can work with MCPhylo types.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MCPhylo.generate_constraints!-Tuple{Dict{Symbol, Union{Array{Vector{S}, 1}, Array{Tuple{Vector{S}, Vector{S}}, 1}} where S<:AbstractString}, String}","page":"Distributions","title":"MCPhylo.generate_constraints!","text":"generate_constraints!(constraints::ConstraintDict, filename::String)\n\nFunction that adds further constraints to an existing dictionary of constraints, based on a txt file with a specific format (each line one constraint). See basic generate_constraints function on a file for more info.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MCPhylo.generate_constraints!-Union{Tuple{Dict{Symbol, Union{Array{Vector{S}, 1}, Array{Tuple{Vector{S}, Vector{S}}, 1}} where S<:AbstractString}}, Tuple{S}} where S<:AbstractString","page":"Distributions","title":"MCPhylo.generate_constraints!","text":"generate_constraints!(\n    constraints::Dict;\n    mono::Vector{Vector{S}}=Vector{String}[],\n    not_mono::Vector{Vector{S}}=Vector{String}[],\n    exc::Vector{Tuple{Vector{S}, Vector{S}}}=Vector{Tuple{Vector{String}, Vector{String}}}[]\n)::ConstraintDict where S<:AbstractString\n\nFunction that adds further constraints to an existing dictionary of constraints. See basic generate_constraints function for more info.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MCPhylo.generate_constraints-Tuple{String}","page":"Distributions","title":"MCPhylo.generate_constraints","text":"generate_constraints(filename::String)\n\nFunction that creates a dictionary of constraints, based on a txt file with a specific format, i.e.:\n\nlines starting with '#' will be ignored\n\nmultiple constraints per line allowed\n\nmono:        A,B; C,D; mono:        E,F;\n\nfinal semicolon is optional\n\nnot_mono:    C,D,E exc :        E,F!G;\n\nSee basic generate_constraints function for more info.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MCPhylo.generate_constraints-Union{Tuple{}, Tuple{S}} where S<:AbstractString","page":"Distributions","title":"MCPhylo.generate_constraints","text":"generate_constraints(\n    ; mono::Vector{Vector{S}}=Vector{String}[],\n    not_mono::Vector{Vector{S}}=Vector{String}[],\n    exc::Vector{Tuple{Vector{S}, Vector{S}}}=Vector{Tuple{Vector{String}, Vector{String}}}[]\n)::ConstraintDict where S<:AbstractString\n\nGenerate a dictionary of constraints based on the given arguments. Mono for all monophyletic groups. not_mono for leafs that are not allowed to form a monophletic group. And exc for a partial constraint, where one or more leafs are not allowed to be part of a specific clade.\n\ne.g.: generate_constraints(mono=[[\"a\", \"b\"], [\"a\", \"c\"]],                            exc=[([\"b\", \"c\"],[\"d\"]])\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MCPhylo.parse_constraints-Tuple{S} where S<:AbstractString","page":"Distributions","title":"MCPhylo.parse_constraints","text":"parse_constraints(filename::S\n                 )::Tuple{\n                    Vector{Vector{S}},\n                    Vector{Vector{S}},\n                    Vector{Tuple{Vector{S}, Vector{S}}}\n                 } where S<:AbstractString\n\n–- INTERNAL –- Helper function that reads constraints out of a file\n\n\n\n\n\n","category":"method"},{"location":"links/#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"links/","page":"Links","title":"Links","text":"Below we've provided links to relevant Jupyter Notebooks and publications. More will be added as they come. ","category":"page"},{"location":"links/#Notebooks","page":"Links","title":"Notebooks","text":"","category":"section"},{"location":"links/#[Markov-Chain-Monte-Carlo-for-Tree-structures](https://github.com/erathorn/Julia_Tree/blob/master/notebook/MCPhylo.ipynb)","page":"Links","title":"Markov Chain Monte Carlo for Tree structures","text":"","category":"section"},{"location":"links/","page":"Links","title":"Links","text":"A software package to calculate statistic problems including (phylogenetic) tree structures","category":"page"},{"location":"links/#Papers,-References","page":"Links","title":"Papers, References","text":"","category":"section"},{"location":"links/#[Markov-Chain-Monte-Carlo-in-Julia](https://mambajl.readthedocs.io/en/latest/)","page":"Links","title":"Markov Chain Monte Carlo in Julia","text":"","category":"section"},{"location":"links/#[Probabilistic-Path-Hamiltonian-Dynamics](https://arxiv.org/pdf/1702.07814.pdf)","page":"Links","title":"Probabilistic Path Hamiltonian Dynamics","text":"","category":"section"},{"location":"#MCPhylo","page":"Index","title":"MCPhylo","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This package does phylogenetic computations in Julia. It is an extension of the Mamba package which does Markov Chain Monte Carlo (MCMC) sampling for Bayesian analysis. (https://mambajl.readthedocs.io/en/latest/) MCPhylo extends Mamba by a tree module to perform phylogenetic computations.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The goal is to facilitate phylogenetic computations in computational historical linguistics. To facilitate the inference of phylogenetic trees, Probabilistic Path Hamiltonian Dynamics (https://arxiv.org/pdf/1702.07814.pdf) are implemented.","category":"page"},{"location":"","page":"Index","title":"Index","text":"This module is build on a forked instance of Mamba 0.12.0","category":"page"},{"location":"#General-Information","page":"Index","title":"General Information","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"The stable version can  be installed via the Julia package manager.","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"MCPhylo\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"In order to use the latest version you can install it directly from its GitHub source.","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"https://github.com/erathorn/MCPhylo.jl\")","category":"page"},{"location":"#Tree-Functionalities","page":"Index","title":"Tree Functionalities","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"The tree functionalities within this package are reexported from MCPhyloTreehttps://erathorn.github.io/MCPhyloTree.jl/stable/. The the respective documentation for more details.","category":"page"},{"location":"developers/#For-Developers","page":"For Developers","title":"For Developers","text":"","category":"section"},{"location":"developers/","page":"For Developers","title":"For Developers","text":"On this page you can finde more detailed, developer oriented documentation on internal functions which are not necessarily exported to the main API.","category":"page"},{"location":"developers/","page":"For Developers","title":"For Developers","text":"MCPhylo.setinits!\nMCPhylo.setmonitor!\nMCPhylo.update!\nMCPhylo.Base.keys\nMCPhylo.Base.show\nMCPhylo.showall","category":"page"},{"location":"developers/#MCPhylo.setinits!","page":"For Developers","title":"MCPhylo.setinits!","text":"setinits!(l::AbstractLogical, m::Model, ::Any=nothing)\n\nSet initial values for a logical node.\n\nReturns the result of a call to setmonitor!(l, l.monitor) or setmonitor!(d, d.monitor).\n\nl : logical node to which to assign initial values.\nm : model containing the node.\n\n\n\n\n\nsetinits!(s::ScalarStochastic, m::Model, x::Real)\n\nSet initial values for a stochastic node.\n\nReturns the node with its assigned initial values.\n\ns : stochastic node to which to assign initial values.\nm : model containing the node.\nx : values to assign to the node.\n\n\n\n\n\nsetinits!(s::ArrayStochastic, m::Model, x::DenseArray)\n\nSet initial values for a stochastic node.\n\nReturns the node with its assigned initial values.\n\ns : stochastic node to which to assign initial values.\nm : model containing the node.\nx : values to assign to the node.\n\n\n\n\n\nsetinits!(d::TreeStochastic, m::Model, x::T) where {T<:GeneralNode}\n\nSet initial values for a stochastic node.\n\nReturns the node with its assigned initial values.\n\ns or d : stochastic node to which to assign initial values.\nm : model containing the node.\nx : values to assign to the node.\n\n\n\n\n\nsetinits!(m::Model, inits::Dict{Symbol})\n\nSet the initial values of stochastic model nodes.\n\nReturns the model with stochastic nodes initialized and the iter field set equal to 0.\n\nm : model with nodes to be initialized.\ninits : initial values for stochastic model nodes. Dictionary keys and values should be given for each stochastic node.\n\n\n\n\n\nsetinits!(m::Model, inits::Vector{V} where V<:Dict{Symbol})\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.setmonitor!","page":"For Developers","title":"MCPhylo.setmonitor!","text":"setmonitor!(d::AbstractDependent, monitor::Bool)\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : boolean indicating whether all elements are monitored.\n\n\n\n\n\nsetmonitor!(d::AbstractDependent, monitor::Vector{Int})\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : vector of element-wise indices of elements to monitor.\n\n\n\n\n\nsetmonitor!(d::TreeVariate, monitor::Bool)\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : boolean indicating whether all elements are monitored.\n\n\n\n\n\nsetmonitor!(d::TreeVariate, monitor::Vector{Int})\n\nSpecify node elements to be included in monitored MCMC sampler output.\n\nReturns d with its monitor field updated to reflect the specified monitoring.\n\nd : node whose elements contain sampled MCMC values.\nmonitor : vector of element-wise indices of elements to monitor.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.update!","page":"For Developers","title":"MCPhylo.update!","text":"update!(l::AbstractLogical, m::Model)\n\nUpdate the values of a logical node according to its relationship with others in a model.\n\nReturns the node with its values updated.\n\nl : logical node to update.\nm : model containing the node.\n\n\n\n\n\nupdate!(s::AbstractStochastic, m::Model)\n\nUpdate the values of a stochastic node according to its relationship with others in a model.\n\nReturns the node with its values updated.\n\ns : stochastic node to update.\nm : model containing the node.\n\n\n\n\n\nupdate!(m::Model, block::Integer=0)\n\n\n\n\n\nupdate!(m::Model, nodekeys::Vector{Symbol})\n\nUpdate values of logical and stochastic model node according to their relationship with others in a model.\n\nReturns the model with updated nodes.\n\nm : mode with nodes to be updated.\nblock : sampling block of nodes to be updated (default: all blocks).\nnodekeys : nodes to be updated in the given order.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.keys","page":"For Developers","title":"Base.keys","text":"Base.keys(m::Model, ntype::Symbol, at...)\n\nExtract the symbols (keys) for all existing nodes or for nodes of a specified type.\n\nm : model containing the nodes of interest.\nntype : type of nodes to return. Options are\n:all : all input, logical, and stochastic model nodes.\n:assigned : nodes that have been assigned values.\n:block : stochastic nodes being updated by the sampling block(s) at::Integer=0 (default: all blocks).\n:dependent : logical and stochastic (dependent) nodes in topologically sorted order.\n:independent or :input : input (independent) nodes.\n:logical : logical nodes.\n:monitor : stochastic nodes being monitored in MCMC sampler output.\n:output : stochastic nodes upon which no other stochastic nodes depend.\n:source : nodes upon which the node at::Symbol or vector of nodes at::Vector{Symbol} depends.\n:stochastic : stochastic nodes.\n:target : topologically sorted nodes that depend on the sampling block(s) at::Integer=0 (default: all blocks), node at::Symbol , or vector of nodes at::Vector{Symbol} .\nat... : additional positional arguments to be passed to the ntype options, as described above.\n\n\n\n\n\nBase.keys(c::AbstractChains)\n\nReturns names of parameter elements.\n\nc : Chain to return names of.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.show","page":"For Developers","title":"Base.show","text":"Base.show(io::IO, m::Model)\n\nWrite a text representation of the model, nodes, and attributes to the current output stream.\n\n\n\n\n\nBase.show(io::IO, c::AbstractChains)\n\nPrints header and values of Chain.\n\nio : IO stream on which to print.\nAbstractChains : Chain to print.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.showall","page":"For Developers","title":"MCPhylo.showall","text":"showall(io::IO, m::Model)\n\nWrite a verbose text representation of the model, nodes, and attributes to the current output stream.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Simulation","page":"For Developers","title":"Simulation","text":"","category":"section"},{"location":"developers/","page":"For Developers","title":"For Developers","text":"MCPhylo.gettune\nMCPhylo.settune!\nMCPhylo.gradlogpdf\nMCPhylo.gradlogpdf!\nMCPhylo.logpdf\nMCPhylo.logpdf!\nMCPhylo.sample!(::Main.MCPhylo.Model, ::Integer)\nMCPhylo.unlist\nMCPhylo.relist\nMCPhylo.relist!\nMCPhylo.update!\nMCPhylo.sample!\nMCPhylo.ABC_sample\nMCPhylo.Sampler","category":"page"},{"location":"developers/#MCPhylo.gettune","page":"For Developers","title":"MCPhylo.gettune","text":"gettune(m::Model, block::Integer)\n\n\n\n\n\ngettune(m::Model)\n\nGet block-sampler tuning parameters.\n\nReturns a Vector{Any} of all block-specific tuning parameters without block input, and turning parameters for the specified block otherwise.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.settune!","page":"For Developers","title":"MCPhylo.settune!","text":"settune!(m::Model, tune, block::Integer)\n\n\n\n\n\nsettune!(m::Model, tune::Vector{Any})\n\nSet tuning parameters for one or all blocks.\n\nAssigns desired tune values to model.\n\nm : model containing the nodes of interest.\ntune : tune values to be assigned to models; if no block value is input, tune must be a Vector with length equal to m.samplers.\nblock : Integer denoting which block's tune value is to be reassigned.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Distributions.gradlogpdf","page":"For Developers","title":"Distributions.gradlogpdf","text":"gradlogpdf(m::Model, block::Integer=0, transform::Bool=false;\n                dtype::Symbol=:forward)\n\n\n\n\n\ngradlogpdf(m::Model, targets::Array{Symbol, 1})::Tuple{Float64, Array{Float64}}\n\nCompute the gradient of log-densities for stochastic nodes.\n\nReturns the resulting gradient vector. Method gradlogpdf!() additionally updates model m with supplied values x.\n\nm : model containing the stochastic nodes for which to compute the gradient.\nblock : sampling block of stochastic nodes for which to compute the gradient (default: all stochastic nodes).\nx: value (possibly different than the current one) at which to compute the gradient.\ntransform: whether to compute the gradient of block parameters on the link–transformed scale.\ndtype : type of differentiation for gradient calculations. Options are\n:central : central differencing.\n:forward : forward differencing.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.gradlogpdf!","page":"For Developers","title":"MCPhylo.gradlogpdf!","text":"gradlogpdf!(m::Model, x::AbstractVector{T}, block::Integer=0,\n                  transform::Bool=false; dtype::Symbol=:forward) where {T<:Real}\n\n\n\n\n\ngradlogpdf!(m::Model, x::AbstractArray{T}, block::Integer=0,transform::Bool=false)\n where T<:GeneralNode\n\n\n\n\n\ngradlogpdf!(m::Model, x::N, block::Integer=0,transform::Bool=false)::Tuple{Float64, Vector{Float64}}\n    where N<:GeneralNode\n\nReturns the resulting gradient vector. Method gradlogpdf!() additionally updates model m with supplied values x.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Distributions.logpdf","page":"For Developers","title":"Distributions.logpdf","text":"logpdf(m::Model, block::Integer=0, transform::Bool=false)\n\n\n\n\n\nlogpdf(m::Model, nodekeys::Vector{Symbol}, transform::Bool=false)\n\nCompute the sum of log-densities for stochastic nodes.\n\nReturns the resulting numeric value of summed log-densities.\n\nm: model containing the stochastic nodes for which to evaluate log-densities.\nblock : sampling block of stochastic nodes over which to sum densities (default: all stochastic nodes).\nnodekeys : nodes over which to sum densities.\nx : value (possibly different than the current one) at which to evaluate densities.\ntransform : whether to evaluate evaluate log-densities of block parameters on the link–transformed scale.\n\n\n\n\n\nlogpdf(m::Model, x::AbstractArray{T}, block::Integer=0,\n        transform::Bool=false) where {T<:Real}\n\n\n\n\n\nlogpdf(mc::ModelChains, f::Function, nodekeys::Vector{Symbol})\n\nCompute the sum of log-densities at each iteration of MCMC output for stochastic nodes.\n\nReturns a ModelChains object of resulting summed log-densities at each MCMC iteration of the supplied chain.\n\nmc : sampler output from a model fit with the mcmc()` function.\nnodekey/nodekeys : stochastic model node(s) over which to sum densities (default: all).\nf : ??\n\n\n\n\n\nlogpdf(mc::ModelChains,\n       nodekeys::Vector{Symbol}=keys(mc.model, :stochastic))\n\n\n\n\n\n","category":"function"},{"location":"developers/#Distributions.logpdf!","page":"For Developers","title":"Distributions.logpdf!","text":"logpdf!(m::Model, x::N, block::Integer=0,\n          transform::Bool=false) where N<:GeneralNode\n\n\n\n\n\n","category":"function"},{"location":"developers/#StatsBase.sample!-Tuple{Model, Integer}","page":"For Developers","title":"StatsBase.sample!","text":"sample!(m::Model, block::Integer=0)\n\nGenerate one MCMC sample of values for a specified model.\n\nReturns the model updated with the MCMC sample and, in the case of block=0, the iter field incremented by 1.\n\nm : model specification.\nblock : block for which to sample values (default: all blocks).\n\n\n\n\n\n","category":"method"},{"location":"developers/#MCPhylo.unlist","page":"For Developers","title":"MCPhylo.unlist","text":"unlist(m::Model, block::Integer=0, transform::Bool=false)\n\n\n\n\n\nunlist(m::Model, monitoronly::Bool)\n\n\n\n\n\nunlist(m::Model, nodekeys::Vector{Symbol}, transform::Bool=false)\n\nConvert (unlist) sets of logical and/or stochastic node values to vectors.\n\nReturns vectors of concatenated node values.\n\nm : model containing nodes to be unlisted or relisted.\nblock : sampling block of nodes to be listed (default: all blocks).\nnodekeys : node(s) to be listed.\ntransform : whether to apply a link transformation in the conversion.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.relist","page":"For Developers","title":"MCPhylo.relist","text":"relist(m::Model, x::AbstractArray{T}, block::Integer=0,\n        transform::Bool=false) where {T<:Real}\n\n\n\n\n\nrelist(m::Model, x::AbstractArray{T}, block::Integer=0,\n        transform::Bool=false) where {T<:GeneralNode}\n\n\n\n\n\nrelist(m::Model, x::AbstractArray{T},\n        nodekeys::Vector{Symbol}, transform::Bool=false) where {T<:Any}\n\n\n\n\n\nrelist(m::Model, x::N, nodekeys::Vector{Symbol}, transform::Bool=false) where N<:GeneralNode\n\nReverse of unlist; ie. Converts vectors to sets of logical and/or stochastic node values. Same inputs and return values as unlist.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.relist!","page":"For Developers","title":"MCPhylo.relist!","text":"relist!(m::Model, x::AbstractArray{T}, block::Integer=0,\n          transform::Bool=false) where {T<:Any}\n\n\n\n\n\nrelist!(m::Model, x::AbstractArray{T}, nodekey::Symbol,\n              transform::Bool=false) where {T<:Real}\n\nReverse of unlist; ie. Converts vectors to sets of logical and/or stochastic node values. Same inputs as unlist.\n\nReturns m, with values copied to the nodes.\n\n\n\n\n\n","category":"function"},{"location":"developers/#StatsBase.sample!","page":"For Developers","title":"StatsBase.sample!","text":"sample!(m::Model, block::Integer=0)\n\nGenerate one MCMC sample of values for a specified model.\n\nReturns the model updated with the MCMC sample and, in the case of block=0, the iter field incremented by 1.\n\nm : model specification.\nblock : block for which to sample values (default: all blocks).\n\n\n\n\n\nsample!(v::HMCVariate, logfgrad::Function)\n\nDraw one sample from a target distribution using the HMC sampler. Parameters are assumed to be continuous and unconstrained.\n\nReturns v updated with simulated values and associated tuning parameters.\n\n\n\n\n\nsample!(v::NUTSVariate, logfgrad::Function; adapt::Bool=false)\n\nDraw one sample from a target distribution using the NUTS sampler. Parameters are assumed to be continuous and unconstrained.\n\nReturns v updated with simulated values and associated tuning parameters.\n\n\n\n\n\nsample!(v::RWMVariate, logf::Function, moves::Array{Symbol})\n\nPropose a new tree by randomly performing a move from the ones specified in moves.\n\nReturns v updated with simulated values and associated tuning parameters.\n\n\n\n\n\nsample!(v::RWMVariate, logf::Function)\n\nDraw one sample from a target distribution using the RWM sampler. Parameters are assumed to be continuous and unconstrained.\n\nReturns v updated with simulated values and associated tuning parameters.\n\n\n\n\n\nsample!(v::SliceSimplexVariate, logf::Function)\n\nDraw one sample from a target distribution using the SliceSimplex sampler. Parameters are assumed to be continuous and constrained to a simplex.\n\nReturns v updated with simulated values and associated tuning parameters.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.ABC_sample","page":"For Developers","title":"MCPhylo.ABC_sample","text":"Do the ABC sampling. This version uses threads.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MCPhylo.Sampler","page":"For Developers","title":"MCPhylo.Sampler","text":"Sampler(params::Vector{Symbol}, f::Function, tune::Any=Dict())\n\nConstruct a Sampler object that defines a sampling function for a block of stochastic nodes.\n\nReturns a Sampler{typeof(tune)} type object.\n\nparams: node(s) being block-updated by the sampler.\nf: function for the eval field of the constructed sampler and whose arguments are the other model nodes upon which the sampler depends, typed argument model::Model that contains all model nodes, and/or typed argument block::Integer that is an index identifying the corresponding sampling function in a vector of all samplers for the associated model. Through the arguments, all model nodes and fields can be accessed in the body of the function. The function may return an updated sample for the nodes identified in its params field. Such a return value can be a structure of the same type as the node if the block consists of only one node, or a dictionary of node structures with keys equal to the block node symbols if one or more. Alternatively, a value of nothing may be returned. Return values that are not nothing will be used to automatically update the node values and propagate them to dependent nodes. No automatic updating will be done if nothing is returned.\ntune: tuning parameters needed by the sampling function.\n\n\n\n\n\n","category":"type"},{"location":"developers/","page":"For Developers","title":"For Developers","text":"MCPhylo.getindex\nMCPhylo.setindex!\nMCPhylo.Base.cat\nMCPhylo.Base.keys(::Main.MCPhylo.AbstractChains)\nMCPhylo.Base.show(::IO, ::Main.MCPhylo.AbstractChains)\nMCPhylo.Base.size","category":"page"},{"location":"developers/#Base.getindex","page":"For Developers","title":"Base.getindex","text":"Base.getindex(c::Chains, window, names, chains)\n\nSubset MCMC sampler output. The syntax c[i, j, k] is converted to getindex(c, i, j, k).\n\nSubsetted sampler output stored in the same type of object as that supplied in the call.\n\nc : sampler output to subset.\nwindow : indices of the form start:stop or start:thin:stop can be used to subset iterations, where start and stop define a range for the subset and thin will apply additional thinning to existing sampler output.\nnames : indices for subsetting of parameters that can be specified as strings, integers, or booleans identifying parameters to be kept. ModelChains may additionally be indexed by model node symbols.\nchains : indices for chains can be integers or booleans.\n\nA value of : can be specified for any of the dimensions to indicate no subsetting.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.setindex!","page":"For Developers","title":"Base.setindex!","text":"Base.setindex!(c::AbstractChains, value, iters, names, chains)\n\nStore MCMC sampler output at a given index. The syntax c[i, j, k] = value is converted to setindex!(c, value, i, j, k).\n\nReturns an object of the same type as c with the sampler output stored in the specified indices.\n\nc : object within which to store sampler output.\nvalue : sampler output.\niters : iterations can be indexed as a start:stop or start:thin:stop range, a single numeric index, or a vector of indices; and are taken to be relative to the index range store in the c.range field.\nnames : indices for subsetting of parameters can be specified as strings, integers, or booleans.\nchains : indices for chains can be integers or booleans.\n\nA value of : can be specified for any of the dimensions to indicate no subsetting.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.cat","page":"For Developers","title":"Base.cat","text":"Base.cat(c1::AbstractChains, args::AbstractChains...; dims::Integer)\n\nConcatenate input MCMC chains along a specified dimension. For dimensions other than the specified one, all input chains must have the same sizes, which will also be the sizes of the output chain. The size of the output chain along the specified dimension will be the sum of the sizes of the input chains in that dimension. vcat concatenates vertically along dimension 1, and has the alternative syntax [chain1; chain2; ...]. hcat concatenates horizontally along dimension 2, and has the alternative syntax [chain1 chain2 ...].\n\nReturns a Chains object containing the concatenated input.\n\ndim : dimension (1, 2, or 3) along which to concatenate the input chains.\nc1, args... : Chains to concatenate.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.keys-Tuple{AbstractChains}","page":"For Developers","title":"Base.keys","text":"Base.keys(c::AbstractChains)\n\nReturns names of parameter elements.\n\nc : Chain to return names of.\n\n\n\n\n\n","category":"method"},{"location":"developers/#Base.show-Tuple{IO, AbstractChains}","page":"For Developers","title":"Base.show","text":"Base.show(io::IO, c::AbstractChains)\n\nPrints header and values of Chain.\n\nio : IO stream on which to print.\nAbstractChains : Chain to print.\n\n\n\n\n\n","category":"method"},{"location":"developers/#Base.size","page":"For Developers","title":"Base.size","text":"Base.size(c::AbstractChains)\n\nReturns Tuple containing last iteration of MCMC sampler output and dimensions of Chain dimensions of c.value.\n\nc : Chain object of interest.\n\n\n\n\n\nBase.size(c::AbstractChains, ind)\n\nReturns last iteration of MCMC sampler output, or dimension derived from C, according to value of ind.\n\nc : Chain object of interest.\nind : index of tuple to return; 1 returns last iteration of MCMC sampler output, 2 and 3 return dimensions of c.value.\n\n\n\n\n\n","category":"function"},{"location":"output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"output/#Chains","page":"Output","title":"Chains","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"MCPhylo.Chains","category":"page"},{"location":"output/#MCPhylo.Chains","page":"Output","title":"MCPhylo.Chains","text":"Chains(iters::Integer, params::Integer;\nstart::Integer=1, thin::Integer=1, chains::Integer=1,\nnames::Vector{T}=AbstractString[]) where {T<:AbstractString}\n\n\n\n\n\nChains(value::Array{T, 3},\nstart::Integer=1, thin::Integer=1,\nnames::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])\nwhere {T<:Real, U<:AbstractString, V<:Integer, W <: AbstractString}\n\n\n\n\n\nChains(value::Array{T, 3},\nvalue2::Array{U,3};\nstart::Integer=1, thin::Integer=1,\nnames::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])\nwhere {T<:Real, U<:AbstractString, V<:Integer, W <: AbstractString}\n\n\n\n\n\nChains(value::Matrix{T};\nstart::Integer=1, thin::Integer=1,\nnames::Vector{U}=AbstractString[], chains::Integer=1)\nwhere {T<:Real, U<:AbstractString}\n\n\n\n\n\nChains(value::Vector{T};\nstart::Integer=1, thin::Integer=1,\nnames::U=\"Param1\", chains::Integer=1) where {T<:Real, U <: AbstractString}\n\nConstruct a Chains object that stores MCMC sampler output.\n\nReturns an object of type Chains.\n\niters: total number of iterations in each sampler run, of which length(start:thin:iters) outputted iterations will be stored in the object.\nparams: number of parameters to store.\nvalue: array whose first, second (optional), and third (optional) dimensions index outputted iterations, parameter elements, and runs of an MCMC sampler, respectively.\nstart: number of the first iteration to be stored.\nthin: number of steps between consecutive iterations to be stored.\nchains: number of simulation runs for which to store output, or indices to the runs (default: 1, 2, …).\nnames: names to assign to the parameter elements (default: \"Param1\", \"Param2\", …).\n\n\n\n\n\n","category":"type"},{"location":"output/#File-I/O","page":"Output","title":"File I/O","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Modules = [MCPhylo]\nPages   = [\"fileio.jl\"]\nFilter =","category":"page"},{"location":"output/#Base.read-Union{Tuple{T}, Tuple{AbstractString, Type{T}}} where T<:AbstractChains","page":"Output","title":"Base.read","text":"Base.read(name::AbstractString, ::Type{T}) where {T<:AbstractChains}\n\nRead a chain from an external file.\n\nReturns an AbstractChains subtype read from an external file.\n\nname : file to read or write. Recommended convention is for the file name to be specified with a .jls extension.\nT : chain type to read.\nc : chain to write.\n\n\n\n\n\n","category":"method"},{"location":"output/#Base.write-Tuple{AbstractString, AbstractChains}","page":"Output","title":"Base.write","text":"Base.write(name::AbstractString, c::AbstractChains)\n\nWrite a chain to an external file.\n\nReturns a written external file containing a subtype.\n\nname : file to read or write. Recommended convention is for the file name to be specified with a .jls extension.\nT : chain type to read.\nc : chain to write.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.readcoda-Tuple{AbstractString, AbstractString}","page":"Output","title":"MCPhylo.readcoda","text":"readcoda(output::AbstractString, index::AbstractString)\n\nRead MCMC sampler output generated in the CODA format by OpenBUGS. The function only retains those sampler iterations at which all model parameters were monitored.\n\nReturns a Chains object containing the read sampler output.\n\noutput : text file containing the iteration numbers and sampled values for the model parameters.\nindex : text file containing the names of the parameters, followed by the first and last rows in which their output can be found in the output file.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.to_file-Tuple{ModelChains, AbstractString}","page":"Output","title":"MCPhylo.to_file","text":"to_file(model::ModelChains, outpath::AbstractString)\n\nThis function writes the results of the MCMC runs into files. The destination of the files is specified using outpath. It will create a files for each chain. A params_x.log file storing each parameter sample. In this case x specifies the index of the chain. The file is compatible with MCMC analysis tools like Tracer (http://tree.bio.ed.ac.uk/software/tracer/). If in addition trees are sampled, they are stored in newick format in a file called trees_x.nwk, where x again specifies the index of the respective chain.\n\n\n\n\n\n","category":"method"},{"location":"output/#Discrete-Diagnostics","page":"Output","title":"Discrete Diagnostics","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Modules = [MCPhylo]\nPages   = [\"discretediag.jl\"]\nFilter =","category":"page"},{"location":"output/#MCPhylo.discretediag-Tuple{AbstractChains}","page":"Output","title":"MCPhylo.discretediag","text":"discretediag(c::AbstractChains; frac::Real=0.3,\n              method::Symbol=:weiss, nsim::Int=1000)\n\nCompute the convergence diagnostic for a discrete variable. Several options are available by choosing method to be one of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT. The first four are based off of Pearson’s chi-square test of homogeneity. The diagnostic tests whether the proportion of the categories of the discrete variable are similar in each chain. The last two methods test whether the transition probabilities between each category are similar between each chain. Along with a between chain assessment of convergence, a within-chain assessment is carried out by comparing a specified fraction (frac), or window, of the beginning of a chain to the specified fraction of the end of the chain. For within-chain assessment, users should ensure that there is sufficient separation between the windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.\n\nA ChainSummary type object with parameters contained in the rows of the value field. The first three columns correspond to the test statistic, degrees of freedom, and p-value of the between-chain assessment. The next columns are the test statistic, degrees of freedom, and p-value for each chain of the within-chain assessment.\n\nc : sampler output on which to perform calculations.\nfrac : proportion of iterations to include in the first window.\nmethod : Specify which method to use. One of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT`.\nnsim : For the bootstrap methods (:DARBOOT, :MCBOOT, and :billingsleyBOOT) the number of bootstrap simulations.\n\n\n\n\n\n","category":"method"},{"location":"output/#Gelman-Diagnostic","page":"Output","title":"Gelman Diagnostic","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Modules = [MCPhylo]\nPages   = [\"gelmandiag.jl\"]\nFilter =","category":"page"},{"location":"output/#MCPhylo.gelmandiag-Tuple{AbstractChains}","page":"Output","title":"MCPhylo.gelmandiag","text":"gelmandiag(c::AbstractChains; alpha::Real=0.05, mpsrf::Bool=false,\n            transform::Bool=false)\n\nCompute the convergence diagnostics of Gelman, Rubin, and Brooks for MCMC sampler output. The diagnostics are designed to asses convergence of posterior means estimated with multiple autocorrelated samples (chains). They does so by comparing the between and within-chain variances with metrics called potential scale reduction factors (PSRF). Both univariate and multivariate factors are available to assess the convergence of parameters individually and jointly. Scale factors close to one are indicative of convergence. As a rule of thumb, convergence is concluded if the 0.975 quantile of an estimated factor is less than 1.2. Multiple chains are required for calculations. It is recommended that at least three chains be generated, each with different starting values chosen to be diffuse with respect to the anticipated posterior distribution. Use of multiple chains in the diagnostic provides for more robust assessment of convergence than is possible with single chain diagnostics.\n\nReturns a ChainSummary type object of the form:\n\nstruct ChainSummary\n  value::Array{Float64, 3}\n  rownames::Vector{AbstractString}\n  colnames::Vector{AbstractString}\n  header::AbstractString\nend\n\nwith parameters contained in the rows of the value field, and scale reduction factors and upper-limit quantiles in the first and second columns.\n\nc : sampler output on which to perform calculations.\nalpha : quantile (1 - alpha / 2) at which to estimate the upper limits of scale reduction factors.\nmpsrf : whether to compute the multivariate potential scale reduction factor. This factor will not be calculable if any one of the parameters in the output is a linear combination of others.\ntransform : whether to apply log or logit transformations, as appropriate, to parameters in the chain to potentially produce output that is more normally distributed, an assumption of the PSRF formulations.\n\n\n\n\n\n","category":"method"},{"location":"output/#Geweke-Diagnostic","page":"Output","title":"Geweke Diagnostic","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Main.MCPhylo.gewekediag","category":"page"},{"location":"output/#MCPhylo.gewekediag","page":"Output","title":"MCPhylo.gewekediag","text":"gewekediag(x::Vector{T}; first::Real=0.1, last::Real=0.5,\n            etype=:imse, args...) where {T<:Real}\n\n\n\n\n\ngewekediag(c::AbstractChains; first::Real=0.1, last::Real=0.5,\n            etype=:imse, args...)\n\nCompute the convergence diagnostic of Geweke [37] for MCMC sampler output. The diagnostic is designed to asses convergence of posterior means estimated with autocorrelated samples. It computes a normal-based test statistic comparing the sample means in two windows containing proportions of the first and last iterations. Users should ensure that there is sufficient separation between the two windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and test Z-scores and p-values in the first and second columns. Results are chain-specific.\n\nc : sampler output on which to perform calculations.\nfirst : proportion of iterations to include in the first window.\nlast : proportion of iterations to include in the last window.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\nx : vector on which to perform calculations.\n\n\n\n\n\n","category":"function"},{"location":"output/#Heidel-Diagnostic","page":"Output","title":"Heidel Diagnostic","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"MCPhylo.heideldiag","category":"page"},{"location":"output/#MCPhylo.heideldiag","page":"Output","title":"MCPhylo.heideldiag","text":"heideldiag(x::Vector{T}; alpha::Real=0.05, eps::Real=0.1,\n            etype=:imse, start::Integer=1, args...) where {T<:Real}\n\n\n\n\n\nheideldiag(c::AbstractChains; alpha::Real=0.05, eps::Real=0.1,\n            etype=:imse, args...)\n\nCompute the convergence diagnostic of Heidelberger and Welch for MCMC sampler output. The diagnostic is designed to assess convergence of posterior means estimated with autocorrelated samples and to determine whether a target degree of accuracy is achieved. A stationarity test is performed for convergence assessment by iteratively discarding 10% of the initial samples until the test p-value is non-significant and stationarity is concluded or until 50% have been discarded and stationarity is rejected, whichever occurs first. Then, a halfwidth test is performed by calculating the relative halfwidth of a posterior mean estimation interval as z_1 - alpha  2 hats  bartheta; where z is a standard normal quantile, hats is the Monte Carlo standard error, and bartheta is the estimated posterior mean. If the relative halfwidth is greater than a target ratio, the test is rejected. Rejection of the stationarity or halfwidth test suggests that additional samples are needed.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and numbers of burn-in sequences to discard, whether the stationarity tests are passed (1 = yes, 0 = no), their p-values (p  alpha implies stationarity), posterior means, halfwidths of their (1 - alpha) 100 estimation intervals, and whether the halfwidth tests are passed (1 = yes, 0 = no) in the columns. Results are chain-specific.\n\nc : sampler output on which to perform calculations.\nalpha : significance level for evaluations of stationarity tests and calculations of relative estimation interval halfwidths.\neps : target ratio for the relative halfwidths.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\nx : vector on which to perform calculations.\nstart : ??\n\n\n\n\n\n","category":"function"},{"location":"output/#Raftery-and-Lewis-Diagnostic","page":"Output","title":"Raftery and Lewis Diagnostic","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"MCPhylo.rafterydiag","category":"page"},{"location":"output/#MCPhylo.rafterydiag","page":"Output","title":"MCPhylo.rafterydiag","text":"rafterydiag(x::Vector{T}; q::Real=0.025, r::Real=0.005,\n                  s::Real=0.95, eps::Real=0.001,\n                  range::AbstractRange=1:1:length(x)) where {T<:Real}\n\n\n\n\n\nrafterydiag(c::AbstractChains; q::Real=0.025, r::Real=0.005,\n                 s::Real=0.95, eps::Real=0.001)\n\nCompute the convergence diagnostic of Raftery and Lewis for MCMC sampler output. The diagnostic is designed to determine the number of autocorrelated samples required to estimate a specified quantile theta_q, such that Pr(theta le theta_q) = q, within a desired degree of accuracy. In particular, if hattheta_q is the estimand and Pr(theta le hattheta_q) = hatP_q the estimated cumulative probability, then accuracy is specified in terms of r and s, where Pr(q - r  hatP_q  q + r) = s. Thinning may be employed in the calculation of the diagnostic to satisfy its underlying assumptions. However, users may not want to apply the same (or any) thinning when estimating posterior summary statistics because doing so results in a loss of information. Accordingly, sample sizes estimated by the diagnostic tend to be conservative (too large).\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and thinning intervals employed, numbers of samples to discard as burn-in sequences, total numbers (N) to burn-in and retain, numbers of independent samples that would be needed (Nmin), and dependence factors (N  Nmin) in the columns. Results are chain-specific.\n\nc : sampler output on which to perform calculations.\nq : posterior quantile of interest.\nr : margin of error for estimated cumulative probabilities.\ns : probability for the margin of error.\neps : tolerance within which the probabilities of transitioning from initial to retained iterations are within the equilibrium probabilities for the chain. This argument determines the number of samples to discard as a burn-in sequence and is typically left at its default value.\nx : vector on which to perform calculations.\nrange : ??\n\n\n\n\n\n","category":"function"},{"location":"output/#Average-Standard-Deviation-of-Split-Frequencies","page":"Output","title":"Average Standard Deviation of Split Frequencies","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"MCPhylo.ASDSF","category":"page"},{"location":"output/#MCPhylo.ASDSF","page":"Output","title":"MCPhylo.ASDSF","text":"ASDSF(args::String...; freq::Int64=1, check_leaves::Bool=true,\n      min_splits::Float64=0.1, show_progress::Bool=true)::Vector{Float64}\n\nCalculate the average standard deviation of split frequencies for two or more files containing newick representations of trees. Default frequency is 1 and by default only trees with the same leafsets are supported. The default minimal splits threshold is 0.1. The progress bar is activated by default.\n\n\n\n\n\nASDSF(args::Vector{String}...; freq::Int64=1, check_leaves::Bool=true,\n      min_splits::Float64=0.1, show_progress::Bool=true)::Vector{Float64}\n\nCalculate the average standard deviation of split frequencies for two or more Vectors containing newick representations of trees. Default frequency is 1 and by default only trees with the same leafsets are supported. The default minimal splits threshold is 0.1. The progress bar is activated by default.\n\n\n\n\n\nASDSF(model::ModelChains; freq::Int64=1, check_leaves::Bool=true,\n      min_splits::Float64=0.1, show_progress::Bool=true\n      )::Vector{Vector{Float64}}\n\nCalculate the average standard deviation of split frequencies for the trees in different chains in a ModelChains object. Default frequency is 1 and by default only trees with the same leafsets are supported. The default minimal splits threshold is 0.1. The progress bar is activated by default.\n\n\n\n\n\nASDSF(r_channels::Vector{RemoteChannel}, n_trees::Int64,\n      tree_dims::UnitRange{Int64}, min_splits::Float64\n      )::Tuple{Vector{Vector{Float64}}, ConvergenceStorage}\n\n–- INTERNAL –- Calculates - on-the-fly - the average standard deviation of split frequencies for the trees generated by MCMC draws from a model. Takes a vector of remote channels (where the generated trees are stored during the mcmc simulation) and the total number of trees in each chain as arguments. The default minimal splits threshold is 0.1.\n\n\n\n\n\n","category":"function"},{"location":"output/#Monte-Carlo-Standard-Errors","page":"Output","title":"Monte Carlo Standard Errors","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"MCPhylo.mcse","category":"page"},{"location":"output/#MCPhylo.mcse","page":"Output","title":"MCPhylo.mcse","text":"mcse(x::Vector{T}, method::Symbol=:imse; args...) where {T<:Real}\n\nCompute Monte Carlo standard errors.\n\nReturns the numeric standard error value.\n\nx : time series of values on which to perform calculations.\nmethod : method used for the calculations. Options are\n:bm : batch means, with optional argument size::Integer=100 determining the number of sequential values to include in each batch. This method requires that the number of values in x is at least 2 times the batch size.\n:imse : initial monotone sequence estimator.\n:ipse : initial positive sequence estimator.\nargs... : additional arguments for the calculation method.\n\n\n\n\n\n","category":"function"},{"location":"output/#ModelChains","page":"Output","title":"ModelChains","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"MCPhylo.ModelChains","category":"page"},{"location":"output/#MCPhylo.ModelChains","page":"Output","title":"MCPhylo.ModelChains","text":"ModelChains(c::Chains, m::Model)\n\nSee Chains().\n\n\n\n\n\n","category":"type"},{"location":"output/#Model-Based-Inference","page":"Output","title":"Model-Based Inference","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Modules = [MCPhylo]\nPages   = [\"modelstats.jl\"]\nFilter =","category":"page"},{"location":"output/#Distributions.logpdf","page":"Output","title":"Distributions.logpdf","text":"logpdf(mc::ModelChains,\n       nodekeys::Vector{Symbol}=keys(mc.model, :stochastic))\n\n\n\n\n\n","category":"function"},{"location":"output/#Distributions.logpdf-Tuple{ModelChains, Function, Vector{Symbol}}","page":"Output","title":"Distributions.logpdf","text":"logpdf(mc::ModelChains, f::Function, nodekeys::Vector{Symbol})\n\nCompute the sum of log-densities at each iteration of MCMC output for stochastic nodes.\n\nReturns a ModelChains object of resulting summed log-densities at each MCMC iteration of the supplied chain.\n\nmc : sampler output from a model fit with the mcmc()` function.\nnodekey/nodekeys : stochastic model node(s) over which to sum densities (default: all).\nf : ??\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.dic-Tuple{ModelChains}","page":"Output","title":"MCPhylo.dic","text":"dic(mc::ModelChains)\n\nCompute the Deviance Information Criterion (DIC) of Spiegelhalter et al. and Gelman et al. from MCMC sampler output.\n\nReturns a ChainSummary type object with DIC results from the methods of Spiegelhalter and Gelman in the first and second rows of the value field, and the DIC value and effective numbers of parameters in the first and second columns; where\n\ntextDIC = -2 mathcalL(barTheta) + 2 p\n\nsuch that mathcalL(barTheta) is the log-likelihood of model outputs given the expected values of model parameters Theta, and p is the effective number of parameters. The latter is defined as p_D = -2 barmathcalL(Theta) + 2 mathcalL(barTheta) for the method of Spiegelhalter and as p_V = frac12 operatornamevar(-2 mathcalL(Theta)) for the method of Gelman. Results are for all chains combined.\n\nmc : sampler output from a model fit with the mcmc() function.\n\n\n\n\n\n","category":"method"},{"location":"output/#StatsAPI.predict","page":"Output","title":"StatsAPI.predict","text":"predict(mc::ModelChains,\n         nodekeys::Vector{Symbol}=keys(mc.model, :output))\n\nGenerate MCMC draws from a posterior predictive distribution.\n\nReturns a ModelChains object of draws simulated at each MCMC iteration of the supplied chain. For observed data node y, simulation is from the posterior predictive distribution\n\np(tildey  y) = int p(tildey  Theta) p(Theta  y) dTheta\n\nwhere tildey is an unknown observation on the node, p(tildey  Theta) is the data likelihood, and p(Theta  y) is the posterior distribution of unobserved parameters Theta.\n\nmc : sampler output from a model fit with the mcmc()` function.\nnodekey/nodekeys : observed Stochastic model node(s) for which to generate draws from the predictive distribution (default: all observed data nodes).\n\n\n\n\n\n","category":"function"},{"location":"output/#Plot","page":"Output","title":"Plot","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Modules = [MCPhylo]\nPages   = [\"plot.jl\"]\nFilter =","category":"page"},{"location":"output/#MCPhylo.bar_int-Tuple{AbstractChains, Vector{Int64}}","page":"Output","title":"MCPhylo.bar_int","text":"bar_int(c::AbstractChains, indeces::Vector{Int64}; args...)::Plots.Plot\n\n–- INTERNAL –- Helper function for creating barplots.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.check_filename-Tuple{Any, Any, Any}","page":"Output","title":"MCPhylo.check_filename","text":"check_filename(filename, fmt, plots)\n\n–- INTERNAL –- Helper function that checks if a user-given filename is valid, and saves the created plots to that file.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.check_vars-Tuple{Vector{AbstractString}, Vector{String}}","page":"Output","title":"MCPhylo.check_vars","text":"checkvars(simnames::Vector{AbstractString},              vars::Vector{String})::Vector{Int64}\n\n–- INTERNAL –- Helper function that returns a list of indeces that correspond to specific variables. Only those variables are then plotted in the following steps.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.groupedbar_fillrange-Tuple{Any}","page":"Output","title":"MCPhylo.groupedbar_fillrange","text":"groupedbar_fillrange(y)\n\n–- INTERNAL –- Helper function for the groupbar plot\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.mixeddensityplot-Tuple{AbstractChains, Vector{Int64}}","page":"Output","title":"MCPhylo.mixeddensityplot","text":"mixeddensityplot(c::AbstractChains,, indeces::Vector{Int64};\n                 barbounds::Tuple{Real, Real}=(0, Inf), args...):Plots.Plot\n\n–- INTERNAL –- Helper function that creates a barplot for each discrete and a density for each continuous variable.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.plot_asdsf-Tuple{AbstractChains}","page":"Output","title":"MCPhylo.plot_asdsf","text":"plot_asdsf(c::AbstractChains; args...)::Plots.Plot\n\n–- INTERNAL –- Plot the ASDSF values of an Abstract Chains object.\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.ASDSF_trace}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(vals::ASDSF_trace)\n\n–- INTERNAL –- Recipe for trace plots of ASDSF values\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Autocor}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(acor::Autocor)\n\n–- INTERNAL –- Recipe for Autocor plots\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Contour}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(cont::Contour)\n\n–- INTERNAL –- Recipe for contour plots\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Density}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(dens::Density)\n\n–- INTERNAL –- Recipe for density plots\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.GroupBar}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(g::GroupBar; spacing=0)\n\n–- INTERNAL –- Recipe for a grouped bar plot.\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Mean}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(mean::Mean)\n\n–- INTERNAL –- Recipe for mean plots\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Trace}","page":"Output","title":"RecipesBase.apply_recipe","text":"f(trace::Trace)\n\n–- INTERNAL –- Recipe for trace plots\n\n\n\n\n\n","category":"method"},{"location":"output/#RecipesBase.plot","page":"Output","title":"RecipesBase.plot","text":"plot(c::AbstractChains, ptype::Vector{Symbol}=[:trace, :density];\n   <keyword arguments>)::Array{Plots.Plot}\n\nFunction that takes a MCMC chain and creates various different plots (trace & density by default).\n\nArguments\n\n'vars::Vector{String}=String[]': specifies the variables of the chain that                                  are plotted. Trick: Instead of inputting                                  [varname[1], varname[2], varname[3], ...]                                  you can simply write [varname]. The function                                  will understand that you want all variables                                  with that name.\n'filename::String=\"\"': when given, the plots will be saved to a file\n'fmt::Symbol=:pdf': Format of the output file\n'fuse::Bool=false': Fuse all of the plots into one big plot, instead of                     displaying each of the different plot types separately\n'f_layout=nothing': Layout for the fused plot.\n'fsize::Tuple(Number, Number)=(0,0)': Size of the fused plot.\n'force::Bool=false': Force plotting of more than 20 variables.\n'args...': This includes specific arguments for the different plot types            , like the number of bins for the contourplot or if the barplots            bars should be stacked or not. Check the specific plot functions            to use these arguments.\n      Plot attributes from the Plots.jl package can also be passed here:\n      I.e. try passing background_color=:black for a black background on\n      your plots. List of attributes here,\n      https://docs.juliaplots.org/latest/generated/attributes_series/\n      https://docs.juliaplots.org/latest/generated/attributes_plot/\n      https://docs.juliaplots.org/latest/generated/attributes_subplot/\n      https://docs.juliaplots.org/latest/generated/attributes_axis/\n      though not all are supported:\n      https://docs.juliaplots.org/latest/generated/supported/\n\n\n\n\n\n","category":"function"},{"location":"output/#Posterior-Summary-Statistics","page":"Output","title":"Posterior Summary Statistics","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Modules = [MCPhylo]\nPages   = [\"stats.jl\"]\nFilter =","category":"page"},{"location":"output/#DataAPI.describe-Tuple{IO, AbstractChains}","page":"Output","title":"DataAPI.describe","text":"describe(io::IO, c::AbstractChains;\n              q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975], etype=:bm, args...)\n\nCompute summary statistics for MCMC sampler output.\n\nReturns results from calls to summarystats(c, etype, args...) and quantile(c, q) are printed for all chains combined, and a value of nothing is returned.\n\nc : sampler output on which to perform calculations.\nq : probabilities at which to calculate quantiles.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.changerate-Tuple{AbstractChains}","page":"Output","title":"MCPhylo.changerate","text":"changerate(c::AbstractChains)\n\nEstimate the probability, or rate per iteration, Pr(theta^i ne theta^i-1) of a state space change for iterations i = 2 ldots N in MCMC sampler output. Estimation is performed for each parameter univariately as well as for the full parameter vector multivariately. For continuous output generated from samplers, like Metropolis-Hastings, whose algorithms conditionally accept candidate draws, the probability can be viewed as the acceptance rate.\n\nReturns a ChainSummary type object with parameters in the rows of the value field, and the estimated rates in the column. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.hpd-Tuple{AbstractChains}","page":"Output","title":"MCPhylo.hpd","text":"hpd(c::AbstractChains; alpha::Real=0.05)\n\n\n\n\n\n","category":"method"},{"location":"output/#MCPhylo.hpd-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Real","page":"Output","title":"MCPhylo.hpd","text":"hpd(x::Vector{T}; alpha::Real=0.05) where {T<:Real}\n\nCompute highest posterior density (HPD) intervals of Chen and Shao [16] for MCMC sampler output. HPD intervals have the desirable property of being the smallest intervals that contain a given probability. However, their calculation assumes unimodal marginal posterior distributions, and they are not invariant to transformations of parameters like central (quantile-based) posterior intervals.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and lower and upper intervals in the first and second columns. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\nalpha : the 100 * (1 - alpha)% interval to compute.\nx : vector on which to perform calculations.\n\n\n\n\n\n","category":"method"},{"location":"output/#Statistics.cor-Tuple{AbstractChains}","page":"Output","title":"Statistics.cor","text":"cor(c::AbstractChains)\n\nCompute cross-correlations for MCMC sampler output.\n\nReturns a ChainSummary type object with the first and second dimensions of the value field indexing the model parameters between which correlations. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\n\n\n\n\n\n","category":"method"},{"location":"output/#Statistics.quantile-Tuple{AbstractChains}","page":"Output","title":"Statistics.quantile","text":"quantile(c::AbstractChains; q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975])\n\nCompute posterior quantiles for MCMC sampler output.\n\nReturns a ChainSummary type object with parameters contained in the rows of the value field, and quantiles in the columns. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\nq : probabilities at which to compute quantiles.\n\n\n\n\n\n","category":"method"},{"location":"output/#StatsBase.autocor-Tuple{AbstractChains}","page":"Output","title":"StatsBase.autocor","text":"autocor(c::AbstractChains; lags::Vector=[1, 5, 10, 50],\n         relative::Bool=true)\n\nCompute lag-k autocorrelations for MCMC sampler output.\n\nReturns a ChainSummary type object with model parameters indexed by the first dimension of value, lag-autocorrelations by the second, and chains by the third.\n\nc : sampler output on which to perform calculations.\nlags : lags at which to compute autocorrelations.\nrelative : whether the lags are relative to the thinning interval of the output (true) or relative to the absolute iteration numbers (false).\n\n\n\n\n\n","category":"method"},{"location":"output/#StatsBase.summarystats-Tuple{AbstractChains}","page":"Output","title":"StatsBase.summarystats","text":"summarystats(c::AbstractChains; etype=:bm, args...)\n\nCompute posterior summary statistics for MCMC sampler output.\n\nReturns a ChainSummary type object with parameters in the rows of the value field; and the sample mean, standard deviation, standard error, Monte Carlo standard error, and effective sample size in the columns. Results are for all chains combined.\n\nc : sampler output on which to perform calculations.\netype : method for computing Monte Carlo standard errors. See mcse() for options.\nargs... : additional arguments to be passed to the etype method.\n\n\n\n\n\n","category":"method"}]
}
