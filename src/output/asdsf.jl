"""
    ASDSF(args::String...; freq::Int64=1, check_leaves::Bool=true,
          min_splits::Float64=0.1, show_progress::Bool=true)::Vector{Float64}

Calculate the average standard deviation of split frequencies for two or more
files containing newick representations of trees. Default frequency is 1 and
by default only trees with the same leafsets are supported. The default minimal
splits threshold is 0.1. The progress bar is activated by default.
"""
function ASDSF(args::String...; freq::Int64=1, check_leaves::Bool=true,
               min_splits::Float64=0.1, show_progress::Bool=true
               )#::Vector{Float64}

    length(args) < 2 && throw(ArgumentError("At least two input files are needed."))
    splitsQueue = [Accumulator{BitVector, Int64}()]
    splitsQueues = [Vector{Accumulator{BitVector, Int64}}()]
    for arg in args
        push!(splitsQueues[1], Accumulator{Tuple{Set{String}, Set{String}}, Int64}())
    end # for
    cv = ConvergenceStorage(splitsQueue, splitsQueues)
    iter = zip([eachline(arg) for arg in args]...)
    nsams = countlines(args[1]) / freq
    asdsf_size = ceil(Int,nsams)
    

    # tree_dims is hardcoded to 1 because there are no multiple dims in files
    ASDSF_int!(cv, iter, 1, freq, check_leaves,
              min_splits, show_progress, basic=true)
    res = cv.ASDSF_vals
    asdsf_size > nsams ? res[1:end-1] : res
end # ASDSF


"""
    ASDSF(args::Vector{String}...; freq::Int64=1, check_leaves::Bool=true,
          min_splits::Float64=0.1, show_progress::Bool=true)::Vector{Float64}

Calculate the average standard deviation of split frequencies for two or more
Vectors containing newick representations of trees. Default frequency is 1 and
by default only trees with the same leafsets are supported. The default minimal
splits threshold is 0.1. The progress bar is activated by default.
"""
function ASDSF(args::Vector{String}...; freq::Int64=1, check_leaves::Bool=true,
               min_splits::Float64=0.1, show_progress::Bool=true
               )::Vector{Float64}

    length(args) < 2 && throw(ArgumentError("At least two input arrays are needed."))
    splitsQueue = [Accumulator{BitVector, Int64}()]
    splitsQueues = [Vector{Accumulator{BitVector, Int64}}()]
    for arg in args
        push!(splitsQueues[1], Accumulator{Tuple{Set{String}, Set{String}}, Int64}())
    end # for
    cv = ConvergenceStorage(splitsQueue, splitsQueues)
    iter = zip(args...)
    
    # tree_dims is hardcoded to 1 because there are no multiple dims in Vectors
    ASDSF_int!(cv, iter, 1, freq, check_leaves,
              min_splits, show_progress; basic=true)
    return cv.ASDSF_vals
end # ASDSF


"""
    ASDSF(model::ModelChains; freq::Int64=1, check_leaves::Bool=true,
          min_splits::Float64=0.1, show_progress::Bool=true
          )::Vector{Vector{Float64}}

Calculate the average standard deviation of split frequencies for the trees in
different chains in a ModelChains object. Default frequency is 1 and by default
only trees with the same leafsets are supported. The default minimal splits
threshold is 0.1. The progress bar is activated by default.
"""
function ASDSF(model::ModelChains; freq::Int64=1, check_leaves::Bool=true,
               min_splits::Float64=0.1, show_progress::Bool=true
               )::Vector{Vector{Float64}}
               
    tree_dims::UnitRange{Int64} = 1:size(model.trees, 2)
    splitsQueue = [Accumulator{BitVector, Int64}() for x in tree_dims]
    splitsQueues = [Vector{Accumulator{BitVector, Int64}}() for x in tree_dims]
    nchains = size(model.trees, 3)
    for i in 1:nchains
        for j in tree_dims
            push!(splitsQueues[j], Accumulator{BitVector, Int64}())
        end # for
    end # for
    trees = Array{Vector{AbstractString}, 2}(undef, size(model.trees, 1), nchains)
    #if length(tree_dims) > 1
    @inbounds for i in 1:size(model.trees, 1), j in 1:nchains
        trees[i, j] = model.trees[i,:,j]
    end # for
    #end # if
    iter = zip([trees[:,c] for c in 1:nchains]...)
    #ASDSF_vals::Vector{Vector{Float64}} = [zeros(Int(floor(length(iter) / freq))) for x in tree_dims]
    cv = ConvergenceStorage(splitsQueue, splitsQueues)
    ASDSF_int!(cv, iter, tree_dims, freq,
              check_leaves, min_splits, show_progress)
    cv.ASDSF_vals
end # ASDSF


"""
    ASDSF(r_channels::Vector{RemoteChannel}, n_trees::Int64,
          tree_dims::UnitRange{Int64}, min_splits::Float64
          )::Tuple{Vector{Vector{Float64}}, ConvergenceStorage}

--- INTERNAL ---
Calculates - on-the-fly - the average standard deviation of split frequencies
for the trees generated by MCMC draws from a model. Takes a vector of remote
channels (where the generated trees are stored during the mcmc simulation) and
the total number of trees in each chain as arguments. The default minimal splits
threshold is 0.1.
"""
function ASDSF(r_channels::Vector{RemoteChannel{Channel{Array{AbstractString,1}}}},
               n_trees::Int64, tree_dims::UnitRange{Int64}, min_splits::Float64;
               cs::Union{Nothing, ConvergenceStorage}=nothing
               )::Tuple{Vector{Vector{Float64}}, ConvergenceStorage}

    iter = 1:n_trees
    nchains = length(r_channels)
    if isnothing(cs)
        splitsQueue = [Accumulator{BitVector, Int64}() for x in tree_dims]
        splitsQueues = [Vector{Accumulator{BitVector, Int64}}() for x in tree_dims]
        for i in 1:nchains
            for j in tree_dims
                push!(splitsQueues[j], Accumulator{BitVector, Int64}())
            end # for
        end # for
        cv = ConvergenceStorage(splitsQueue, splitsQueues)
        ASDSF_int!(cv, iter, tree_dims,1, false,
                  min_splits, false; r_channels=r_channels)
        return cv.ASDSF_vals, cv
    else
        ASDSF_int!(cs, iter, tree_dims, 1,
                  false, min_splits, false; r_channels=r_channels)
        
        return cs.ASDSF_vals, cs
    end # if/else
end # ASDSF


"""
    ASDSF_int(splitsQueue, splitsQueues, iter, tree_dims, ASDSF_vals, freq,
              check_leaves, min_splits, show_progress; r_channels=nothing,
              run::Int64=1, basic=false
              )::Tuple{Vector{Vector{Float64}}, ConvergenceStorage}

--- INTERNAL ---
Handles the computation of the Average Standard Deviation of Split Frequencies.
"""
function ASDSF_int!(conv_store, iter, tree_dims, freq,
                   check_leaves, min_splits, show_progress; r_channels=nothing,
                    basic=false
                   )::Nothing#Tuple{Vector{Vector{Float64}}, ConvergenceStorage}

    all_keys = [Set{BitVector}() for x in tree_dims]
    
    if show_progress
        prog = ProgressMeter.Progress(length(conv_store.ASDSF_vals[1]),"Computing ASDSF: ")
    end # if
    
    n_chains = size(conv_store.splitsQueues[1], 1)
    for (i, line) in enumerate(iter)
        if mod(i, freq) == 0
            if !isnothing(r_channels)
                line = [take!(rc) for rc in r_channels]
            end
            for td in tree_dims
                trees = basic ? [ParseNewick(tree) for tree in line] :
                                [ParseNewick(tree[td]) for tree in line]
                check_leaves && check_leafsets(trees)

                # get all bipartitions
                cmds = Accumulator.(countmap.(filter.(x->sum(x) > 1, MCPhyloTree.get_bipartitions_as_bitvectors.(trees))))
                
                for (ind,acc) in enumerate(cmds)
                    merge!(conv_store.splitsQueues[td][ind], acc)
                end
                new_splits = merge(cmds...)
                
                all_keys[td] = union(all_keys[td], keys(new_splits))
                merge!(conv_store.splitsQueue[td], new_splits)
                conv_store.n_tree_gens += 1
                tmp = 0.0
                M = 0.0
                for split in all_keys[td]
                    tmp_i = 0.0
                    keep = false
                    ova = conv_store.splitsQueue[td][split]/(n_chains*conv_store.n_tree_gens)
                    for chain in conv_store.splitsQueues[td]
                        fi = chain[split]/conv_store.n_tree_gens 
                        keep |= fi > min_splits
                        tmp_i += (fi - ova) ^ 2
                    end
                    
                    tmp_i /= (n_chains - 1)
                    tmp += keep ? sqrt(tmp_i) : 0.0
                    M += keep ? 1 : 0    
                end
                push!(conv_store.ASDSF_vals[td],  tmp / M )

            end # for
            
            show_progress && ProgressMeter.next!(prog)
        end # if
    end # for
    show_progress && ProgressMeter.finish!(prog)
    #conv_storage = ConvergenceStorage(splitsQueue, splitsQueues, total_runs, ASDSF_vals)
    #conv_store.ASDSF_vals, conv_store
    nothing
end # ASDSF_int
