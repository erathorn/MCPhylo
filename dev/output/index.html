<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Output · MCPhylo.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCPhylo.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../likelihood/">Likelihood</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../model/">Model</a></li><li class="is-active"><a class="tocitem" href>Output</a><ul class="internal"><li><a class="tocitem" href="#Chains"><span>Chains</span></a></li><li><a class="tocitem" href="#File-I/O"><span>File I/O</span></a></li><li><a class="tocitem" href="#Discrete-Diagnostics"><span>Discrete Diagnostics</span></a></li><li><a class="tocitem" href="#Gelman-Diagnostic"><span>Gelman Diagnostic</span></a></li><li><a class="tocitem" href="#Geweke-Diagnostic"><span>Geweke Diagnostic</span></a></li><li><a class="tocitem" href="#Heidel-Diagnostic"><span>Heidel Diagnostic</span></a></li><li><a class="tocitem" href="#Raftery-and-Lewis-Diagnostic"><span>Raftery and Lewis Diagnostic</span></a></li><li><a class="tocitem" href="#Average-Standard-Deviation-of-Split-Frequencies"><span>Average Standard Deviation of Split Frequencies</span></a></li><li><a class="tocitem" href="#Monte-Carlo-Standard-Errors"><span>Monte Carlo Standard Errors</span></a></li><li><a class="tocitem" href="#ModelChains"><span>ModelChains</span></a></li><li><a class="tocitem" href="#Model-Based-Inference"><span>Model-Based Inference</span></a></li><li><a class="tocitem" href="#Plot"><span>Plot</span></a></li><li><a class="tocitem" href="#Posterior-Summary-Statistics"><span>Posterior Summary Statistics</span></a></li></ul></li><li><a class="tocitem" href="../samplers/">Samplers</a></li><li><a class="tocitem" href="../utils/">Utils</a></li><li><a class="tocitem" href="../links/">Links</a></li><li><a class="tocitem" href="../developers/">For Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Output</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Output</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/MCPhylo.jl/blob/master/docs/src/output.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h1><h2 id="Chains"><a class="docs-heading-anchor" href="#Chains">Chains</a><a id="Chains-1"></a><a class="docs-heading-anchor-permalink" href="#Chains" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.Chains" href="#MCPhylo.Chains"><code>MCPhylo.Chains</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Chains(iters::Integer, params::Integer;
start::Integer=1, thin::Integer=1, chains::Integer=1,
names::Vector{T}=AbstractString[]) where {T&lt;:AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/chains.jl#L4-L8">source</a></section><section><div><pre><code class="nohighlight hljs">Chains(value::Array{T, 3},
start::Integer=1, thin::Integer=1,
names::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])
where {T&lt;:Real, U&lt;:AbstractString, V&lt;:Integer, W &lt;: AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/chains.jl#L33-L38">source</a></section><section><div><pre><code class="nohighlight hljs">Chains(value::Array{T, 3},
value2::Array{U,3};
start::Integer=1, thin::Integer=1,
names::Vector{W}=AbstractString[], chains::Vector{V}=Int[], moves::Vector{V}=Int[0])
where {T&lt;:Real, U&lt;:AbstractString, V&lt;:Integer, W &lt;: AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/chains.jl#L55-L61">source</a></section><section><div><pre><code class="nohighlight hljs">Chains(value::Matrix{T};
start::Integer=1, thin::Integer=1,
names::Vector{U}=AbstractString[], chains::Integer=1)
where {T&lt;:Real, U&lt;:AbstractString}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/chains.jl#L95-L100">source</a></section><section><div><pre><code class="nohighlight hljs">Chains(value::Vector{T};
start::Integer=1, thin::Integer=1,
names::U=&quot;Param1&quot;, chains::Integer=1) where {T&lt;:Real, U &lt;: AbstractString}</code></pre><p>Construct a <code>Chains</code> object that stores MCMC sampler output.</p><p>Returns an object of type <code>Chains</code>.</p><ul><li><p><code>iters</code>: total number of iterations in each sampler run, of which <code>length(start:thin:iters)</code> outputted iterations will be stored in the object.</p></li><li><p><code>params</code>: number of parameters to store.</p></li><li><p><code>value</code>: array whose first, second (optional), and third (optional) dimensions index outputted iterations, parameter elements, and runs of an MCMC sampler, respectively.</p></li><li><p><code>start</code>: number of the first iteration to be stored.</p></li><li><p><code>thin</code>: number of steps between consecutive iterations to be stored.</p></li><li><p><code>chains</code>: number of simulation runs for which to store output, or indices to the runs (default: 1, 2, …).</p></li><li><p><code>names</code>: names to assign to the parameter elements (default: <code>&quot;Param1&quot;</code>, <code>&quot;Param2&quot;</code>, …).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/chains.jl#L119-L141">source</a></section></article><h2 id="File-I/O"><a class="docs-heading-anchor" href="#File-I/O">File I/O</a><a id="File-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#File-I/O" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.read-Union{Tuple{T}, Tuple{AbstractString, Type{T}}} where T&lt;:AbstractChains" href="#Base.read-Union{Tuple{T}, Tuple{AbstractString, Type{T}}} where T&lt;:AbstractChains"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.read(name::AbstractString, ::Type{T}) where {T&lt;:AbstractChains}</code></pre><p>Read a chain from an external file.</p><p>Returns an <code>AbstractChains</code> subtype read from an external file.</p><ul><li><p><code>name</code> : file to read or write. Recommended convention is for the file name to be specified with a <code>.jls</code> extension.</p></li><li><p><code>T</code> : chain type to read.</p></li><li><p><code>c</code> : chain to write.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/fileio.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{AbstractString, AbstractChains}" href="#Base.write-Tuple{AbstractString, AbstractChains}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.write(name::AbstractString, c::AbstractChains)</code></pre><p>Write a chain to an external file.</p><p>Returns a written external file containing a subtype.</p><ul><li><p><code>name</code> : file to read or write. Recommended convention is for the file name to be specified with a <code>.jls</code> extension.</p></li><li><p><code>T</code> : chain type to read.</p></li><li><p><code>c</code> : chain to write.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/fileio.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.readcoda-Tuple{AbstractString, AbstractString}" href="#MCPhylo.readcoda-Tuple{AbstractString, AbstractString}"><code>MCPhylo.readcoda</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readcoda(output::AbstractString, index::AbstractString)</code></pre><p>Read MCMC sampler output generated in the CODA format by OpenBUGS. The function only retains those sampler iterations at which all model parameters were monitored.</p><p>Returns a <code>Chains</code> object containing the read sampler output.</p><ul><li><p><code>output</code> : text file containing the iteration numbers and sampled values for the model parameters.</p></li><li><p><code>index</code> : text file containing the names of the parameters, followed by the first and last rows in which their output can be found in the <code>output</code> file.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/fileio.jl#L37-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.to_file-Tuple{ModelChains, AbstractString}" href="#MCPhylo.to_file-Tuple{ModelChains, AbstractString}"><code>MCPhylo.to_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_file(model::ModelChains, outpath::AbstractString)</code></pre><p>This function writes the results of the MCMC runs into files. The destination of the files is specified using <code>outpath</code>. It will create a files for each chain. A <code>params_x.log</code> file storing each parameter sample. In this case <code>x</code> specifies the index of the chain. The file is compatible with MCMC analysis tools like <code>Tracer</code> (http://tree.bio.ed.ac.uk/software/tracer/). If in addition trees are sampled, they are stored in newick format in a file called <code>trees_x.nwk</code>, where <code>x</code> again specifies the index of the respective chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/fileio.jl#L76-L85">source</a></section></article><h2 id="Discrete-Diagnostics"><a class="docs-heading-anchor" href="#Discrete-Diagnostics">Discrete Diagnostics</a><a id="Discrete-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.discretediag-Tuple{AbstractChains}" href="#MCPhylo.discretediag-Tuple{AbstractChains}"><code>MCPhylo.discretediag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discretediag(c::AbstractChains; frac::Real=0.3,
              method::Symbol=:weiss, nsim::Int=1000)</code></pre><p>Compute the convergence diagnostic for a discrete variable. Several options are available by choosing method to be one of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT. The first four are based off of Pearson’s chi-square test of homogeneity. The diagnostic tests whether the proportion of the categories of the discrete variable are similar in each chain. The last two methods test whether the transition probabilities between each category are similar between each chain. Along with a between chain assessment of convergence, a within-chain assessment is carried out by comparing a specified fraction (frac), or window, of the beginning of a chain to the specified fraction of the end of the chain. For within-chain assessment, users should ensure that there is sufficient separation between the windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.</p><p>A <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field. The first three columns correspond to the test statistic, degrees of freedom, and p-value of the between-chain assessment. The next columns are the test statistic, degrees of freedom, and p-value for each chain of the within-chain assessment.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>frac</code> : proportion of iterations to include in the first window.</p></li><li><p><code>method</code> : Specify which method to use. One of :hangartner, :weiss, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT`.</p></li><li><p><code>nsim</code> : For the bootstrap methods (:DARBOOT, :MCBOOT, and :billingsleyBOOT) the number of bootstrap simulations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/discretediag.jl#L437-L452">source</a></section></article><h2 id="Gelman-Diagnostic"><a class="docs-heading-anchor" href="#Gelman-Diagnostic">Gelman Diagnostic</a><a id="Gelman-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Gelman-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.gelmandiag-Tuple{AbstractChains}" href="#MCPhylo.gelmandiag-Tuple{AbstractChains}"><code>MCPhylo.gelmandiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gelmandiag(c::AbstractChains; alpha::Real=0.05, mpsrf::Bool=false,
            transform::Bool=false)</code></pre><p>Compute the convergence diagnostics of Gelman, Rubin, and Brooks for MCMC sampler output. The diagnostics are designed to asses convergence of posterior means estimated with multiple autocorrelated samples (chains). They does so by comparing the between and within-chain variances with metrics called potential scale reduction factors (PSRF). Both univariate and multivariate factors are available to assess the convergence of parameters individually and jointly. Scale factors close to one are indicative of convergence. As a rule of thumb, convergence is concluded if the 0.975 quantile of an estimated factor is less than 1.2. Multiple chains are required for calculations. It is recommended that at least three chains be generated, each with different starting values chosen to be diffuse with respect to the anticipated posterior distribution. Use of multiple chains in the diagnostic provides for more robust assessment of convergence than is possible with single chain diagnostics.</p><p>Returns a <code>ChainSummary</code> type object of the form:</p><pre><code class="nohighlight hljs">struct ChainSummary
  value::Array{Float64, 3}
  rownames::Vector{AbstractString}
  colnames::Vector{AbstractString}
  header::AbstractString
end</code></pre><p>with parameters contained in the rows of the <code>value</code> field, and scale reduction factors and upper-limit quantiles in the first and second columns.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>alpha</code> : quantile (<code>1 - alpha / 2</code>) at which to estimate the upper limits of scale reduction factors.</p></li><li><p><code>mpsrf</code> : whether to compute the multivariate potential scale reduction factor. This factor will not be calculable if any one of the parameters in the output is a linear combination of others.</p></li><li><p><code>transform</code> : whether to apply log or logit transformations, as appropriate, to parameters in the chain to potentially produce output that is more normally distributed, an assumption of the PSRF formulations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/gelmandiag.jl#L2-L27">source</a></section></article><h2 id="Geweke-Diagnostic"><a class="docs-heading-anchor" href="#Geweke-Diagnostic">Geweke Diagnostic</a><a id="Geweke-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Geweke-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.gewekediag" href="#MCPhylo.gewekediag"><code>MCPhylo.gewekediag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gewekediag(x::Vector{T}; first::Real=0.1, last::Real=0.5,
            etype=:imse, args...) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/gewekediag.jl#L2-L7">source</a></section><section><div><pre><code class="nohighlight hljs">gewekediag(c::AbstractChains; first::Real=0.1, last::Real=0.5,
            etype=:imse, args...)</code></pre><p>Compute the convergence diagnostic of Geweke [37] for MCMC sampler output. The diagnostic is designed to asses convergence of posterior means estimated with autocorrelated samples. It computes a normal-based test statistic comparing the sample means in two windows containing proportions of the first and last iterations. Users should ensure that there is sufficient separation between the two windows to assume that their samples are independent. A non-significant test p-value indicates convergence. Significant p-values indicate non-convergence and the possible need to discard initial samples as a burn-in sequence or to simulate additional samples.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field, and test Z-scores and p-values in the first and second columns. Results are chain-specific.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>first</code> : proportion of iterations to include in the first window.</p></li><li><p><code>last</code> : proportion of iterations to include in the last window.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/gewekediag.jl#L30-L49">source</a></section></article><h2 id="Heidel-Diagnostic"><a class="docs-heading-anchor" href="#Heidel-Diagnostic">Heidel Diagnostic</a><a id="Heidel-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Heidel-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.heideldiag" href="#MCPhylo.heideldiag"><code>MCPhylo.heideldiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heideldiag(x::Vector{T}; alpha::Real=0.05, eps::Real=0.1,
            etype=:imse, start::Integer=1, args...) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/heideldiag.jl#L2-L5">source</a></section><section><div><pre><code class="nohighlight hljs">heideldiag(c::AbstractChains; alpha::Real=0.05, eps::Real=0.1,
            etype=:imse, args...)</code></pre><p>Compute the convergence diagnostic of Heidelberger and Welch for MCMC sampler output. The diagnostic is designed to assess convergence of posterior means estimated with autocorrelated samples and to determine whether a target degree of accuracy is achieved. A stationarity test is performed for convergence assessment by iteratively discarding 10% of the initial samples until the test p-value is non-significant and stationarity is concluded or until 50% have been discarded and stationarity is rejected, whichever occurs first. Then, a halfwidth test is performed by calculating the relative halfwidth of a posterior mean estimation interval as <span>$z_{1 - \alpha / 2} \hat{s} / |\bar{\theta}|$</span>; where <span>$z$</span> is a standard normal quantile, <span>$\hat{s}$</span> is the Monte Carlo standard error, and <span>$\bar{\theta}$</span> is the estimated posterior mean. If the relative halfwidth is greater than a target ratio, the test is rejected. Rejection of the stationarity or halfwidth test suggests that additional samples are needed.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field, and numbers of burn-in sequences to discard, whether the stationarity tests are passed (1 = yes, 0 = no), their p-values (<span>$p &gt; \alpha$</span> implies stationarity), posterior means, halfwidths of their <span>$(1 - \alpha) 100\%$</span> estimation intervals, and whether the halfwidth tests are passed (1 = yes, 0 = no) in the columns. Results are chain-specific.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>alpha</code> : significance level for evaluations of stationarity tests and calculations of relative estimation interval halfwidths.</p></li><li><p><code>eps</code> : target ratio for the relative halfwidths.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li><li><p><code>start</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/heideldiag.jl#L37-L59">source</a></section></article><h2 id="Raftery-and-Lewis-Diagnostic"><a class="docs-heading-anchor" href="#Raftery-and-Lewis-Diagnostic">Raftery and Lewis Diagnostic</a><a id="Raftery-and-Lewis-Diagnostic-1"></a><a class="docs-heading-anchor-permalink" href="#Raftery-and-Lewis-Diagnostic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.rafterydiag" href="#MCPhylo.rafterydiag"><code>MCPhylo.rafterydiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rafterydiag(x::Vector{T}; q::Real=0.025, r::Real=0.005,
                  s::Real=0.95, eps::Real=0.001,
                  range::AbstractRange=1:1:length(x)) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/rafterydiag.jl#L2-L6">source</a></section><section><div><pre><code class="nohighlight hljs">rafterydiag(c::AbstractChains; q::Real=0.025, r::Real=0.005,
                 s::Real=0.95, eps::Real=0.001)</code></pre><p>Compute the convergence diagnostic of Raftery and Lewis for MCMC sampler output. The diagnostic is designed to determine the number of autocorrelated samples required to estimate a specified quantile <span>$\theta_q$</span>, such that <span>$\Pr(\theta \le \theta_q) = q$</span>, within a desired degree of accuracy. In particular, if <span>$\hat{\theta}_q$</span> is the estimand and <span>$\Pr(\theta \le \hat{\theta}_q) = \hat{P}_q$</span> the estimated cumulative probability, then accuracy is specified in terms of r and s, where <span>$\Pr(q - r &lt; \hat{P}_q &lt; q + r) = s$</span>. Thinning may be employed in the calculation of the diagnostic to satisfy its underlying assumptions. However, users may not want to apply the same (or any) thinning when estimating posterior summary statistics because doing so results in a loss of information. Accordingly, sample sizes estimated by the diagnostic tend to be conservative (too large).</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the value field, and thinning intervals employed, numbers of samples to discard as burn-in sequences, total numbers <span>$(N)$</span> to burn-in and retain, numbers of independent samples that would be needed <span>$(Nmin)$</span>, and dependence factors <span>$(N / Nmin)$</span> in the columns. Results are chain-specific.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>q</code> : posterior quantile of interest.</p></li><li><p><code>r</code> : margin of error for estimated cumulative probabilities.</p></li><li><p><code>s</code> : probability for the margin of error.</p></li><li><p><code>eps</code> : tolerance within which the probabilities of transitioning from initial to retained iterations are within the equilibrium probabilities for the chain. This argument determines the number of samples to discard as a burn-in sequence and is typically left at its default value.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li><li><p><code>range</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/rafterydiag.jl#L56-L77">source</a></section></article><h2 id="Average-Standard-Deviation-of-Split-Frequencies"><a class="docs-heading-anchor" href="#Average-Standard-Deviation-of-Split-Frequencies">Average Standard Deviation of Split Frequencies</a><a id="Average-Standard-Deviation-of-Split-Frequencies-1"></a><a class="docs-heading-anchor-permalink" href="#Average-Standard-Deviation-of-Split-Frequencies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.ASDSF" href="#MCPhylo.ASDSF"><code>MCPhylo.ASDSF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ASDSF(args::String...; freq::Int64=1, check_leaves::Bool=true,
      min_splits::Float64=0.1, show_progress::Bool=true)::Vector{Float64}</code></pre><p>Calculate the average standard deviation of split frequencies for two or more files containing newick representations of trees. Default frequency is 1 and by default only trees with the same leafsets are supported. The default minimal splits threshold is 0.1. The progress bar is activated by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/asdsf.jl#L1-L9">source</a></section><section><div><pre><code class="nohighlight hljs">ASDSF(args::Vector{String}...; freq::Int64=1, check_leaves::Bool=true,
      min_splits::Float64=0.1, show_progress::Bool=true)::Vector{Float64}</code></pre><p>Calculate the average standard deviation of split frequencies for two or more Vectors containing newick representations of trees. Default frequency is 1 and by default only trees with the same leafsets are supported. The default minimal splits threshold is 0.1. The progress bar is activated by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/asdsf.jl#L32-L40">source</a></section><section><div><pre><code class="nohighlight hljs">ASDSF(model::ModelChains; freq::Int64=1, check_leaves::Bool=true,
      min_splits::Float64=0.1, show_progress::Bool=true
      )::Vector{Vector{Float64}}</code></pre><p>Calculate the average standard deviation of split frequencies for the trees in different chains in a ModelChains object. Default frequency is 1 and by default only trees with the same leafsets are supported. The default minimal splits threshold is 0.1. The progress bar is activated by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/asdsf.jl#L59-L68">source</a></section><section><div><pre><code class="nohighlight hljs">ASDSF(r_channels::Vector{RemoteChannel}, n_trees::Int64,
      tree_dims::UnitRange{Int64}, min_splits::Float64
      )::Tuple{Vector{Vector{Float64}}, ConvergenceStorage}</code></pre><p>–- INTERNAL –- Calculates - on-the-fly - the average standard deviation of split frequencies for the trees generated by MCMC draws from a model. Takes a vector of remote channels (where the generated trees are stored during the mcmc simulation) and the total number of trees in each chain as arguments. The default minimal splits threshold is 0.1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/asdsf.jl#L97-L108">source</a></section></article><h2 id="Monte-Carlo-Standard-Errors"><a class="docs-heading-anchor" href="#Monte-Carlo-Standard-Errors">Monte Carlo Standard Errors</a><a id="Monte-Carlo-Standard-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-Standard-Errors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.mcse" href="#MCPhylo.mcse"><code>MCPhylo.mcse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcse(x::Vector{T}, method::Symbol=:imse; args...) where {T&lt;:Real}</code></pre><p>Compute Monte Carlo standard errors.</p><p>Returns the numeric standard error value.</p><ul><li><p><code>x</code> : time series of values on which to perform calculations.</p></li><li><p><code>method</code> : method used for the calculations. Options are</p><ul><li><p><code>:bm</code> : batch means, with optional argument <code>size::Integer=100</code> determining the number of sequential values to include in each batch. This method requires that the number of values in <code>x</code> is at least 2 times the batch size.</p></li><li><p><code>:imse</code> : initial monotone sequence estimator.</p></li><li><p><code>:ipse</code> : initial positive sequence estimator.</p></li></ul></li><li><p><code>args...</code> : additional arguments for the calculation method.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/mcse.jl#L2-L19">source</a></section></article><h2 id="ModelChains"><a class="docs-heading-anchor" href="#ModelChains">ModelChains</a><a id="ModelChains-1"></a><a class="docs-heading-anchor-permalink" href="#ModelChains" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.ModelChains" href="#MCPhylo.ModelChains"><code>MCPhylo.ModelChains</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelChains(c::Chains, m::Model)</code></pre><p>See <code>Chains()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/modelchains.jl#L4-L8">source</a></section></article><h2 id="Model-Based-Inference"><a class="docs-heading-anchor" href="#Model-Based-Inference">Model-Based Inference</a><a id="Model-Based-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Based-Inference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf" href="#Distributions.logpdf"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logpdf(mc::ModelChains,
       nodekeys::Vector{Symbol}=keys(mc.model, :stochastic))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/modelstats.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf-Tuple{ModelChains, Function, Vector{Symbol}}" href="#Distributions.logpdf-Tuple{ModelChains, Function, Vector{Symbol}}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logpdf(mc::ModelChains, f::Function, nodekeys::Vector{Symbol})</code></pre><p>Compute the sum of log-densities at each iteration of MCMC output for stochastic nodes.</p><p>Returns a <code>ModelChains</code> object of resulting summed log-densities at each MCMC iteration of the supplied chain.</p><ul><li><p><code>mc</code> : sampler output from a model fit with the <code>mcmc()</code>` function.</p></li><li><p><code>nodekey/nodekeys</code> : stochastic model node(s) over which to sum densities (default: all).</p></li><li><p><code>f</code> : ??</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/modelstats.jl#L31-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.dic-Tuple{ModelChains}" href="#MCPhylo.dic-Tuple{ModelChains}"><code>MCPhylo.dic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dic(mc::ModelChains)</code></pre><p>Compute the Deviance Information Criterion (DIC) of Spiegelhalter et al. and Gelman et al. from MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with DIC results from the methods of Spiegelhalter and Gelman in the first and second rows of the <code>value</code> field, and the DIC value and effective numbers of parameters in the first and second columns; where</p><p><span>$\text{DIC} = -2 \mathcal{L}(\bar{\Theta}) + 2 p,$</span></p><p>such that <span>$\mathcal{L}(\bar{\Theta})$</span> is the log-likelihood of model outputs given the expected values of model parameters <span>$\Theta$</span>, and <span>$p$</span> is the effective number of parameters. The latter is defined as <span>$p_D = -2 \bar{\mathcal{L}}(\Theta) + 2 \mathcal{L}(\bar{\Theta})$</span> for the method of Spiegelhalter and as <span>$p_V = \frac{1}{2} \operatorname{var}(-2 \mathcal{L}(\Theta))$</span> for the method of Gelman. Results are for all chains combined.</p><ul><li><code>mc</code> : sampler output from a model fit with the <code>mcmc()</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/modelstats.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict" href="#StatsAPI.predict"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict(mc::ModelChains,
         nodekeys::Vector{Symbol}=keys(mc.model, :output))</code></pre><p>Generate MCMC draws from a posterior predictive distribution.</p><p>Returns a <code>ModelChains</code> object of draws simulated at each MCMC iteration of the supplied chain. For observed data node <span>$y$</span>, simulation is from the posterior predictive distribution</p><p><span>$p(\tilde{y} | y) = \int p(\tilde{y} | \Theta) p(\Theta | y) d\Theta,$</span></p><p>where <span>$\tilde{y}$</span> is an unknown observation on the node, <span>$p(\tilde{y} | \Theta)$</span> is the data likelihood, and <span>$p(\Theta | y)$</span> is the posterior distribution of unobserved parameters <span>$\Theta$</span>.</p><ul><li><p><code>mc</code> : sampler output from a model fit with the <code>mcmc()</code>` function.</p></li><li><p><code>nodekey/nodekeys</code> : observed Stochastic model node(s) for which to generate draws from the predictive distribution (default: all observed data nodes).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/modelstats.jl#L142-L157">source</a></section></article><h2 id="Plot"><a class="docs-heading-anchor" href="#Plot">Plot</a><a id="Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Plot" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.bar_int-Tuple{AbstractChains, Vector{Int64}}" href="#MCPhylo.bar_int-Tuple{AbstractChains, Vector{Int64}}"><code>MCPhylo.bar_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bar_int(c::AbstractChains, indeces::Vector{Int64}; args...)::Plots.Plot</code></pre><p>–- INTERNAL –- Helper function for creating barplots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L276-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.check_filename-Tuple{Any, Any, Any}" href="#MCPhylo.check_filename-Tuple{Any, Any, Any}"><code>MCPhylo.check_filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_filename(filename, fmt, plots)</code></pre><p>–- INTERNAL –- Helper function that checks if a user-given filename is valid, and saves the created plots to that file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.check_vars-Tuple{Vector{AbstractString}, Vector{String}}" href="#MCPhylo.check_vars-Tuple{Vector{AbstractString}, Vector{String}}"><code>MCPhylo.check_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>check<em>vars(sim</em>names::Vector{AbstractString},              vars::Vector{String})::Vector{Int64}</p><p>–- INTERNAL –- Helper function that returns a list of indeces that correspond to specific variables. Only those variables are then plotted in the following steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.groupedbar_fillrange-Tuple{Any}" href="#MCPhylo.groupedbar_fillrange-Tuple{Any}"><code>MCPhylo.groupedbar_fillrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">groupedbar_fillrange(y)</code></pre><p>–- INTERNAL –- Helper function for the groupbar plot</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L593-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.mixeddensityplot-Tuple{AbstractChains, Vector{Int64}}" href="#MCPhylo.mixeddensityplot-Tuple{AbstractChains, Vector{Int64}}"><code>MCPhylo.mixeddensityplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mixeddensityplot(c::AbstractChains,, indeces::Vector{Int64};
                 barbounds::Tuple{Real, Real}=(0, Inf), args...):Plots.Plot</code></pre><p>–- INTERNAL –- Helper function that creates a barplot for each discrete and a density for each continuous variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L429-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.plot_asdsf-Tuple{AbstractChains}" href="#MCPhylo.plot_asdsf-Tuple{AbstractChains}"><code>MCPhylo.plot_asdsf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>plot_asdsf(c::AbstractChains; args...)::Plots.Plot</p><p>–- INTERNAL –- Plot the ASDSF values of an Abstract Chains object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L627-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.ASDSF_trace}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.ASDSF_trace}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(vals::ASDSF_trace)</code></pre><p>–- INTERNAL –- Recipe for trace plots of ASDSF values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L651-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Autocor}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Autocor}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(acor::Autocor)</code></pre><p>–- INTERNAL –- Recipe for Autocor plots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Contour}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Contour}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(cont::Contour)</code></pre><p>–- INTERNAL –- Recipe for contour plots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L312-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Density}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Density}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(dens::Density)</code></pre><p>–- INTERNAL –- Recipe for density plots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L360-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.GroupBar}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.GroupBar}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(g::GroupBar; spacing=0)</code></pre><p>–- INTERNAL –- Recipe for a grouped bar plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L515-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Mean}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Mean}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(mean::Mean)</code></pre><p>–- INTERNAL –- Recipe for mean plots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L397-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Trace}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, MCPhylo.Trace}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(trace::Trace)</code></pre><p>–- INTERNAL –- Recipe for trace plots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L472-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot" href="#RecipesBase.plot"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(c::AbstractChains, ptype::Vector{Symbol}=[:trace, :density];
   &lt;keyword arguments&gt;)::Array{Plots.Plot}</code></pre><p>Function that takes a MCMC chain and creates various different plots (trace &amp; density by default).</p><p><strong>Arguments</strong></p><ul><li><p>&#39;vars::Vector{String}=String[]&#39;: specifies the variables of the chain that                                  are plotted. Trick: Instead of inputting                                  [varname[1], varname[2], varname[3], ...]                                  you can simply write [varname]. The function                                  will understand that you want all variables                                  with that name.</p></li><li><p>&#39;filename::String=&quot;&quot;&#39;: when given, the plots will be saved to a file</p></li><li><p>&#39;fmt::Symbol=:pdf&#39;: Format of the output file</p></li><li><p>&#39;fuse::Bool=false&#39;: Fuse all of the plots into one big plot, instead of                     displaying each of the different plot types separately</p></li><li><p>&#39;f_layout=nothing&#39;: Layout for the fused plot.</p></li><li><p>&#39;fsize::Tuple(Number, Number)=(0,0)&#39;: Size of the fused plot.</p></li><li><p>&#39;force::Bool=false&#39;: Force plotting of more than 20 variables.</p></li><li><p>&#39;args...&#39;: This includes specific arguments for the different plot types            , like the number of bins for the contourplot or if the barplots            bars should be stacked or not. Check the specific plot functions            to use these arguments.</p><pre><code class="nohighlight hljs">      Plot attributes from the Plots.jl package can also be passed here:
      I.e. try passing background_color=:black for a black background on
      your plots. List of attributes here,
      https://docs.juliaplots.org/latest/generated/attributes_series/
      https://docs.juliaplots.org/latest/generated/attributes_plot/
      https://docs.juliaplots.org/latest/generated/attributes_subplot/
      https://docs.juliaplots.org/latest/generated/attributes_axis/
      though not all are supported:
      https://docs.juliaplots.org/latest/generated/supported/</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/plot.jl#L1-L36">source</a></section></article><h2 id="Posterior-Summary-Statistics"><a class="docs-heading-anchor" href="#Posterior-Summary-Statistics">Posterior Summary Statistics</a><a id="Posterior-Summary-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Posterior-Summary-Statistics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.describe-Tuple{IO, AbstractChains}" href="#DataAPI.describe-Tuple{IO, AbstractChains}"><code>DataAPI.describe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">describe(io::IO, c::AbstractChains;
              q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975], etype=:bm, args...)</code></pre><p>Compute summary statistics for MCMC sampler output.</p><p>Returns results from calls to <code>summarystats(c, etype, args...)</code> and <code>quantile(c, q)</code> are printed for all chains combined, and a value of <code>nothing</code> is returned.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>q</code> : probabilities at which to calculate quantiles.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L70-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.changerate-Tuple{AbstractChains}" href="#MCPhylo.changerate-Tuple{AbstractChains}"><code>MCPhylo.changerate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changerate(c::AbstractChains)</code></pre><p>Estimate the probability, or rate per iteration, <span>$\Pr(\theta^i \ne \theta^{i-1})$</span> of a state space change for iterations <span>$i = 2, \ldots, N$</span> in MCMC sampler output. Estimation is performed for each parameter univariately as well as for the full parameter vector multivariately. For continuous output generated from samplers, like Metropolis-Hastings, whose algorithms conditionally accept candidate draws, the probability can be viewed as the acceptance rate.</p><p>Returns a <code>ChainSummary</code> type object with parameters in the rows of the <code>value</code> field, and the estimated rates in the column. Results are for all chains combined.</p><ul><li><code>c</code> : sampler output on which to perform calculations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.hpd-Tuple{AbstractChains}" href="#MCPhylo.hpd-Tuple{AbstractChains}"><code>MCPhylo.hpd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hpd(c::AbstractChains; alpha::Real=0.05)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L125-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhylo.hpd-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#MCPhylo.hpd-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>MCPhylo.hpd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hpd(x::Vector{T}; alpha::Real=0.05) where {T&lt;:Real}</code></pre><p>Compute highest posterior density (HPD) intervals of Chen and Shao [16] for MCMC sampler output. HPD intervals have the desirable property of being the smallest intervals that contain a given probability. However, their calculation assumes unimodal marginal posterior distributions, and they are not invariant to transformations of parameters like central (quantile-based) posterior intervals.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the value field, and lower and upper intervals in the first and second columns. Results are for all chains combined.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>alpha</code> : the <code>100 * (1 - alpha)</code>% interval to compute.</p></li><li><p><code>x</code> : vector on which to perform calculations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L101-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.cor-Tuple{AbstractChains}" href="#Statistics.cor-Tuple{AbstractChains}"><code>Statistics.cor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cor(c::AbstractChains)</code></pre><p>Compute cross-correlations for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with the first and second dimensions of the <code>value</code> field indexing the model parameters between which correlations. Results are for all chains combined.</p><ul><li><code>c</code> : sampler output on which to perform calculations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.quantile-Tuple{AbstractChains}" href="#Statistics.quantile-Tuple{AbstractChains}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quantile(c::AbstractChains; q::Vector=[0.025, 0.25, 0.5, 0.75, 0.975])</code></pre><p>Compute posterior quantiles for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with parameters contained in the rows of the <code>value</code> field, and quantiles in the columns. Results are for all chains combined.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>q</code> : probabilities at which to compute quantiles.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.autocor-Tuple{AbstractChains}" href="#StatsBase.autocor-Tuple{AbstractChains}"><code>StatsBase.autocor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autocor(c::AbstractChains; lags::Vector=[1, 5, 10, 50],
         relative::Bool=true)</code></pre><p>Compute lag-k autocorrelations for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with model parameters indexed by the first dimension of <code>value</code>, lag-autocorrelations by the second, and chains by the third.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>lags</code> : lags at which to compute autocorrelations.</p></li><li><p><code>relative</code> : whether the lags are relative to the thinning interval of the output (<code>true</code>) or relative to the absolute iteration numbers (<code>false</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.summarystats-Tuple{AbstractChains}" href="#StatsBase.summarystats-Tuple{AbstractChains}"><code>StatsBase.summarystats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">summarystats(c::AbstractChains; etype=:bm, args...)</code></pre><p>Compute posterior summary statistics for MCMC sampler output.</p><p>Returns a <code>ChainSummary</code> type object with parameters in the rows of the <code>value</code> field; and the sample mean, standard deviation, standard error, Monte Carlo standard error, and effective sample size in the columns. Results are for all chains combined.</p><ul><li><p><code>c</code> : sampler output on which to perform calculations.</p></li><li><p><code>etype</code> : method for computing Monte Carlo standard errors. See <code>mcse()</code> for options.</p></li><li><p><code>args...</code> : additional arguments to be passed to the <code>etype</code> method.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhylo.jl/blob/132aa8273a16899016484694bb83c2be61bfca64/src/output/stats.jl#L154-L166">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model/">« Model</a><a class="docs-footer-nextpage" href="../samplers/">Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Monday 16 May 2022 15:01">Monday 16 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
